<?xml version="1.0" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
    <title>Блог Андрея Акиньшина</title>
    <link>http://aakinshin.net/</link>
    <atom:link href="http://aakinshin.net/rss.xml" rel="self" type="application/rss+xml" />
    <description></description>
    <language>ru-ru</language>
    <pubDate>Thu, 26 Feb 2015 09:05:17 GMT</pubDate>
    <lastBuildDate>Thu, 26 Feb 2015 09:05:17 GMT</lastBuildDate>

            <item>
                <title>История про инлайнинг под JIT-x86 и starg</title>
                <link>http://aakinshin.net/ru/blog/dotnet/inlining-and-starg/</link> 	
                <pubDate>Thu, 26 Feb 2015 00:00:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/inlining-and-starg/</guid>
                <description>&lt;p&gt;Порой можно узнать много интересного во время чтения исходников .NET. Взглянем на конструктор типа &lt;code&gt;Decimal&lt;/code&gt; из .NET Reference Source (&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158&quot;&gt;mscorlib/system/decimal.cs,158&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Constructs a Decimal from an integer value.
//
public Decimal(int value) {
    //  JIT today can&#39;t inline methods that contains &amp;quot;starg&amp;quot; opcode.
    //  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &amp;quot;starg&amp;quot;.
    int value_copy = value;
    if (value_copy &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value_copy = -value_copy;
    }
    lo = value_copy;
    mid = 0;
    hi = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В комментарии сказано, что если метод содержит IL-опкод &lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx&quot;&gt;starg&lt;/a&gt;, то он не может быть заинлайнен под x86. Любопытно, не правда ли?&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;Исходники JIT&lt;/h3&gt;
&lt;p&gt;Давайте разберёмся в ситуации. Заглянем в исходники JIT из CoreCLR. Фрагмент файла &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252&quot;&gt;flowgraph.cpp&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// NetCF had some strict restrictions on inlining.  Specifically they
// would only inline methods that fit a specific pattern of loading
// arguments inorder, starting with zero, with no skipping, but not
// needing to load all of them.  Then a &#39;body&#39; section that could do
// anything besides control flow.  And a final ending ret opcode.
// Lastly they did not allow starg or ldarga.
// These simplifications allowed them to skip past the ldargs, when
// inlining, and just use the caller&#39;s EE stack as the callee&#39;s EE
// stack, after optionally popping a few &#39;arguments&#39; from the end.
//
// stateNetCFQuirks is a simple state machine to track that state
// and allow us to match those restrictions.
// State -1 means we&#39;re not tracking (no quirks mode)
// State 0 though 0x0000FFFF tracks what the *next* ldarg should be
//    to match the pattern
// State 0x00010000 and above means we are in the &#39;body&#39; section and
//    thus no more ldarg&#39;s are allowed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Комментарий гласит, что если метод содержит IL-команду &lt;code&gt;starg&lt;/code&gt; или &lt;code&gt;ldarga&lt;/code&gt;, то инлайнинг не выполнится. Почитаем код и убедимся, что это действительно так. Вскоре после комментария происходит выбор опкода:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;switch (opcode)

// ...

    case CEE_STARG:
    case CEE_STARG_S:     goto ARG_WRITE;

    case CEE_LDARGA:
    case CEE_LDARGA_S:
    case CEE_LDLOCA:
    case CEE_LDLOCA_S:    goto ADDR_TAKEN;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Случай с командой &lt;code&gt;starg&lt;/code&gt; попроще, взглянем на него более внимательно:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;ARG_WRITE:
            if (compIsForInlining())
            {

#ifdef DEBUG
                if (verbose)
                {
                    printf(&amp;quot;\n\nInline expansion aborted due to opcode at offset [%02u] which writes to an argument\n&amp;quot;,
                           codeAddr-codeBegp-1);
                }
#endif

                /* The inliner keeps the args as trees and clones them.  Storing the arguments breaks that
                 * simplification.  To allow this, flag the argument as written to and spill it before
                 * inlining.  That way the STARG in the inlinee is trivial. */
                inlineFailReason = &amp;quot;Inlinee writes to an argument.&amp;quot;;
                goto InlineNever;
            }
            else
            {
                noway_assert(sz == sizeof(BYTE) || sz == sizeof(WORD));
                if (codeAddr &amp;gt; codeEndp - sz)
                goto TOO_FAR;
                varNum = (sz == sizeof(BYTE)) ? getU1LittleEndian(codeAddr)
                                              : getU2LittleEndian(codeAddr);
                varNum = compMapILargNum(varNum); // account for possible hidden param

                // This check is only intended to prevent an AV.  Bad varNum values will later
                // be handled properly by the verifier.
                if (varNum &amp;lt; lvaTableCnt)
                    lvaTable[varNum].lvArgWrite = 1;
            }
            break;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Действительно, всё выглядит так, что для опкода &lt;code&gt;starg&lt;/code&gt; в конечном итоге выполнится &lt;code&gt;goto InlineNever&lt;/code&gt;. В &lt;code&gt;DEBUG&lt;/code&gt;-режиме мы также получим сообщение, что процесс инлайнинга был прерван.&lt;/p&gt;
&lt;p&gt;Эта &#171;фича&#187; используется в других местах JIT-а. Взглянем на фрагмент файла &lt;a href=&quot;https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp&quot;&gt;importer.cpp&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;/******************************************************************************
 Is this the original &amp;quot;this&amp;quot; argument to the call being inlined?
 
 Note that we do not inline methods with &amp;quot;starg 0&amp;quot;, and so we do not need to
 worry about it.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Смотрим на Decimal&lt;/h3&gt;
&lt;p&gt;Вернёмся к нашему конструктору класса &lt;code&gt;Decimal&lt;/code&gt;, убедимся, что копирование параметра &lt;code&gt;value&lt;/code&gt; в локальную переменную действительно помогает. Вооружимся &lt;a href=&quot;http://ilspy.net/&quot;&gt;ILSpy&lt;/a&gt; и взглянем на IL-код нашего конструктора:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Methods
.method public hidebysig specialname rtspecialname 
  instance void .ctor (
    int32 &#39;value&#39;
  ) cil managed 
{
  .custom instance void __DynamicallyInvokableAttribute::.ctor() = (
    01 00 00 00
  )
  // Method begins at RVA 0x222e8
  // Code size 51 (0x33)
  .maxstack 2
  .locals init (
    [0] int32
  )

  IL_0000: ldarg.1
  IL_0001: stloc.0
  IL_0002: ldloc.0
  IL_0003: ldc.i4.0
  IL_0004: blt.s IL_000f

  IL_0006: ldarg.0
  IL_0007: ldc.i4.0
  IL_0008: stfld int32 System.Decimal::&#39;flags&#39;
  IL_000d: br.s IL_001d

  IL_000f: ldarg.0
  IL_0010: ldc.i4 -2147483648
  IL_0015: stfld int32 System.Decimal::&#39;flags&#39;
  IL_001a: ldloc.0
  IL_001b: neg
  IL_001c: stloc.0

  IL_001d: ldarg.0
  IL_001e: ldloc.0
  IL_001f: stfld int32 System.Decimal::lo
  IL_0024: ldarg.0
  IL_0025: ldc.i4.0
  IL_0026: stfld int32 System.Decimal::mid
  IL_002b: ldarg.0
  IL_002c: ldc.i4.0
  IL_002d: stfld int32 System.Decimal::hi
  IL_0032: ret
} // end of method Decimal::.ctor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А что было бы, если бы мы не скопировали &lt;code&gt;value&lt;/code&gt; в локальную переменную? Давайте проверим. Напишем простой код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class MyDecimal
{
  private const int SignMask  = unchecked((int)0x80000000);
  private int flags, hi, lo, mid;

  public MyDecimal(int value)
  {
    if (value &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value = -value;
    }
    lo = value;
    mid = 0;
    hi = 0;
  }
}
class Program
{
  static void Main()
  {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Скомпилируем его:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;csc Program.cs /optimize
Microsoft (R) Visual C# Compiler version 4.0.30319.33440
for Microsoft (R) .NET Framework 4.5
Copyright (C) Microsoft Corporation. All rights reserved.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И взглянем на IL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.class private auto ansi beforefieldinit MyDecimal
  extends [mscorlib]System.Object
{
  // Fields
  .field private static literal int32 SignMask = int32(-2147483648)
  .field private int32 &#39;flags&#39;
  .field private int32 hi
  .field private int32 lo
  .field private int32 mid

  // Methods
  .method public hidebysig specialname rtspecialname 
    instance void .ctor (
      int32 &#39;value&#39;
    ) cil managed 
  {
    // Method begins at RVA 0x2050
    // Code size 56 (0x38)
    .maxstack 8

    IL_0000: ldarg.0
    IL_0001: call instance void [mscorlib]System.Object::.ctor()
    IL_0006: ldarg.1
    IL_0007: ldc.i4.0
    IL_0008: blt.s IL_0013

    IL_000a: ldarg.0
    IL_000b: ldc.i4.0
    IL_000c: stfld int32 MyDecimal::&#39;flags&#39;
    IL_0011: br.s IL_0022

    IL_0013: ldarg.0
    IL_0014: ldc.i4 -2147483648
    IL_0019: stfld int32 MyDecimal::&#39;flags&#39;
    IL_001e: ldarg.1
    IL_001f: neg
    IL_0020: starg.s &#39;value&#39;

    IL_0022: ldarg.0
    IL_0023: ldarg.1
    IL_0024: stfld int32 MyDecimal::lo
    IL_0029: ldarg.0
    IL_002a: ldc.i4.0
    IL_002b: stfld int32 MyDecimal::mid
    IL_0030: ldarg.0
    IL_0031: ldc.i4.0
    IL_0032: stfld int32 MyDecimal::hi
    IL_0037: ret
  } // end of method MyDecimal::.ctor

} // end of class MyDecimal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как мы видим, в строчке &lt;code&gt;IL_0020&lt;/code&gt; действительно вызывается команда &lt;code&gt;starg.a&lt;/code&gt;. Подобный приём используется также в конструкторе, который принимает аргумент типа &lt;code&gt;long&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Constructs a Decimal from a long value.
//
public Decimal(long value) {
    //  JIT today can&#39;t inline methods that contains &amp;quot;starg&amp;quot; opcode.
    //  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &amp;quot;starg&amp;quot;.
    long value_copy = value;
    if (value_copy &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value_copy = -value_copy;
    }
    lo = (int)value_copy;
    mid = (int)(value_copy &amp;gt;&amp;gt; 32);
    hi = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Проверяем возможности JIT&lt;/h3&gt;
&lt;p&gt;Для полноты исследования осталось убедиться, что JIT действительно себя ведёт именно так. Напишем простой код для проверки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Runtime.CompilerServices;

class Program
{
    static void Main()
    {
        var value = 0;
        value += SimpleMethod(0x11);
        value += MethodWithStarg(0x12);
        value += MethodWithStargAggressive(0x13);
        Console.WriteLine(value);
    }

    static int SimpleMethod(int value)
    {
        return value;
    }

    static int MethodWithStarg(int value)
    {
        if (value &amp;lt; 0)
            value = -value;
        return value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static int MethodWithStargAggressive(int value)
    {
        if (value &amp;lt; 0)
            value = -value;
        return value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Метод &lt;code&gt;SimpleMethod&lt;/code&gt; очень маленький и будет заинлайнен. Метод &lt;code&gt;MethodWithStarg&lt;/code&gt; имеет следующее IL-представление:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;.method private hidebysig static 
  int32 MethodWithStarg (
    int32 &#39;value&#39;
  ) cil managed 
{
  // Method begins at RVA 0x2086
  // Code size 10 (0xa)
  .maxstack 8

  IL_0000: ldarg.0
  IL_0001: ldc.i4.0
  IL_0002: bge.s IL_0008

  IL_0004: ldarg.0
  IL_0005: neg
  IL_0006: starg.s &#39;value&#39;

  IL_0008: ldarg.0
  IL_0009: ret
} // end of method Program::MethodWithStarg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Данный код в строчке &lt;code&gt;IL_0006&lt;/code&gt; содержит интересующую нас команду &lt;code&gt;starg.s&lt;/code&gt;. Метод &lt;code&gt;MethodWithStargAggressive&lt;/code&gt; имеет аналогичный код с той лишь разнице, что для него указан атрибут &lt;code&gt;[MethodImpl(MethodImplOptions.AggressiveInlining)]&lt;/code&gt;. Взглянем на ассемблерный код под x86:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;008A0050  push        ebp  
008A0051  mov         ebp,esp  
008A0053  push        esi  
008A0054  mov         ecx,12h  
008A0059  call        dword ptr ds:[7237BCh]  // MethodWithStarg
008A005F  add         eax,11h  
008A0062  mov         esi,eax  
008A0064  mov         ecx,13h  
008A0069  call        dword ptr ds:[7237C8h]  // MethodWithStargAggressive
008A006F  add         esi,eax  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Эксперимент прошёл успешно. Метод &lt;code&gt;SimpleMethod&lt;/code&gt; был заинлайнен, как и предполагалось. Метод &lt;code&gt;MethodWithStarg&lt;/code&gt; не был заинлайнен, т. к. содержит IL-команду &lt;code&gt;starg.s&lt;/code&gt;. Даже атрибут &lt;code&gt;[MethodImpl(MethodImplOptions.AggressiveInlining)]&lt;/code&gt; не поспособствовал тому, чтобы инлайнинг был выполнен.&lt;/p&gt;
&lt;p&gt;А теперь взглянем на ассемблерный код под x64:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00007FFCC8720094  mov         ecx,36h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как мы видим, JIT успешно выполнил инлайнинг всех методов и заранее предподсчитал результат.&lt;/p&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Для возможности инлайнинга методов необходимо выполнение ряда условий. JIT-x86 не может заинлайнить метод, в теле которого присутствуют IL-команды &lt;code&gt;starg&lt;/code&gt; или &lt;code&gt;ldarga&lt;/code&gt;, при этом даже &lt;code&gt;MethodImplOptions.AggressiveInlining&lt;/code&gt; не в силах на это повлиять. Если вам критично, чтобы JIT мог выполнять инлайнинг, то порой придётся делать костыли, подобные тем, которые мы можем наблюдать в конструкторах класса &lt;code&gt;Decimal&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158&quot;&gt;.NET Reference Source: Constructs a Decimal from an integer value&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252&quot;&gt;CoreCLR, JIT sources: flowgraph.cpp (Feb 26, 2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp&quot;&gt;CoreCLR, JIT sources: importer.cpp (Feb 26, 2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx&quot;&gt;MSDN: starg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.ldarga.aspx&quot;&gt;MSDN: ldarga&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/26369163/net-local-variable-optimization&quot;&gt;Stackoverflow: .NET local variable optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Как я блог на кренделёк переводил</title>
                <link>http://aakinshin.net/ru/blog/notes/migration-to-pretzel/</link> 	
                <pubDate>Thu, 26 Feb 2015 00:00:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/notes/migration-to-pretzel/</guid>
                <description>&lt;p&gt;Наконец-то у меня дошли руки, и я сделал себе статический блог. Раньше я писал посты в &lt;a href=&quot;http://aakinshin.blogspot.ru/&quot;&gt;aakinshin.blogspot.ru&lt;/a&gt; на Google Blogger aka blogspot, но много чего мне в нём не нравилось, отбивалось всё желание писать. Теперь всё работает через GitHub, писать посты можно в MarkDown, шаблоны делать через Razor, кастомизировать всё по своему вкусу. И мультиленг нормальный =). Под катом можно найти техническую информацию.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/notes/migration-to-pretzel/pretzel.png&quot; height=&quot;100px&quot; /&gt;
&lt;/p&gt;&lt;!--more--&gt;
&lt;h2&gt;Что не так с Blogspot&lt;/h2&gt;
&lt;p&gt;Чудо-блогодвижок от Google разражал меня по многим причинам. Обозначу некоторые из них:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Нет нормального редактора. Приходится верстать всё в HTML в примитивной форме без подсветки синтаксиса и валидаций.&lt;/li&gt;
&lt;li&gt;Нет нормального предварительного просмотра. Google рендерит только картинку будущего поста, в которую даже потыкать нельзя. А временами ещё и подтягивает местоположение по ip и рендерит всё в местной локали: скажем, если пользоваться функцией просмотра из Израиля, то велика вероятность увидеть большое количество иврита и right-to-left-вёрстку.&lt;/li&gt;
&lt;li&gt;Нет возможности кастомизировать URL-ы. Я перфекционист, и хочу, чтобы адреса постов формировались согласно моим представлениям об этом мире. Скажем, мне не нравится &lt;code&gt;.html&lt;/code&gt; в конце адреса. Указание текущего года и месяца в адресе также считаю лишним. А ещё хочется раскладывать посты по категориям, которые также бы присутствовали в URL-е.&lt;/li&gt;
&lt;li&gt;Нет возможности вести мультиленг-блог. Т. е., чтобы была возможность сделать русскую и английскую версию поста и легко между ними переключаться. Ну и, соответственно, чтобы были отдельные подверсии блога только с русскими и только английскими постами.&lt;/li&gt;
&lt;li&gt;Нет удобных возможностей для редактирования шаблона. Наверное, если потратить приличное количество времени, то можно в тамошнем редакторе что-то хорошее сделать, но мои попытки обернулись провалом.&lt;/li&gt;
&lt;li&gt;Нет возможности прикрутить любимый мною git, чтобы нормально работать с версиями.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В общем, решил я сделать себе статический блог.&lt;/p&gt;
&lt;h2&gt;Jekyll&lt;/h2&gt;
&lt;p&gt;Интернет подсказал мне, что многие крутые ребята ведут свои блоги на &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;. Отличное решение, приведу понравившиеся мне возможности:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Можно поднять блог через GitHub, прикрутить для отображения кастомный домен.&lt;/li&gt;
&lt;li&gt;Можно отлаживать блог локально без доступа к интернету.&lt;/li&gt;
&lt;li&gt;Можно писать посты в Markdown, а по мере надобности прибегать к HTML+CSS.&lt;/li&gt;
&lt;li&gt;Можно самому сформировать всю нужную разметку шаблонов на &lt;a href=&quot;https://github.com/Shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Можно относительно легко импортировать старые посты из Blogger.&lt;/li&gt;
&lt;li&gt;Можно прописывать все конфиги в YML.&lt;/li&gt;
&lt;li&gt;Можно расширять функциональность движка собственными плагинами.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В общем, всё было хорошо, ушли все проблемы, которые мне мешали жить во вселенной blogspot. Впрочем, возникли некоторые трудности:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Из коробки было далеко не всё, что я хотел видеть в своём новом бложике. Пришлось писать плагины. Jekyll написан на Ruby. И плагины тоже нужно писать на Ruby. Пришлось на старости лет освоить новый язык. Мне даже понравилось, прикольный код получается. Но после написания нескольких плагинчиков пришло осознание, что мне далеко до такого уровня Ruby-мастерства, на котором я смогу сделать эти плагины нормально. Эх, вот можно было бы нужный функционал писать на C#, было бы счастье.&lt;/li&gt;
&lt;li&gt;Liquid прикольный, но на нём далеко не всё делается настолько просто, настолько хотелось бы. Вот дали бы мне мой любимый Razor, жить было бы легче.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;И я понял, что мне в идеале нужен аналог Jekyll, но только на .NET-стеке.&lt;/p&gt;
&lt;h2&gt;Pretzel&lt;/h2&gt;
&lt;p&gt;Ещё немного поиска в интернете — и я нашёл его! Отличный проект под названием &lt;a href=&quot;https://github.com/Code52/pretzel&quot;&gt;pretzel&lt;/a&gt;. Совместим с Jekyll, можно писать функционал на C# и верстать шаблоны на Razor. Увы, проект немного сыроват, многие нужные штуки не работали. Пришлось чутка &lt;a href=&quot;https://github.com/Code52/pretzel/commits/master?author=AndreyAkinshin&quot;&gt;поконтрибьютить&lt;/a&gt; в проект, чтобы мой Jekyll-блог на нём завёлся. Затем ушло какое-то время, чтобы сделать нормальный мультиленг и сверстать всё так, чтобы выглядело хотя бы более или менее вменяемо. С базовой частью я наконец-то справился, блог завёлся и опубликовался в интернете. Остался, правда, небольшой набор тикетов (например, пагинатор, странички для тегов и категорий, косяки в вёрстке и т. п.), но я надеюсь решить их в рабочем режиме. Главное — теперь есть удобный инструмент для написания постов. За последние месяцы у меня накопилось много интересных заметок, планирую оформить их в обозримом будущем в письменном виде. Надеюсь, моя писанина окажется полезной для других разработчиков.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Статические поля в generic-классах</title>
                <link>http://aakinshin.net/ru/blog/dotnet/static-field-in-generic-type/</link> 	
                <pubDate>Wed, 21 Jan 2015 17:32:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/static-field-in-generic-type/</guid>
                <description>&lt;p&gt;Сегодня мы кратко поговорим о статических полях в generic-классах. Тема простая, но у некоторых разработчиков она вызывает трудности. Итак, задачка: что выведет следующий код?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class Foo&amp;lt;T&amp;gt;
{
  public static int Bar;
}
void Main()
{
  Foo&amp;lt;int&amp;gt;.Bar++;
  Console.WriteLine(Foo&amp;lt;double&amp;gt;.Bar);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;em&gt;Правильный ответ:&lt;/em&gt; &lt;code&gt;0&lt;/code&gt;. Всё дело в том, что &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; и &lt;code&gt;Foo&amp;lt;double&amp;gt;&lt;/code&gt; — это два разных класса, у каждого своё собственное статическое поле. И это весьма логично. Действительно, раз у нас есть поле, то оно должно принадлежать экземпляру какого-то класса, а экземпляр &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; создать невозможно, необходимо явно указать &lt;code&gt;T&lt;/code&gt;. Как можно догадаться, &lt;code&gt;typeof(Foo&amp;lt;int&amp;gt;) != typeof(Foo&amp;lt;double&amp;gt;)&lt;/code&gt;, поэтому каждый класс получит собственное статическое поле. Если поменять значение этого поля в одном классе, то это никак не повлияет на значение соответствующего поля в другом классе. Вроде бы просто, но не всем очевидно: мне доводилось видеть, как данный нюанс вызывал проблемы в продакшн-проектах. Поэтому я и решил написать небольшую заметку по этому поводу.&lt;/p&gt;
&lt;p&gt;Приведу также цитату из документации языка C#. &lt;strong&gt;CSharp Language Specification 5.0, 10.5.1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When a field declaration includes a  static modifier, the fields introduced by the declaration are static fields. When no  static modifier is present, the fields introduced by the declaration are instance fields. Static fields and instance fields are two of the several kinds of variables (&#167;5) supported by C#, and at times they are referred to as static variables and instance variables, respectively. A static field is not part of a specific instance; instead, it is shared amongst all instances of a closed type (&#167;4.4.2). No matter how many instances of a closed class type are created, there is only ever one copy of a static field for the associated application domain.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;У MS в разделе &lt;strong&gt;Code Analysis for Managed Code Warnings&lt;/strong&gt; есть такое предупреждение: &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms182139.aspx&quot;&gt;CA1000&lt;/a&gt;: Do not declare static members on generic types (DoNotDeclareStaticMembersOnGenericTypes). Ну и, само собой, в ReSharper также есть подобный warning под названием StaticMemberInGenericType (см. &lt;a href=&quot;https://confluence.jetbrains.com/display/ReSharper/Static+field+in+generic+type&quot;&gt;ReSharper wiki&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Мораль:&lt;/strong&gt; старайтесь не делать изменяемые статические поля в generic-классах. А ещё лучше — просто старайтесь не делать изменяемые статические поля. Как правило, в нормальном проекте такую потребность всегда можно обойти с помощью красивого архитектурного решения. Даже если вы считаете, что изменяемое статическое поле вам просто необходимо, и при этом прекрасно понимаете нюансы, связанные с его использованием в generic-классах (используете эту фичу в своих целях), то помните, что кто-нибудь, кто будет работать с вашим кодом, может не понять авторскую задумку и чего-нибудь испортить или использовать не по плану. А архитектуру нужно стараться делать так, чтобы что-то испортить было чертовски сложно.&lt;/p&gt;
&lt;h3&gt;Задачи&lt;/h3&gt;
&lt;p&gt;Приведённая задачка доступна в &lt;a href=&quot;http://problembook.net/&quot;&gt;ProblemBookt.NET&lt;/a&gt; &lt;a href=&quot;http://problembook.net/content/ru/Oop/StaticFieldInGenericType-P.html&quot;&gt;на русском&lt;/a&gt; и &lt;a href=&quot;http://problembook.net/content/en/Oop/StaticFieldInGenericType-P.html&quot;&gt;на английском&lt;/a&gt;.&lt;/p&gt;</description>
            </item>
            <item>
                <title>List.ForEach в .NET 4.5</title>
                <link>http://aakinshin.net/ru/blog/dotnet/listforeach-net-45/</link> 	
                <pubDate>Mon, 24 Nov 2014 18:24:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/listforeach-net-45/</guid>
                <description>&lt;p&gt;Продолжим обсуждать &lt;a href=&quot;http://aakinshin.blogspot.ru/2014/11/dotnet-list-version-side-effect.html&quot;&gt;тему&lt;/a&gt; изменения коллекции внутри цикла &lt;code&gt;foreach&lt;/code&gt;. Следующий код&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var list = new List&amp;lt;int&amp;gt; { 1, 2 };
foreach (var i in list)
{
    if (i == 1)
        list.Add(3);
    Console.WriteLine(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;выбросит &lt;code&gt;InvalidOperationException&lt;/code&gt;. А как думаете, что случится при выполнении цикла через &lt;a href=&quot;http://msdn.microsoft.com/library/bwabdf9z.aspx&quot;&gt;List&amp;lt;T&amp;gt;.ForEach&lt;/a&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var list = new List&amp;lt;int&amp;gt; { 1, 2 };
list.ForEach(i =&amp;gt;
{
    if (i == 1)
        list.Add(3);
    Console.WriteLine(i);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Правильный ответ: зависит.&lt;!--more--&gt; Ранее (.NET 4.0) данный код замечательно отрабатывал и выводил &lt;code&gt;1 2 3&lt;/code&gt;. Это было не очень хорошо. Поэтому в .NET 4.5 поведение поменялось, &lt;code&gt;ForEach&lt;/code&gt; начал бросать &lt;code&gt;InvalidOperationException&lt;/code&gt; для случая, если кто-то внутри цикла менял коллекцию:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void ForEach(Action&amp;lt;T&amp;gt; action) {
  if( action == null) { 
    ThrowHelper.ThrowArgumentNullException(ExceptionArgument.match);
  } 
  Contract.EndContractBlock();

  int version = _version;

  for(int i = 0 ; i &amp;lt; _size; i++) {
    if (version != _version &amp;amp;&amp;amp; BinaryCompatibility.TargetsAtLeast_Desktop_V4_5) { 
      break; 
    }
    action(_items[i]); 
  }

  if (version != _version &amp;amp;&amp;amp; BinaryCompatibility.TargetsAtLeast_Desktop_V4_5)
    ThrowHelper.ThrowInvalidOperationException(
        ExceptionResource.InvalidOperation_EnumFailedVersion); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&quot;text-decoration: line-through;&quot;&gt;Что касается Mono, то в нём никаких исключение не бросается (даже в последнем стабильном на текущий момент Mono 3.10).&lt;/span&gt; Когда я узнал, что в Mono 3.10 всё плохо, то очень расстроился. А потом пошёл и завёл &lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=24775&quot;&gt;баг-репорт&lt;/a&gt;. Вскоре баг был &lt;a href=&quot;https://github.com/mono/mono/commit/5517c56afa66f4d54575b01adb86fe1577128c01&quot;&gt;исправлен&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;А в старых версий (например, 2.10) был &lt;a href=&quot;http://lists.ximian.com/pipermail/mono-bugs/2011-June/112085.html&quot;&gt;баг&lt;/a&gt;, в результате которого исключение не происходило даже внутри обычного &lt;code&gt;foreach&lt;/code&gt;, если коллекцию менять через индексатор (&lt;a href=&quot;http://ideone.com/A3DbN&quot;&gt;ideone&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;

namespace test
{
    public class test
    {
        public static void Main()
        {
            List x = new List();
            x.Add(1);
            x.Add(4);
            x.Add(9);
            foreach(int i in x){
                x[2] = 3;
            }
            foreach(int i in x){
                System.Console.WriteLine(i);
            }
        }
    }
}

Actual Results (Mono 2.10):
1
4
3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.msdn.com/b/webdev/archive/2012/11/19/all-about-httpruntime-targetframework.aspx&quot;&gt;.NET Web Development and Tools Blog: All about : All about &amp;lt;httpRuntime targetFramework&amp;gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/10/17/net-framework-4-5-off-to-a-great-start.aspx&quot;&gt;.NET Framework Blog: .NET Framework 4.5 – Off to a great start&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AndreyAkinshin/ItDepends.NET/tree/master/ListForEach&quot;&gt;ItDepends.NET: ListForEach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/library/system.invalidoperationexception.aspx&quot;&gt;MSDN: InvalidOperationException&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lists.ximian.com/pipermail/mono-bugs/2011-June/112085.html&quot;&gt;Mono Bug 699182: Modifications to a Collection via indexer during foreach should throw InvalidOperationException&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=24775&quot;&gt;Mono Bug 24775: List.ForEach does not throw InvalidOperationException when collection was modified&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Сайд-эффект внутренней реализации List</title>
                <link>http://aakinshin.net/ru/blog/dotnet/list-version-side-effect/</link> 	
                <pubDate>Wed, 19 Nov 2014 17:29:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/list-version-side-effect/</guid>
                <description>&lt;p&gt;Если вы делаете &lt;code&gt;foreach&lt;/code&gt; по некоторому &lt;a href=&quot;http://msdn.microsoft.com/library/6sh2ey19.aspx&quot;&gt;List&lt;/a&gt;-у, то менять итерируемый лист внутри цикла крайне не рекомендуется, ведь это верный способ получить &lt;a href=&quot;http://msdn.microsoft.com/library/system.invalidoperationexception.aspx&quot;&gt;InvalidOperationException&lt;/a&gt;. А теперь загадка: как думаете, что случится со следующим кодом:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var list = new List&amp;lt;int&amp;gt; { 0, 1, 2 };
foreach(var x in list)
{
  if (x == 0)
  {
    for (int i = int.MinValue; i &amp;lt; int.MaxValue; i++)
      list[0] = 0;
    list.Add(3);
  }
  Console.WriteLine(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
Правильный ответ: этот код замечательно отработает. На консоли вы увидете:
&lt;pre&gt;&lt;code&gt;0
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Разгадка кроется во внутренней реализации класса List (см. реализацию в &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs&quot;&gt;MS.NET&lt;/a&gt; и в
&lt;a href=&quot;https://github.com/mono/mono/blob/mono-3.10.0/mcs/class/corlib/System.Collections.Generic/List.cs&quot;&gt;Mono 3.10&lt;/a&gt;). При итерировании наш List должен как-то следить, не поменял ли его кто-нибудь внутри очередной итерации. Для этого используется приватное поле &lt;code&gt;_version&lt;/code&gt;. При любой операции &lt;code&gt;_version&lt;/code&gt; увеличивается на 1. При создании Enumerator-для цикла это значение &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,1199&quot;&gt;запоминается&lt;/a&gt;, а при каждом вызове &lt;code&gt;MoveNext&lt;/code&gt;
происходит &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,1224&quot;&gt;проверка&lt;/a&gt;, что номер версии не поменялся. Если кто-то менял элементы коллекции, то &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,1225&quot;&gt;будет брошен&lt;/a&gt; &lt;a href=&quot;http://msdn.microsoft.com/library/system.invalidoperationexception.aspx&quot;&gt;InvalidOperationException&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но приведённый выше код отлично отрабатывает без всяких исключений. Как же так? Разгадка проста: для хранения &lt;code&gt;_version&lt;/code&gt; используется тип &lt;code&gt;int&lt;/code&gt;. А что будет, если &lt;code&gt;int&lt;/code&gt;-переменную увеличить на &lt;code&gt;1&lt;/code&gt; ровно &lt;i&gt;2 &lt;sup&gt;32&lt;/sup&gt;&lt;/i&gt; раза? Она вернётся к своему исходному значению. В примере внутренний цикл (от &lt;code&gt;int.MinValue&lt;/code&gt; до &lt;code&gt;int.MaxValue&lt;/code&gt;) изменяет бедный &lt;code&gt;_version&lt;/code&gt; ровно &lt;i&gt;2 &lt;sup&gt;32&lt;/sup&gt;-1&lt;/i&gt; раз. А строчка &lt;code&gt;list.Add(3)&lt;/code&gt; пополняет лист новым элементом и совершает финальный инкремент &lt;code&gt;_version&lt;/code&gt;, который возвращает его к исходному значению. В результате при следующем вызове &lt;code&gt;MoveNext()&lt;/code&gt; никто не подозревает, что мы что-то поменяли. Идеальное преступление.&lt;/p&gt;
&lt;p&gt;Документация нам &lt;a href=&quot;http://msdn.microsoft.com/library/system.collections.ienumerator.movenext.aspx&quot;&gt;говорит&lt;/a&gt;, что исключение должно быть брошено, если кто-то поменял коллекцию. Так что формально данный пример иллюстрирует небольшую .NET-багу. Впрочем, особо волноваться по этому поводу не стоит: вероятность наткнуться на подобную проблему реальной жизни достаточно мала. Закладываться на такое поведение и как-то его учитывать тоже не стоит, т.к. впоследствии оно может поменяться (например, &lt;code&gt;_version&lt;/code&gt; сделают 64-битным).&lt;/p&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/26718990/184842&quot;&gt;StackOverflow: Why this code throws &#39;Collection was modified&#39; and when I iterate something before it, it doesn&#39;t?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Об экранировании URI в .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/uri-escaping/</link> 	
                <pubDate>Thu, 13 Nov 2014 15:29:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/uri-escaping/</guid>
                <description>&lt;h2&gt;Часть 1&lt;/h2&gt;
&lt;p&gt;Загадка на сегодня: что выведет код?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var uri = new Uri(&amp;quot;http://localhost/%2F1&amp;quot;);
Console.WriteLine(uri.OriginalString);
Console.WriteLine(uri.AbsoluteUri);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Правильный ответ: зависит. Давайте немножко поразбираемся.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;Так что же он выведет?&lt;/h3&gt;
&lt;p&gt;Результат работы зависит от версии .NET:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// .NET 4.0
http://localhost/%2F1
http://localhost//1
// .NET 4.5
http://localhost/%2F1
http://localhost/%2F1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Да как же так-то?&lt;/h3&gt;
&lt;p&gt;Увы, до версии .NET 4.0 имела место &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/511010/erroneous-uri-parsing-for-encoded-reserved-characters-according-to-rfc-3986&quot;&gt;неприятная бага&lt;/a&gt; с экранированием слеша (он же &lt;code&gt;%2F&lt;/code&gt;). В 4.5 её решили пофиксить, чтобы поведение соответствовало &lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;. Сделали вроде бы правильно, но добавили дополнительной головной боли разработчикам, которые не знают про этот небольшой нюанс: теперь механизм экранирования зависит от версии Framework-а. Лучше всего использовать правильный механизм из .NET 4.5. Но что, если у нас нет .NET 4.5? Имеется путь починить поведение в .NET 4.0. Для этого необходимо добавить в *.config-файл вашего приложения магические строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
  &amp;lt;uri&amp;gt;
    &amp;lt;schemeSettings&amp;gt;
      &amp;lt;add name=&amp;quot;http&amp;quot; 
           genericUriParserOptions=&amp;quot;DontUnescapePathDotsAndSlashes&amp;quot; /&amp;gt;
    &amp;lt;/schemeSettings&amp;gt;
  &amp;lt;/uri&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Работает приведённый фокус-покус начиная с .NET 4.0 beta 2. Т.е., скажем, в .NET 3.5 так сделать не получится. Так что придётся крутиться и вертеться. Например, на просторах интернета &lt;a href=&quot;http://stackoverflow.com/a/784937/184842&quot;&gt;можно найти&lt;/a&gt; вот такой чудо-хак:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;void ForceCanonicalPathAndQuery(Uri uri)
{
  string paq = uri.PathAndQuery; // need to access PathAndQuery
  FieldInfo flagsFieldInfo = typeof(Uri).GetField(&amp;quot;m_Flags&amp;quot;, 
    BindingFlags.Instance | BindingFlags.NonPublic);
  ulong flags = (ulong) flagsFieldInfo.GetValue(uri);
  flags &amp;amp;= ~((ulong) 0x30); // Flags.PathNotCanonical|Flags.QueryNotCanonical
  flagsFieldInfo.SetValue(uri, flags);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;А что будет в Mono?&lt;/h3&gt;
&lt;p&gt;В Mono &lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=16960&quot;&gt;накосячили&lt;/a&gt; точно также. Починка осуществилась совсем недавно с &lt;a href=&quot;http://www.mono-project.com/docs/about-mono/releases/3.10.0/&quot;&gt;выходом&lt;/a&gt; Mono 3.10.0 в октябре 2014. Так что если вы сидите на последней версии, то у вас уже всё должно быть хорошо. Но как же нам теперь переключаться между старым и новым поведением? Для этих целей в классе &lt;code&gt;System.Uri&lt;/code&gt; имеется свойство &lt;code&gt;IriParsing&lt;/code&gt;. Заглянем в &lt;a href=&quot;https://github.com/mono/mono/blob/mono-3.10.0/mcs/class/System/System/Uri.cs&quot;&gt;код&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private static bool s_IriParsing;

internal static bool IriParsing {
    get { return s_IriParsing; }
    set { s_IriParsing = value; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выставляется свойство следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;static Uri ()
{
#if NET_4_5
    IriParsing = true;
#endif

    var iriparsingVar = 
        Environment.GetEnvironmentVariable (&amp;quot;MONO_URI_IRIPARSING&amp;quot;);
    if (iriparsingVar == &amp;quot;true&amp;quot;)
        IriParsing = true;
    else if (iriparsingVar == &amp;quot;false&amp;quot;)
        IriParsing = false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Т.е. выставить его проще всего через переменную окружения &lt;code&gt;MONO_URI_IRIPARSING&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Заключение&lt;/h3&gt;
&lt;p&gt;Бага не особо приятная и может стоить вам многих часов душевного спокойствия, если вы на неё случайно наткнётесь. Поэтому я решил оформить такую вот небольшую заметку, чтобы побольше людей было в курсе. Помните о неоднозначности экранирования некоторых URI и пишите стабильный код.&lt;/p&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/511010/erroneous-uri-parsing-for-encoded-reserved-characters-according-to-rfc-3986&quot;&gt;MS Connect 511010: Erroneous URI parsing for encoded, reserved characters, according to RFC 3986&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=16960&quot;&gt;Mono Bug 16960&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/20769150/184842&quot;&gt;StackOverflow: Getting a Uri with escaped slashes on mono&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/781205/184842%22%3EStackOverflow&quot;&gt;GETting a URL with an url-encoded slash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mono-project.com/docs/about-mono/releases/3.10.0/&quot;&gt;Mono 3.10.0 release notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mikehadlow.blogspot.co.uk/2011/08/how-to-stop-systemuri-un-escaping.html&quot;&gt;Mike Hadlow: How to stop System.Uri un-escaping forward slash characters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://grootveld.com/archives/21/url-encoded-slashes-in-systemuri&quot;&gt;Arnout&#39;s Eclectica: URL-encoded slashes in System.Uri&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Часть 2&lt;/h2&gt;
&lt;p&gt;На StackOverflow мне попался интересный вопрос: &lt;a href=&quot;http://stackoverflow.com/q/27062562/184842&quot;&gt;&#171;Unit test ReSharper and NUnit give different results&#187;&lt;/a&gt;. Суть заключалась в том, что ReSharper и NUnit дают разные результаты при экранировании URI. Я решил немножко углубиться в эту проблему. Разобраться с проблемой нам поможет следующая небольшая программка:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
    Print(&amp;quot;http://localhost/a%2Fb&amp;quot;);
    Print(&amp;quot;http://localhost/a.?b&amp;quot;);
    Print(&amp;quot;http://localhost/a?b=c%3Fd%3De&amp;quot;);
}

public void Print(string uriString)
{
    var uri = new Uri(uriString);
    Console.WriteLine(&amp;quot;Original: &amp;quot; + uri.OriginalString);
    Console.WriteLine(&amp;quot;Absolute: &amp;quot; + uri.AbsoluteUri);
    Console.WriteLine(&amp;quot;ToString: &amp;quot; + uri.ToString());
    Console.WriteLine();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Я взял на рассмотрение три строки: с экранированным слешом, с точкой и с экранированными вопросом и знаком равенства. Программа запускалась под MS.NET 4.0, MS.NET 4.0 с опцией &lt;code&gt;genericUriParserOptions=&amp;quot;DontUnescapePathDotsAndSlashes&amp;quot;&lt;/code&gt;, MS.NET 4.5, Mono 3.2.8, Mono 3.10.0. Результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// MS.NET 4.0:

Original: http://localhost/a%2Fb
Absolute: http://localhost/a/b
ToString: http://localhost/a/b

Original: http://localhost/a.?b
Absolute: http://localhost/a?b
ToString: http://localhost/a?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c?d=e

// MS.NET 4.0 (DontUnescapePathDotsAndSlashes):

Original: http://localhost/a%2Fb
Absolute: http://localhost/a%2Fb
ToString: http://localhost/a/b

Original: http://localhost/a.?b
Absolute: http://localhost/a?b
ToString: http://localhost/a?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c?d=e

// MS.NET 4.5:

Original: http://localhost/a%2Fb
Absolute: http://localhost/a%2Fb
ToString: http://localhost/a%2Fb

Original: http://localhost/a.?b
Absolute: http://localhost/a.?b
ToString: http://localhost/a.?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c%3Fd%3De

// Mono 3.2.8

Original: http://localhost/a%2Fb
Absolute: http://localhost/a/b
ToString: http://localhost/a/b

Original: http://localhost/a.?b
Absolute: http://localhost/a.?b
ToString: http://localhost/a.?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c%3Fd=e

// Mono 3.10

Original: http://localhost/a%2Fb
Absolute: http://localhost/a%2Fb
ToString: http://localhost/a%2Fb

Original: http://localhost/a.?b
Absolute: http://localhost/a.?b
ToString: http://localhost/a.?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c%3Fd%3De
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Внимательное созерцание результатов может подтолкнуть к следующим выводам:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;uri.AbsoluteUri&lt;/code&gt; совсем не обязательно совпадает с &lt;code&gt;uri.ToString()&lt;/code&gt;. Например, &lt;code&gt;DontUnescapePathDotsAndSlashes&lt;/code&gt; хак в MS.NET 4.0 при экранировании слеша влияет на &lt;code&gt;AbsoluteUri&lt;/code&gt;, но не оказывает влияния на &lt;code&gt;ToString()&lt;/code&gt;. Под Mono 3.2.8 можно увидеть проблемы с экранированным знаком равенства в &lt;code&gt;AbsoluteUri&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;В Mono и MS.NET были разные проблемы с обработкой URI. Например, под MS.NET 4.0 строка &lt;code&gt;a.?b&lt;/code&gt; превратилась в &lt;code&gt;a?b&lt;/code&gt;, а под Mono 3.2.8 мы увидели всё тот же &lt;code&gt;a.?b&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;В последних версиях (MS.NET 4.5 и Mono 3.10) всё хорошо: &lt;code&gt;AbsoluteUri&lt;/code&gt; и &lt;code&gt;ToString()&lt;/code&gt; на &lt;em&gt;приведённых примерах&lt;/em&gt; совпадают с &lt;code&gt;OriginalString&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Что касается изначального StackOverflow-вопроса, то ReSharper проводит тестирование правильно: он запускает тесты под нужную версию .NET. А NUnit при консольном тестировании без указания специфических параметров по каким-то причинам может подхватить логику из старых библиотек.&lt;/p&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Если вы работаете с URI, в который могут попасть разные спецсимволы в экранированном или явном виде, то лучше бы вам не полагаться на стандартную реализацию по обработке исходной строчки: результат работы &lt;code&gt;AbsoluteUri&lt;/code&gt; и &lt;code&gt;ToString()&lt;/code&gt; могут вас неприятно удивить. Если вы уверены, что у вас повсеместно используется MS.NET 4.5+ или Mono 3.10+, то скорее всего у вас всё будет нормально, но при поддержке старых версий .NET лучше бы написать свою логику по работе с URI.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Nullable-арифметика</title>
                <link>http://aakinshin.net/ru/blog/dotnet/cheatsheet-nullable/</link> 	
                <pubDate>Tue, 11 Nov 2014 18:01:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/cheatsheet-nullable/</guid>
                <description>&lt;p&gt;Что будет, если &lt;code&gt;null&lt;/code&gt; поделить на ноль? А сколько будет &lt;code&gt;null | true&lt;/code&gt;? А &lt;code&gt;null &amp;amp; true&lt;/code&gt;? А &lt;code&gt;((string)null + null)&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Практика подсказывает, что C#-разработчики зачастую не особо задумываются о том, как будут оцениваться выражения, если один из операндов равен &lt;code&gt;null&lt;/code&gt;. Поэтому я решил составить небольшую шпаргалку на эту тему.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;Числа&lt;/h3&gt;
&lt;p&gt;Обычные арифметические операции с числами, в которых один из операндов равен &lt;code&gt;null&lt;/code&gt;, всегда будут возвращать &lt;code&gt;null&lt;/code&gt;. Т.е. если у нас имеется некоторый &lt;code&gt;X&lt;/code&gt; типа &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; или &lt;code&gt;decimal&lt;/code&gt;, то для любых значений &lt;code&gt;X&lt;/code&gt; работает нижеприведённая табличка. Даже если &lt;code&gt;X==0&lt;/code&gt;, то выражения &lt;code&gt;null / X&lt;/code&gt; и &lt;code&gt;null % X&lt;/code&gt; всё равно вернут &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+------------+-------+
| Expression | Value |
+------------+-------+
| X + null   | null  |
| X - null   | null  |
| X * null   | null  |
| X / null   | null  |
| X % null   | null  |
| null + X   | null  |
| null - X   | null  |
| null * X   | null  |
| null / X   | null  |
| null % X   | null  |
+------------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Сравнения&lt;/h3&gt;
&lt;p&gt;Операции &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; всегда возвращают &lt;code&gt;false&lt;/code&gt;, если один из операндов равен &lt;code&gt;null&lt;/code&gt;. Операции &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; работают так, как подсказывает логика.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------+-------+-------+-------+-------+-------+-------+
|   X   |   Y   |  X&amp;lt;Y  | X&amp;lt;=Y  |  X&amp;gt;Y  | X&amp;gt;=Y  | X==Y  | X!=Y  |
+-------+-------+-------+-------+-------+-------+-------+-------+
| 0     | 0     | false | true  | false | true  | true  | false |
| 0     | null  | false | false | false | false | false | true  |
| null  | 0     | false | false | false | false | false | true  |
| null  | null  | false | false | false | false | true  | false |
+-------+-------+-------+-------+-------+-------+-------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Логические операции&lt;/h3&gt;
&lt;p&gt;Логические операции &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; вызывают большее количество непонимания у людей. Проиллюстрируем булеву арифметику ещё одной табличной:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------+-------+-------+-------+
|   X   |   Y   | X | Y | X &amp;amp; Y | X ^ Y |
+-------+-------+-------+-------+-------+
| false | false | false | false | false |
| false | true  | true  | false | true  |
| false | null  | null  | false | null  |
| true  | false | true  | false | true  |
| true  | true  | true  | true  | false |
| true  | null  | true  | null  | null  |
| null  | false | null  | false | null  |
| null  | true  | true  | null  | null  |
| null  | null  | null  | null  | null  |
+-------+-------+-------+-------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Строки&lt;/h3&gt;
&lt;p&gt;В операциях конкатенации строк &lt;code&gt;null&lt;/code&gt; всегда заменяется на пустую строчку. Таким образом,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;&amp;quot;foo&amp;quot; + null == &amp;quot;foo&amp;quot;
(string)null + null + null == &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.microsoft.com/downloads/en/details.aspx?FamilyID=DFBF523C-F98C-4804-AFBD-459E846B268E&quot;&gt;C# Language Specification&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;4.1.10 Nullable types&lt;/li&gt;
&lt;li&gt;6.1.4 Implicit nullable conversions&lt;/li&gt;
&lt;li&gt;6.2.3 Explicit nullable conversions&lt;/li&gt;
&lt;li&gt;7.3.7 Lifted operators&lt;/li&gt;
&lt;li&gt;7.8.4 Addition operator&lt;/li&gt;
&lt;li&gt;7.10.9 Equality operators and null&lt;/li&gt;
&lt;li&gt;7.11.4 Nullable boolean logical operators&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/library/2cf62fcy.aspx&quot;&gt;MSDN: Using Nullable Types (C# Programming Guide)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Об UTF-8-преобразованиях в Mono</title>
                <link>http://aakinshin.net/ru/blog/dotnet/mono-utf8-conversions/</link> 	
                <pubDate>Mon, 10 Nov 2014 02:03:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/mono-utf8-conversions/</guid>
                <description>&lt;p&gt;Данный пост является логическим продолжением поста Джона Скита &lt;a href=&quot;http://codeblog.jonskeet.uk/2014/11/07/when-is-a-string-not-a-string&quot;&gt;“When is a string not a string?”&lt;/a&gt;. Jon showed very interesting things about behavior of ill-formed Unicode strings in .NET. I wondered about how similar examples will work on Mono. And I have got very interesting results.&lt;/p&gt;
&lt;h3&gt;Experiment 1: Compilation&lt;/h3&gt;
&lt;p&gt;Let&#39;s take the Jon&#39;s code with a small modification. We will just add &lt;code&gt;text&lt;/code&gt; null check in &lt;code&gt;DumpString&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.ComponentModel;
using System.Text;
using System.Linq;
 
[Description(Value)]
class Test
{
    const string Value = &amp;quot;X\ud800Y&amp;quot;;
 
    static void Main()
    {
        var description = (DescriptionAttribute)typeof(Test).
            GetCustomAttributes(typeof(DescriptionAttribute), true)[0];
        DumpString(&amp;quot;Attribute&amp;quot;, description.Description);
        DumpString(&amp;quot;Constant&amp;quot;, Value);
    }
 
    static void DumpString(string name, string text)
    {
        Console.Write(&amp;quot;{0}: &amp;quot;, name);
        if (text != null)
        {
            var utf16 = text.Select(c =&amp;gt; ((uint) c).ToString(&amp;quot;x4&amp;quot;));
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, utf16));
        }
        else
            Console.WriteLine(&amp;quot;null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Let&#39;s compile the code with MS.NET (csc) and Mono (mcs). The resulting IL files will have one important distinction:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler
.custom instance void class
[System]System.ComponentModel.DescriptionAttribute::&#39;.ctor&#39;(string) =
(01 00 05 58 ED A0 80 59 00 00 ) // ...X...Y..
// Mono compiler
.custom instance void class
[System]System.ComponentModel.DescriptionAttribute::&#39;.ctor&#39;(string) =
(01 00 05 58 59 BF BD 00 00 00 ) // ...XY.....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 1:&lt;/strong&gt; MS.NET and Mono transform original C# strings to UTF-8 IL strings in different ways. But both ways give non-valid UTF-8 strings (&lt;code&gt;58 ED A0 80 59&lt;/code&gt; and &lt;code&gt;58 59 BF BD 00&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;Experiment 2: Run&lt;/h3&gt;
&lt;p&gt;Ok, let&#39;s run it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler / MS.NET runtime
Attribute: 0058 fffd fffd 0059
Constant: 0058 d800 0059
// MS.NET compiler / Mono runtime
Attribute: null
Constant: 0058 d800 0059
// Mono compiler / MS.NET runtime
Attribute: 0058 0059 fffd fffd 0000
Constant: 0058 d800 0059
// Mono compiler / Mono runtime
Attribute: null
Constant: 0058 d800 0059
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 2:&lt;/strong&gt; Mono runtime can&#39;t use our non-valid UTF-8 IL strings. Instead, Mono use &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Experiment 3: Manual UTF-8 to String conversion&lt;/h3&gt;
&lt;p&gt;Ok, but what if we create non-valid UTF-8 string in runtime? Let&#39;s check it! The code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Text;
using System.Linq;

class Test
{
    static void Main()
    {
        DumpString(&amp;quot;(1)&amp;quot;, Encoding.UTF8.GetString(
            new byte[] { 0x58, 0xED, 0xA0, 0x80, 0x59 }));
        DumpString(&amp;quot;(2)&amp;quot;, Encoding.UTF8.GetString(
            new byte[] { 0x58, 0x59, 0xBF, 0xBD, 0x00 }));
    }

    static void DumpString(string name, string text)
    {
        Console.Write(&amp;quot;{0}: &amp;quot;, name);
        if (text != null)
        {
            var utf16 = text.Select(c =&amp;gt; ((uint)c).ToString(&amp;quot;x4&amp;quot;));
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, utf16));
        }
        else
            Console.WriteLine(&amp;quot;null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET runtime
(1): 0058 fffd fffd 0059
(2): 0058 0059 fffd fffd 0000
// Mono runtime
(1): 0058 fffd fffd fffd 0059
(2): 0058 0059 fffd fffd 0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MS.NET and Mono implement UTF-8 to String conversion in different ways. The &lt;code&gt;ED A0 80&lt;/code&gt; sequence transforms to &lt;code&gt;FFDD FFDD&lt;/code&gt; on MS.NET and to &lt;code&gt;FFDD FFDD FFDD&lt;/code&gt; on Mono.&lt;/p&gt;
&lt;h3&gt;Experiment 4: Manual String to UTF-8 conversion&lt;/h3&gt;
&lt;p&gt;Let&#39;s look to the reverse conversion (from String to UTF-8). The code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var bytes = Encoding.UTF8.GetBytes(&amp;quot;X\ud800Y&amp;quot;);
Console.WriteLine(string.Join(&amp;quot; &amp;quot;, bytes.Select(b =&amp;gt; b.ToString(&amp;quot;x2&amp;quot;))));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET runtime
58 ef bf bd 59
// Mono runtime
58 59 bf bd 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 4:&lt;/strong&gt; MS.NET and Mono implement String to UTF-8 conversion in different ways too.&lt;/p&gt;
&lt;h3&gt;Experiment 5: Prohibition of ill-formed string&lt;/h3&gt;
&lt;p&gt;Also, Jon&#39;s has written about prohibition of ill-formed strings in some attributes. For example, the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[DllImport(Value)]
static extern void Foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will not compile on csc or Roslyn. But it will be successfully compile on Mono!&lt;/p&gt;
&lt;p&gt;Another example: the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Conditional(Value)]
void Bar() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will not compile on csc and Mono:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler
error CS0647:
Error emitting ‘DllImportAttribute’ attribute
// Mono compiler
error CS0633:
The argument to the ‘ConditionalAttribute’ attribute must be a valid identifier
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Encodings are hard.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Endianness в .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/endianness/</link> 	
                <pubDate>Wed, 29 Oct 2014 17:06:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/endianness/</guid>
                <description>&lt;table class=&quot;table-ok&quot;&gt;
    &lt;tr&gt;
        &lt;td valign=&quot;top&quot;&gt;
            &lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
                &lt;img src=&quot;/img/posts/dotnet/endianness/front.png&quot; alt=&quot;Endian funny image&quot;/&gt;
            &lt;/div&gt;
        &lt;/td&gt;
        &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;Рассмотрим простую задачку: что выведет следующий код?&lt;/p&gt;
&lt;pre class=&quot;prettyprint lang-cs&quot;&gt;
[StructLayout(LayoutKind.Explicit)]
struct UInt16Wrapper
{
  [FieldOffset(0)]
  public UInt16 Value;
  [FieldOffset(0)]
  public Byte Byte1;
  [FieldOffset(1)]
  public Byte Byte2;
}
void Main()
{
  var uint16 = new UInt16Wrapper();
  uint16.Value = 1 + 2 * 256;
  Console.WriteLine(uint16.Byte1);
  Console.WriteLine(uint16.Byte2);
}
&lt;/pre&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Полагаю, что внимательный читатель должен обратить внимание на название поста и дать правильный ответ: &#171;зависит&#187;. Сегодня мы немного поговорим о том, как в .NET обстоят дела с порядком байтов.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;Небольшой обзор&lt;/h3&gt;
&lt;p&gt;Про то, что такое endianness и зачем он нужен, я писать не буду — на эту тему и так хватает материала (&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;Endianness&lt;/a&gt;), &lt;a href=&quot;http://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures#Endianness&quot;&gt;Comparison of instruction set architectures&lt;/a&gt;, &lt;a href=&quot;http://habrahabr.ru/post/233245/&quot;&gt;Разбираемся с прямым и обратным порядком байтов&lt;/a&gt;). Ответ на задачку можно легко найти в &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt;, &#171;I.12.6.3  Byte ordering&#187;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For data types larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms. The PE file format (see &#167;I.12.2) allows the file to be marked to indicate that it depends on a particular type ordering.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ну, казалось бы, всё просто: зависит от конкретной архитектуры. Только вот архитектур у нас много. Например, Mono &lt;a href=&quot;http://www.mono-project.com/docs/about-mono/supported-platforms/&quot;&gt;поддерживает&lt;/a&gt; в числе прочего &lt;a href=&quot;http://en.wikipedia.org/wiki/X86&quot;&gt;x86&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/X86-64&quot;&gt;x64&lt;/a&gt; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness#Little-endian&quot;&gt;Little-endian&lt;/a&gt;); &lt;a href=&quot;http://en.wikipedia.org/wiki/IBM_ESA/390&quot;&gt;s390&lt;/a&gt; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness#Big-endian&quot;&gt;Big-endian&lt;/a&gt;); &lt;a href=&quot;http://en.wikipedia.org/wiki/PowerPC&quot;&gt;PowerPC&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/SPARC&quot;&gt;SPARC&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Itanium&quot;&gt;IA64&lt;/a&gt; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness#Bi-endian_hardware&quot;&gt;Bi-endian&lt;/a&gt;, т.е. есть возможность переключаться между Little/Big-endian). Общая мораль такова: лучше не закладываться на какой-то конкретный порядок байт. Конечно, скорее всего вы пишете под x86 или x64 и можете представлять себе всю память как Little-endian, но нужно держать в уме, что это может быть и не так (особенно актуально в свете распространённости ARM для мобильных устройств).&lt;/p&gt;
&lt;h3&gt;Погружаемся внутрь&lt;/h3&gt;
&lt;p&gt;Данный раздел предназначен для тех, кто любит залезать внутрь своих программ. Если вы не из таких, то можете просто перейти к следующему разделу. А с теми, кому всё-таки интересно, вернёмся к рассмотрению нашего примера и взглянем на IL-код метода Main:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.class nested private explicit ansi sealed beforefieldinit UInt16Wrapper
  extends [mscorlib]System.ValueType
{
  // Fields
  .field [0] public uint16 Value
  .field [0] public uint8 Byte1
  .field [1] public uint8 Byte2
} // end of class UInt16Wrapper

.method private hidebysig 
  instance void Run () cil managed 
{
  // Method begins at RVA 0x205c
  // Code size 45 (0x2d)
  .maxstack 2
  .locals init (
    [0] valuetype Program/UInt16Wrapper uint16
  )

  IL_0000: ldloca.s uint16
  IL_0002: initobj Program/UInt16Wrapper
  IL_0008: ldloca.s uint16
  IL_000a: ldc.i4 513
  IL_000f: stfld uint16 Program/UInt16Wrapper::Value
  IL_0014: ldloca.s uint16
  IL_0016: ldfld uint8 Program/UInt16Wrapper::Byte1
  IL_001b: call void [mscorlib]System.Console::WriteLine(int32)
  IL_0020: ldloca.s uint16
  IL_0022: ldfld uint8 Program/UInt16Wrapper::Byte2
  IL_0027: call void [mscorlib]System.Console::WriteLine(int32)
  IL_002c: ret
} // end of method Program::Run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут всё достаточно просто: в нашей структуре имеется три поля: одно двухбайтовое (&lt;code&gt;uint16&lt;/code&gt;) и два однобайтовых (&lt;code&gt;uint8&lt;/code&gt;). Двухбайтовое поле &lt;code&gt;Value&lt;/code&gt; имеет смещение 0 байт. Первое однобайтовое поле &lt;code&gt;Byte1&lt;/code&gt; также имеет смещение 0 байт, т.е. указывает в точности туда же, куда и &lt;code&gt;Value&lt;/code&gt; (другими словами, на байт &lt;code&gt;Value&lt;/code&gt; с младшим адресом). Второе однобайтовое поле &lt;code&gt;Byte2&lt;/code&gt; имеет смещение 1 байт, т.е. указывает на байт &lt;code&gt;Value&lt;/code&gt; со старшим адресом. В примере значение &lt;code&gt;Value&lt;/code&gt; равно &lt;code&gt;1+2*256&lt;/code&gt;. На моём компьютере архитектура x64, что означает Little-endian. Для простоты примера соберём программу под x86 (с точно таким же Little-endian) А значит в &lt;code&gt;Byte1&lt;/code&gt; будет хранится &lt;code&gt;1&lt;/code&gt;, а в &lt;code&gt;Byte2&lt;/code&gt; — &lt;code&gt;2&lt;/code&gt;. На консоли мы увидим:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ради интереса взглянем на asm-код. Под Windows получим следующее:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        {
            var uint16 = new UInt16Wrapper();
00DE29A1  mov         ebp,esp  
00DE29A3  sub         esp,8  
00DE29A6  xor         eax,eax  
00DE29A8  mov         dword ptr [ebp-8],eax  
00DE29AB  mov         dword ptr [ebp-4],ecx  
00DE29AE  cmp         dword ptr ds:[4B51058h],0  
00DE29B5  je          00DE29BC  
00DE29B7  call        73DFC310  
00DE29BC  lea         eax,[ebp-8]  
00DE29BF  mov         word ptr [eax],0  
            uint16.Value = 1 + 2 * 256;
00DE29C4  mov         word ptr [ebp-8],201h  
            Console.WriteLine(uint16.Byte1);
00DE29CA  movzx       ecx,byte ptr [ebp-8]  
00DE29CE  call        7325A920  
            Console.WriteLine(uint16.Byte2);
00DE29D3  lea         eax,[ebp-8]  
00DE29D6  movzx       ecx,byte ptr [eax+1]  
00DE29DA  call        7325A920  
        }
00DE29DF  nop  
00DE29E0  mov         esp,ebp  
00DE29E2  pop         ebp  
00DE29E3  ret  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Значение нашего поля в шестнадцатеричном представлении имеет вид &lt;code&gt;201h&lt;/code&gt;, а найти его мы можем по адресу &lt;code&gt;byte ptr [ebp-8]&lt;/code&gt;. В первом случае (&lt;code&gt;00DE29CA&lt;/code&gt;) мы просто загружаем значение по данному адресу в &lt;code&gt;ecx&lt;/code&gt;, а во втором (&lt;code&gt;00DE29D3&lt;/code&gt;) — сначала загружаем адрес в &lt;code&gt;eax&lt;/code&gt;, а затем получаем значение из &lt;code&gt;byte ptr [eax+1]&lt;/code&gt;. Для полноты эксперимента глянем также код под Linux. Я взял Ubuntu 14.04 и собрал следующую версию mono:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mono --version
Mono JIT compiler version 3.10.0
        TLS:           __thread
        SIGSEGV:       altstack
        Notifications: epoll
        Architecture:  amd64
        Disabled:      none
        Misc:          softdebug 
        LLVM:          supported, not enabled.
        GC:            sgen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Имеем код (x64-версия):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gram_Main:
//{
   0:   48 83 ec 08             sub    $0x8,%rsp
// var int16 = new Int16Wrapper();
   4:   66 c7 04 24 00 00       movw   $0x0,(%rsp)
   a:   66 c7 04 24 00 00       movw   $0x0,(%rsp)
// int16.Value = 1 + 2 * 256;
  10:   66 c7 04 24 01 02       movw   $0x201,(%rsp)
// Console.WriteLine(uint16.Byte1);
  16:   0f b6 3c 24             movzbl (%rsp),%edi
  1a:   49 bb 7e dc 0f 40 00    movabs $0x400fdc7e,%r11
  21:   00 00 00 
  24:   41 ff d3                callq  *%r11
// Console.WriteLine(uint16.Byte2);
  27:   0f b6 7c 24 01          movzbl 0x1(%rsp),%edi
  2c:   49 bb 7e dc 0f 40 00    movabs $0x400fdc7e,%r11
  33:   00 00 00 
  36:   41 ff d3                callq  *%r11
// }
  39:   48 83 c4 08             add    $0x8,%rsp
  3d:   c3                      retq 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Логика аналогична: по адресу &lt;code&gt;(%rsp)&lt;/code&gt; загружаем целевое значение &lt;code&gt;$0x201&lt;/code&gt;. Получаем &lt;code&gt;Byte1&lt;/code&gt; по адресу &lt;code&gt;(%rsp)&lt;/code&gt; и &lt;code&gt;Byte2&lt;/code&gt; по адресу &lt;code&gt;0x1(%rsp)&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;А как узнать порядок байт?&lt;/h3&gt;
&lt;p&gt;Если для вас критично то, в каком порядке байты идут в памяти, то неплохо было бы научиться узнавать: с какой архитектурой процессора мы имеем дело. Рассмотрим пару способов.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Простой способ.&lt;/strong&gt; Благо, разработчики .NET позаботились о программистах и сделали специальное поле &lt;a href=&quot;http://msdn.microsoft.com/library/system.bitconverter.islittleendian.aspx&quot;&gt;BitConverter.IsLittleEndian&lt;/a&gt;. Пользоваться им очень просто:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(BitConverter.IsLittleEndian ? &amp;quot;LittleEndian&amp;quot; : &amp;quot;BigEndian&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Класс &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.bitconverter.aspx&quot;&gt;BitConverter&lt;/a&gt; удобно использовать для работы с отдельными байтами &#171;большой&#187; переменной. И этот способ намного предпочтительней, чем ручная работа с байтами. Вот хороший фрагмент из примера в официальной документации:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int value = 12345678;
byte[] bytes = BitConverter.GetBytes(value);
Console.WriteLine(BitConverter.ToString(bytes));
if (BitConverter.IsLittleEndian)
   Array.Reverse(bytes);
Console.WriteLine(BitConverter.ToString(bytes));
// The example displays the following output on a little-endian system: 
//       4E-61-BC-00
//       00-BC-61-4E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Способ для тех, кто лёгких способов не ищет.&lt;/strong&gt; Следующий пример приведён сугубо в академических целях, в реальных проектах так писать не стоит. Допустим, мы не доверяем значению &lt;code&gt;BitConverter.IsLittleEndian&lt;/code&gt; и хотим сами проверить порядок байт, в котором хранятся наши переменные. Нам в этом поможет &lt;code&gt;unsafe&lt;/code&gt;-code. Просто создадим уже знакомое нам значение &lt;code&gt;0x201&lt;/code&gt;, получим его адрес и возьмём байт по этому адресу. Получится следующий код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public bool IsLittleEndian()
{
  UInt16 value = 0x201;
  unsafe
  {
    UInt16* valueAddress = &amp;amp;value;
    Byte* firstByteAddress = (Byte*)valueAddress;
    Byte firstByte = *firstByteAddress;
    return firstByte == 1;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;BinaryReader/BinaryWriter&lt;/h3&gt;
&lt;p&gt;Ок, с хранением чисел в памяти разобрались. А что, если нам нужно читать/писать числа в бинарном виде? .NET предлагает нам для этого классы &lt;a href=&quot;msdn.microsoft.com/library/system.io.binaryreader.aspx&quot;&gt;BinaryReader&lt;/a&gt; и &lt;a href=&quot;http://msdn.microsoft.com/library/system.io.binarywriter.aspx&quot;&gt;BinaryWriter&lt;/a&gt;. Но тут нужно быть аккуратным и помнить, что согласно документации эти классы &lt;em&gt;всегда&lt;/em&gt; работают с данными в Little-endian формате. Если по какой-то причине вы хотите поработать с данными в формате с заданным порядком байт, то придётся либо ручками реверсировать каждое число для Big-endian, либо использовать какую-нибудь внешнюю библиотеку (например, класс EndianBitConverter из &lt;a href=&quot;http://www.yoda.arachsys.com/csharp/miscutil/&quot;&gt;MiscUtil&lt;/a&gt; от Джона Скита).&lt;/p&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Всегда нужно помнить, что в разных местах для хранения чисел может использоваться разный порядок байт. А если вам доводится работать с памятью в бинарном виде, хранить числа в бинарном виде, передавать их по сети в бинарном виде или ещё-что-нибудь делать с числами в бинарном виде, то к нюансу с порядком байт следует отнестись очень внимательно.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Эти занимательные региональные настройки</title>
                <link>http://aakinshin.net/ru/blog/dotnet/cultureinfo/</link> 	
                <pubDate>Sun, 21 Sep 2014 11:39:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/cultureinfo/</guid>
                <description>&lt;p&gt;Сегодня мы поговорим о региональных настройках. Но сперва — небольшая задачка: что выведет нижеприведённый код? (Код приведён на языке C#, но рассматривается достаточно общая проблематика, так что вы можете представить на его месте какой-нибудь другой язык.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine((-42).ToString() == &amp;quot;-42&amp;quot;);
Console.WriteLine(double.NaN.ToString() == &amp;quot;NaN&amp;quot;);
Console.WriteLine(int.Parse(&amp;quot;-42&amp;quot;) == -42);
Console.WriteLine(1.1.ToString().Contains(&amp;quot;?&amp;quot;) == false);
Console.WriteLine(new DateTime(2014, 1, 1).ToString().Contains(&amp;quot;2014&amp;quot;));
Console.WriteLine(&amp;quot;i&amp;quot;.ToUpper() == &amp;quot;I&amp;quot; || &amp;quot;I&amp;quot;.ToLower() == &amp;quot;i&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Сколько значений &lt;code&gt;true&lt;/code&gt; у вас получилось? Если больше &lt;code&gt;0&lt;/code&gt;, то вам не мешает узнать больше про региональные настройки, т. к. правильный ответ: &#171;зависит&#187;. К сожалению, многие программисты вообще не задумываются о том, что настройки эти в различных окружениях могут отличаться. А выставлять для всего кода InvariantCulture этим программистом лениво, в результате чего их прекрасные приложения ведут себя очень странно, попадая к пользователям из других стран.&lt;/p&gt;
&lt;p&gt;Ошибки бывают самые разные, но чаще всего связаны они с форматированием и парсингом строк — достаточно частыми задачами для многих программистов. В статье приведена краткая подборка некоторых важных моментов, на которые влияют региональные настройки.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/cultureinfo/dotnet-cultureinfoexplorer.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Совсем немного теории: в .NET все сведения об определённом языке и региональных параметрах можно найти с помощью класса &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx&quot;&gt;CultureInfo&lt;/a&gt;. Если вы ранее не сталкивались с культурами, то для первичного ознакомления хорошо подойдёт &lt;a href=&quot;http://habrahabr.ru/post/166053/&quot;&gt;этот пост&lt;/a&gt;. Искушённый программист, увлечённый изучением различных существующих региональных настроек, может утомиться от ручного просмотра всех &lt;code&gt;CultureInfo&lt;/code&gt;. Лично я в какой-то момент утомился. Поэтому появилось небольшое WPF-приложение под названием CultureInfoExplorer (&lt;a href=&quot;https://github.com/AndreyAkinshin/CultureInfoExplorer&quot;&gt;ссылка на GitHub&lt;/a&gt;, &lt;a href=&quot;https://github.com/AndreyAkinshin/CultureInfoExplorer/releases/tag/v1.0.0.0&quot;&gt;бинарники&lt;/a&gt;), представленное на вышеприведённом скриншоте. Оно позволяет:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;По данной &lt;code&gt;CultureInfo&lt;/code&gt; посмотреть значение основных её свойств и то, как в ней выглядят некоторые заранее заготовленные строковые паттерны.&lt;/li&gt;
&lt;li&gt;По данному свойству посмотреть его возможные значения и список всех &lt;code&gt;CultureInfo&lt;/code&gt;, которые соответствуют каждому значению.&lt;/li&gt;
&lt;li&gt;По данному паттерну посмотреть возможные варианты того, во что он может превратиться, и для каждого варианта также посмотреть список соответствующих &lt;code&gt;CultureInfo&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Надеюсь, найдутся читатели, которым данная программка будет полезна. Можно узнать много нового о различных региональных настройках. Ну, а теперь перейдём к примерам.&lt;/p&gt;
&lt;h3&gt;Числа&lt;/h3&gt;
&lt;p&gt;За представление чисел у нас отвечает &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.aspx&quot;&gt;NumberFormatInfo&lt;/a&gt; (доступный через &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.numberformat.aspx&quot;&gt;CultureInfo.NumberFormat&lt;/a&gt;). И имеются в виду не только обычные числа, а также процентные и денежные значения. Обратите внимание на то, что значения бывают положительные и отрицательные: если вы работаете с локализацией/глобализацией, то важно обращать на это внимание. Настоятельно рекомендую хотя бы пробежаться глазами по документации и посмотреть доступные свойства.&lt;/p&gt;
&lt;p&gt;Одно из самых популярных свойств, которое вызывает проблемы у людей, называется &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.numberdecimalseparator.aspx&quot;&gt;NumberDecimalSeparator&lt;/a&gt;. Оно отвечает за то, чем будет при форматировании числа отделяться целая часть от дробной. Типичный пример ошибки: программист сливает массив дробных чисел в строчку, разделяя их запятыми. После этого он пытается распарсить строчку обратно в массив. Если &lt;code&gt;NumberDecimalSeparator&lt;/code&gt; равен точке, то всё будет хорошо. Скажем, при выставленной культуре &lt;code&gt;en-US&lt;/code&gt; у программиста всё заработало, он выпустил свой продукт. Этот продукт скачивает пользователь с культурой &lt;code&gt;ru-RU&lt;/code&gt; и начинает грустить: ведь у него &lt;code&gt;NumberDecimalSeparator&lt;/code&gt; равен запятой: массив из элементов 1.2 и 3.4 при таком слиянии превратится в строчку &lt;code&gt;&amp;quot;1,2,3,4&amp;quot;&lt;/code&gt;, а её распарсить будет проблемно. Лично мне становится ещё грустнее тогда, когда встретивший подобную проблему программист не пытается решить её нормально, указывая правильный &lt;code&gt;NumberFormatInfo&lt;/code&gt; при форматировании, а начинает колдовать с заменами точек на запятые или запятых на точки. Нужно понимать, что &lt;code&gt;NumberDecimalSeparator&lt;/code&gt;, в принципе, может быть любой. Например, в культуре &lt;code&gt;fa-IR&lt;/code&gt; (Persian) он равен слешу (&lt;code&gt;&#39;/&#39;&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Ещё в нашем распоряжении имеются аналогичные свойства для процентов и валют: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.percentdecimalseparator.aspx&quot;&gt;PercentDecimalSeparator&lt;/a&gt; и &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.currencydecimalseparator.aspx&quot;&gt;CurrencyDecimalSeparator&lt;/a&gt;. Все эти три значения вовсе не обязаны совпадать. Например, у казахов (&lt;code&gt;kk-KZ&lt;/code&gt;) &lt;code&gt;NumberDecimalSeparator&lt;/code&gt; и &lt;code&gt;PercentDecimalSeparator&lt;/code&gt; равны запятой, а &lt;code&gt;CurrencyDecimalSeparator&lt;/code&gt; равен знаку минус (точно такому же, с помощью которого обозначаются отрицательные числа).&lt;/p&gt;
&lt;p&gt;Некоторые считают, что целое число при конвертации в строку даёт значение, состоящее только из цифр. Но цифры эти могут разбиваться на группы. За размер групп отвечает свойство &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.numbergroupsizes.aspx&quot;&gt;NumberGroupSizes&lt;/a&gt;, а за их разделитель —
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.numbergroupseparator.aspx&quot;&gt;NumberGroupSeparator&lt;/a&gt; (аналогичные свойства есть у процентов и валют, но они опять-таки не обязаны совпадать). Группы могут быть разного размера: например, во многих культурах (&lt;code&gt;as-IN&lt;/code&gt;, &lt;code&gt;bn-BD&lt;/code&gt;, &lt;code&gt;gu-IN&lt;/code&gt;, &lt;code&gt;hi-IN&lt;/code&gt; и т.п.) &lt;code&gt;NumberGroupSizes&lt;/code&gt; равно {3, 2}. Скажем, число 1234567 в культуре as-IN будет выглядеть как &lt;code&gt;&amp;quot;12,34,567&amp;quot;&lt;/code&gt;. В качестве разделителя групп может выступать пробел &lt;code&gt;\u0020&lt;/code&gt; (например в &lt;code&gt;af-ZA&lt;/code&gt; и &lt;code&gt;lt-LT&lt;/code&gt;), но, увидев его, не торопитесь вбивать очередной костыль на парсинг и форматирование строк. Чаще всего вместо обычного пробела используется неразрывный пробел &lt;code&gt;\u00A0&lt;/code&gt; (наша родная &lt;code&gt;ru-RU&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Знаки для обозначения отрицательных и положительных чисел также входят в культуру: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.negativesign.aspx&quot;&gt;NegativeSign&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.positivesign.aspx&quot;&gt;PositiveSign&lt;/a&gt;. Слава богу, во всех доступных культурах они равны минусу и плюсу, но закладываться на это не стоит: окружение можно переопределить и задать свойствам любые значения. А самое интересное заключается не в знаках, а в паттернах форматирования положительных и отрицательных значений. Например, форматирование отрицательного числа определяется с помощью &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.numbernegativepattern.aspx&quot;&gt;NumberNegativePattern&lt;/a&gt;, у которого есть пять возможных значений:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 (n)
1 -n
2 - n
3 n-
4 n -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Например, в культуре &lt;code&gt;ti-ET&lt;/code&gt; (Tigrinya (Ethiopia)) значение &lt;code&gt;-5&lt;/code&gt; предстанет в виде &lt;code&gt;(5)&lt;/code&gt;. С процентами и валютами (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.percentnegativepattern.aspx&quot;&gt;PercentNegativePattern&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.percentpositivepattern.aspx&quot;&gt;PercentPositivePattern&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.currencynegativepattern.aspx&quot;&gt;CurrencyNegativePattern&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.currencypositivepattern.aspx&quot;&gt;CurrencyPositivePattern&lt;/a&gt;) дело обстоит ещё веселее. Например, для &lt;code&gt;CurrencyNegativePattern&lt;/code&gt; есть целых шестнадцать возможных значений:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0  ($n)
1  -$n
2  $-n
3  $n-
4  (n$)
5  -n$
6  n-$
7  n$-
8  -n $
9  -$ n
10 n $-
11 $ n-
12 $ -n
13 n- $
14 ($ n)
15 (n $)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Также есть специальные свойства для специальных знаков и специальных численных значений: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.percentsymbol.aspx&quot;&gt;PercentSymbol&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.permillesymbol.aspx&quot;&gt;PerMilleSymbol&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.nansymbol.aspx&quot;&gt;NaNSymbol&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.negativeinfinitysymbol.aspx&quot;&gt;NegativeInfinitySymbol&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.positiveinfinitysymbol.aspx&quot;&gt;PositiveInfinitySymbol&lt;/a&gt;. Мне доводилось видеть реальный проект, в котором брался double, форматировался в строку (разумеется, в текущей культуре пользователя), а затем в строковом виде сравнивался с &lt;code&gt;&#171;-Infinity&#187;&lt;/code&gt;. А в зависимости от этой самой текущей культуры &lt;code&gt;NegativeInfinitySymbol&lt;/code&gt; может принимать самые разные значения:&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot; style=&quot;white-space: pre-wrap&quot;&gt;&#39;- безкрайност&#39;, &#39;-- អនន្ត&#39;, &#39;(-) முடிவிலி&#39;, &#39;-∞&#39;, &#39;-Anfeidredd&#39;, &#39;-Anfin&#39;, &#39;-begalybė&#39;, &#39;-beskonačnost&#39;, &#39;&#201;igr&#237;och dhi&#250;ltach&#39;, &#39;-ifedh&#39;, &#39;-INF&#39;, &#39;-Infini&#39;, &#39;-infinit&#39;, &#39;-Infinit&#39;, &#39;-Infinito&#39;, &#39;-Infinitu&#39;, &#39;-infinity&#39;, &#39;Infinity-&#39;, &#39;-Infinity&#39;, &#39;miinusl&#245;pmatus&#39;, &#39;m&#237;nusz v&#233;gtelen&#39;, &#39;-nekonečno&#39;, &#39;-neskončnost&#39;, &#39;-nieskończoność&#39;, &#39;-njek&#243;nčne&#39;, &#39;-njesk&#243;ńcnje&#39;, &#39;-onendlech&#39;, &#39;-Sonsuz&#39;, &#39;-t&#252;keniksizlik&#39;, &#39;-unendlich&#39;, &#39;-Unendlich&#39;, &#39;-Άπειρο&#39;, &#39;-бесконачност&#39;, &#39;терс чексиздик&#39;, &#39;-უსასრულობა&#39;, &#39;אינסוף שלילי&#39;, &#39;-لا نهاية&#39;, &#39;منهای بی نهایت&#39;, &#39;مەنپىي چەكسىزلىك&#39;, &#39;-අනන්තය&#39;, &#39;ᠰᠦᠬᠡᠷᠬᠦ ᠬᠢᠵᠠᠭᠠᠷᠭᠦᠢ ᠶᠡᠬᠡ&#39;, &#39;མོ་གྲངས་ཚད་མེད་ཆུང་བ།&#39;, &#39;ߘߊ߲߬ߒߕߊ߲߫-&#39;, &#39;ꀄꊭꌐꀋꉆ&#39;, &#39;負無窮大&#39;, &#39;负无穷大&#39;&lt;/pre&gt;
&lt;p&gt;Примеры разных полезных свойств мы разобрали. А теперь давайте немножко пошалим: чуть-чуть изменим русскую культуру, чтобы её новое значение портило нам жизнь в примере из начала поста:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var myCulture = (CultureInfo)new CultureInfo(&amp;quot;ru-RU&amp;quot;).Clone();
myCulture.NumberFormat.NegativeSign = &amp;quot;!&amp;quot;;
myCulture.NumberFormat.PositiveSign = &amp;quot;-&amp;quot;;
myCulture.NumberFormat.PositiveInfinitySymbol = &amp;quot;+Inf&amp;quot;;
myCulture.NumberFormat.NaNSymbol = &amp;quot;Not a number&amp;quot;;
myCulture.NumberFormat.NumberDecimalSeparator = &amp;quot;?&amp;quot;;
Thread.CurrentThread.CurrentCulture = myCulture;
Console.WriteLine(-42); // !42
Console.WriteLine(double.NaN); // Not a number
Console.WriteLine(int.Parse(&amp;quot;-42&amp;quot;)); // 42
Console.WriteLine(1.1); // 1?1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Возможно, кто-то тут скажет мне: &#171;Да зачем такие примеры вообще рассматривать? Ни один программист такое никогда писать не будет!&#187;. А я отвечу: &#171;Ну-ну, ни один не будет, как же&#187;. Ситуация становится печальной, когда вы распространяете некоторую библиотеку, а один из её пользователей решил поразвлекаться с культурой. Может, он просто любит развлекаться, а может, пишет приложение для какой-то диковиной культуры (скажем, мёртвого или вымышленного языка). Но это не важно. А важно то, что ваша библиотека начинает вести себя странно в непривычном для неё окружении. Поэтому не стоит закладываться на то, что &lt;code&gt;NegativeSign&lt;/code&gt; и &lt;code&gt;PositiveSign&lt;/code&gt; никогда не меняются. Лучше просто явно указать нужную вам культуру и жить счастливо.&lt;/p&gt;
&lt;p&gt;А ещё, всем советую прочитать недавний пост Джона Скита &lt;a href=&quot;http://codeblog.jonskeet.uk/2014/08/08/the-bobbytables-culture/&quot;&gt;The BobbyTables culture&lt;/a&gt;. Краткая суть: Джон Скит ругается на тех, кто не экранирует параметры в SQL-запросах, даже если это числа и даты. И тогда Джон берёт пару запросов&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;SELECT * FROM Foo WHERE BarDate &amp;gt; &#39;&amp;quot; + DateTime.Today + &amp;quot;&#39;&amp;quot;
&amp;quot;SELECT * FROM Foo WHERE BarValue = &amp;quot; + (-10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и определяет чудо-культуру:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;CultureInfo bobby = (CultureInfo) CultureInfo.InvariantCulture.Clone();
bobby.DateTimeFormat.ShortDatePattern = @@&amp;quot;yyyy-MM-dd&#39;&#39; OR &#39; &#39;=&#39;&#39;&amp;quot;;
bobby.DateTimeFormat.LongTimePattern = &amp;quot;&amp;quot;;
bobby.NumberFormat.NegativeSign = &amp;quot;1 OR 1=1 OR 1=&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Легким движением руки запросы превращаются в:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM Foo WHERE BarDate &amp;gt; &#39;2014-08-08&#39; OR &#39; &#39;=&#39; &#39;
SELECT * FROM Foo WHERE BarValue = 1 OR 1=1 OR 1=10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну, думаю, дальнейшие пояснения не нужны.&lt;/p&gt;
&lt;h3&gt;Дата и время&lt;/h3&gt;
&lt;p&gt;С датами и временем всё особенно тяжело. За даты у нас отвечает класс &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.datetimeformatinfo.aspx&quot;&gt;DateTimeFormatInfo&lt;/a&gt; (свойство &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.datetimeformat.aspx&quot;&gt;CultureInfo.DateTimeFormat&lt;/a&gt;), а в нём есть &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.datetimeformatinfo.calendar.aspx&quot;&gt;Calendar&lt;/a&gt;. Причём есть основной календарь культуры (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.calendar.aspx&quot;&gt;CultureInfo&lt;/a&gt;), а есть список доступных для использования календарей (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.optionalcalendars.aspx&quot;&gt;CultureInfo.OptionalCalendar&lt;/a&gt;). В нашем распоряжении имеется большая пачка стандартных календарей:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.chineselunisolarcalendar.aspx&quot;&gt;ChineseLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.eastasianlunisolarcalendar.aspx&quot;&gt;EastAsianLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.gregoriancalendar.aspx&quot;&gt;GregorianCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.hebrewcalendar.aspx&quot;&gt;HebrewCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.hijricalendar.aspx&quot;&gt;HijriCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.japanesecalendar.aspx&quot;&gt;JapaneseCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.japaneselunisolarcalendar.aspx&quot;&gt;JapaneseLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.juliancalendar.aspx&quot;&gt;JulianCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.koreancalendar.aspx&quot;&gt;KoreanCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.koreanlunisolarcalendar.aspx&quot;&gt;KoreanLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.persiancalendar.aspx&quot;&gt;PersianCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.taiwancalendar.aspx&quot;&gt;TaiwanCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.taiwanlunisolarcalendar.aspx&quot;&gt;TaiwanLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.thaibuddhistcalendar.aspx&quot;&gt;ThaiBuddhistCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.umalquracalendar.aspx&quot;&gt;UmAlQuraCalendar&lt;/a&gt;
(у некоторых есть ряд дополнительных важных параметров). Логика у них, доложу я вам, самая разная. Не будем останавливаться подробно, ибо на эту тему подробной информации в интернете достаточно, а материала хватит на серию самостоятельных постов. Правила форматирования дат и времени ещё более весёлые, чем у чисел: куча паттернов для разных вариантов форматирования даты, нативные имена для месяцев и дней недели, обозначения для AM/PM, разделители и т.п. Скажем, 31 декабря 2014 года может быть представлено (&lt;code&gt;dateTime.ToString(&amp;quot;d&amp;quot;)&lt;/code&gt;) в следующих форматах:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;09/03/36
10/3/1436
12/31/2014
1436/3/10
2014.12.21.
2014/12/21
2014-12-21
31. 12. 2014
31.12.14
31.12.14 &#253;.
31.12.2014
31.12.2014 г.
31.12.2014.
31/12/14
31/12/2014
31/12/2557
31-12-14
31-12-2014
31-дек 14
31-жел-14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И это только дефолтные значения (без подключения опциональных календарей). Но даже тут видно разнообразие летоисчислений: у кого-то на дворе 1436 год, а у кого-то — 2557 (это отсылка к предпоследней строчке примера из начала статьи). Если вы оперируете с датами, то следует задуматься: стоит ли их показывать всегда в одинаковом формате или же подстроиться под пользователя и отобразить дату в более привычном для него виде. Ну, а про парсинг дат я вообще умолчу.&lt;/p&gt;
&lt;h3&gt;The Turkey Test&lt;/h3&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/cultureinfo/turkey-flag.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Есть классический пост от 2008 года под называнием &lt;a href=&quot;http://www.moserware.com/2008/02/does-your-code-pass-turkey-test.html&quot;&gt;Does Your Code Pass The Turkey Test?&lt;/a&gt;. Подробно пересказывать его не буду, лучше самостоятельно прочитать оригинал. Краткая суть The Turkey Test такова: поменяйте текущую культуру на tr-TR (Turkish (Turkey)) и запустите ваше приложение. Всё ли нормально работает? В этой культуре хватает веселья и с датами, и с числами, и со строками. Если вернуться к нашему первому примеру, то в рассматриваемой культуре &lt;code&gt;&amp;quot;i&amp;quot;.ToUpper()&lt;/code&gt; не равно &lt;code&gt;&amp;quot;I&amp;quot;&lt;/code&gt;, а &lt;code&gt;&amp;quot;I&amp;quot;.ToLower()&lt;/code&gt; не равно &lt;code&gt;&amp;quot;i&amp;quot;&lt;/code&gt; (если вам интересно больше узнать про заглавные и строчные буквы, то крайне рекомендую &lt;a href=&quot;http://habrahabr.ru/post/147387/&quot;&gt;этот пост&lt;/a&gt; и &lt;a href=&quot;http://stackoverflow.com/a/6163129/184842&quot;&gt;вот этот SO-ответ про UTF-8&lt;/a&gt;, это просто прекрасно). В конце поста приводится замечательный пример, в котором под регулярное выражение &lt;code&gt;\d{5}&lt;/code&gt; подходит строка состоящая из арабских цифр &lt;code&gt;&amp;quot;٤٦٠٣٨&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Вместо заключения&lt;/h3&gt;
&lt;p&gt;Наука о региональных настройках сложна. В этом посте я ни в коем случае не претендую на то, чтобы выдать полную информацию о том, на что же они могут влиять. Есть ещё очень много разных интересностей, связанных с интернализацией (думаю, только про идущий справа налево текст можно написать отдельный пост, да и не один). Мне просто хотелось показать несколько занимательных примеров того, как &lt;code&gt;CultureInfo.CurrentCulture&lt;/code&gt; может повлиять на ваше приложение. Надеюсь, в плане расширения общей эрудиции этот материал окажется кому-то полезным. Общая мораль такова: если вы не хотите думать о том, что в мире существует много разных культур, то используйте везде &lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt; (или другую подходящую вам культуру) — в подавляющем большинстве случаев вы сможете спать спокойно. А если вы об этом задумываетесь, то неплохо бы поизучать эту область более основательно. В этом может помочь вот эта хорошая книжка: &lt;a href=&quot;https://www.goodreads.com/book/show/1310940.Net_Internationalization&quot;&gt;Net Internationalization: The Developer&#39;s Guide to Building Global Windows and Web Applications&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Приветствуются любые дополнительные факты о том, как &lt;code&gt;CultureInfo&lt;/code&gt; может повлиять на работу различных функций. Думаю, у многих найдутся собственные увлекательные истории.&lt;/p&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;habrahabr.ru/post/237209/&quot;&gt;Оригинал поста на Хабре&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Happy Monday!</title>
                <link>http://aakinshin.net/ru/blog/dotnet/happy-monday/</link> 	
                <pubDate>Mon, 11 Aug 2014 13:09:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/happy-monday/</guid>
                <description>&lt;p&gt;Хотелось бы рассказать историю одного волшебного бага. Волшебство его заключалось в том, что он не давал нам отлаживать по понедельникам. Я сейчас совершенно серьёзно: каждый понедельник у нас отваливался Debug mode. Мало того, этот баг с циничным видом желал нам счастливого понедельничка. Для меня это был очень ценный урок в плане того, какие же всё-таки разнообразные бывают проблемы. Возможно, кому-то ещё эта история покажется любопытной.&lt;/p&gt;
&lt;p&gt;Итак, как же я впервые встретился с этой багой. Был замечательный вечер воскресенья, ничего не предвещало беды. В понедельник планировался очередной релиз нашей программки (ничего мажорного, но клиенты ждали обещанных мелких фич). На часах отображалось 00:00, и тут мне пришла в голову мысль, что один из пользовательских сценариев для новой фичи мы не проработали. Нужно было дописать всего несколько дополнительных строк, делов минут на 10. Я решил, что сейчас быстренько допишу нужную логику и с чистой совестью лягу спать. Запускаю студию, запускаю билд проекта, жду. И тут моё лицо становится озадаченным, т.к. я вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Странная ошибка-то какая-то.&lt;!--more--&gt; Тем более, что она не даёт сбилдить проект, не сообщая о себе никакой дополнительной информации: ни место, ни причину возникновения. Думаю: ну, мб, я в каких-то пользовательских настройках проекта что-то испортил. Говорю: &lt;code&gt;git clean -f -x -d&lt;/code&gt;, очисти мне всё, чего нет в репозитории. Запускаю билд, вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Ну, может чего-нибудь испортилось в самом последнем коммите? Откатываюсь на один коммит назад, на второй, на третий. Откатываюсь на месяц назад к супер-стабильной ревизии, с которой точно всё было хорошо. Запускаю билд, вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Ну, может чего-то в системном окружении сломалось? Перезагружаюсь, запускаю билд, вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Ну, может чего-то в системном окружении совсем-совсем сломалось? Переношу проект на чистый комп, запускаю билд, вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Часы начинают показывать 4-ый час ночи, а я ещё даже проект не сбилдил. В порядке протыкивания всего подряд меняю Configuration на Release. И о чудо — билд проходит успешно, приложение запускается. Возвращаю Debug — вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Ситуация начинает меня злить, я запускаю из консоли MSBUILD и начинаю изучать километровый лог. И в нём я нахожу чудесные строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Starting the pipe server: &amp;quot;C:\ProgramData\PostSharp\3.1.28\bin.Release\postsharp.srv.4.0-x86.exe /tp &amp;quot;postsharp-S-1-5-21-1801181006-371574121-2664876850-1002-4.0-x86-release-3.1.28-a4c26157a4624bb9&amp;quot; /config &amp;quot;C:\ProgramData\PostSharp\3.1.28\bin.Release\postsharp.srv.4.0-x86.exe.config&amp;quot;&amp;quot;.
  : info : Executing PostSharp 3.1 [3.1.28.0, 32 bit, CLR 4.5, Release]
  : message : Happy Monday! As every Monday, you&#39;re getting all the features of the PostSharp Ultimate for free.
  : message : PostSharp 3.1 [3.1.28.0, 32 bit, CLR 4.5, Release] complete -- 0 errors, 0 warnings, processed in 102 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вы только поглядите: &lt;a href=&quot;http://www.postsharp.net/&quot;&gt;PostSharp&lt;/a&gt; решил пожелать мне счастливого понедельника, угостив плюшками Ultimate-версии (которые мне не особо нужны), но сломав при этом построение моего проекта! Не ожидал я от него такого, не ожидал. Но почему же только отлаживать было нельзя? А всё потому, что мы использовали PostSharp для логирования в Debug mode, в Release он не попадал.&lt;/p&gt;
&lt;p&gt;Если у вас возникла подобная проблема, то лечится она просто. Некоторое гугление даёт нам информацию о том, что в недавних версиях PostSharp-а были различные дефекты (например, такой: [http://www.postsharp.net/blog/post/URGENT-ACTION-REQUIRED-Critical-Defect-in-PostSharp-31-process-exits-with-code-199](Critical Defect in PostSharp 3.1)), которые могли сделать вашу жизнь достаточно грустной. Описанный выше баг является достаточно старым. Я нашёл историю от марта 2012 (PostSharp 2.1) с замечательным названием &lt;a href=&quot;https://plus.google.com/113181962167438638669/posts/QF5pDB4XY6F&quot;&gt;&#171;PostSharp bugs that occur only on a Monday? Really? :(&#187;&lt;/a&gt;. К счастью, в актуальной версии PostSharp-а проблема вроде бы ушла. У меня на 3.1.48 всё заработало хорошо. Счастливого понедельника PostSharp мне всё ещё желает, но pipe server при этом остаётся целым.&lt;/p&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Мне сложно сформировать какую-то конкретную мораль этой истории. Скажу только то, что она научила меня шире смотреть на проблемы, которые могу возникнуть. А ещё, если студия плюётся в вас какими-то непонятными ошибками, то в первую очередь нужно не думать о проблеме и о возможных причинах её возникновения, а сразу смотреть лог от MSBUILD-а. А ещё я выяснил, что за последние несколько месяцев никто в нашей команде не отлаживал приложение по понедельникам =)&lt;/p&gt;</description>
            </item>
            <item>
                <title>Получение MCP: личный опыт</title>
                <link>http://aakinshin.net/ru/blog/dotnet/ms-mcp/</link> 	
                <pubDate>Thu, 24 Jul 2014 12:46:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/ms-mcp/</guid>
                <description>&lt;p&gt;Не так давно мне на работе перепал ваучер на бесплатную сдачу экзамена от Microsoft. &#171;А почему бы и нет?&#187; — подумал я. План был выполнен успешно, в связи с чем мне хотелось бы поделиться личным опытом. Возможно, эта история пригодится тем, кто только собирается начать получать сертификации от Microsoft.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/ms-mcp/mvp-roadmap.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3&gt;Выбираем экзамен&lt;/h3&gt;
&lt;p&gt;Я очень долго медитировал на схему, приведённую выше. Ух, ну и понаделали же разных экзаменов! Увы, большинство из них (всякие Lync Server, SharePoint, JavaScript и т.п.) не привлекли моего внимания. Выбор остановился на экзамене &lt;a href=&quot;https://www.microsoft.com/learning/ru-ru/exam-70-483.aspx&quot;&gt;070-483&lt;/a&gt; &#171;Programming in C#&#187;.&lt;/p&gt;
&lt;h3&gt;Готовимся к экзамену&lt;/h3&gt;
&lt;p&gt;Перед экзаменом полагается готовиться.
Я пришёл к выводу, что лучшей подготовкой к экзамену будет несколько лет программирования на C#.
Если хочется почитать книжку, то лучше всего пойдёт классика под .NET: &lt;a href=&quot;https://www.goodreads.com/book/show/16033480-clr-via-c&quot;&gt;CLR via C#&lt;/a&gt; от Джеффри Рихтера.
Но, давайте взглянем, что же предлагает нам интернет в плане подготовки.
Первой книжкой, которая попалась мне на глаза, была &lt;a href=&quot;https://www.goodreads.com/book/show/17082095-mcsd-certification-toolkit-exam-70-483&quot;&gt;MCSD Certification Toolkit (Exam 70-483): Programming in C#&lt;/a&gt;.
Ох, лучше бы я её никогда не открывал. И вам не советую. С первых же глав в глаза бросается чудовищное количество ошибок. Причём, не спорных мест, а именно очень грубых ошибок. Готовиться по ней к чему бы то ни было просто не представляется возможным.
Второй книжка была &lt;a href=&quot;https://www.goodreads.com/book/show/16144492-exam-ref-70-483&quot;&gt;Exam Ref 70-483: Programming in C#&lt;/a&gt; от замечательного человека по имени &lt;a href=&quot;http://wouterdekort.blogspot.ru/&quot;&gt;Wouter de Kort&lt;/a&gt;. Это уже намного более адекватное чтиво. Не скажу, что по ней можно на 100% подготовится, но она хотя бы даёт неплохое представление о том, что вообще нужно знать к экзамену.
Можете также почитать достаточно подробную &lt;a href=&quot;http://sonyks2007.blogspot.ru/2014/02/microsoft-exam-70-483.html&quot;&gt;рецензию на эти книжки&lt;/a&gt;.
А ещё, я наткнулся на замечательный блог &lt;a href=&quot;http://mypathto70-483.blogspot.ru/&quot;&gt;mypathto70-483.blogspot.ru&lt;/a&gt;. Автор блога основательно готовится к экзамену, подробно прорабатывая каждую (даже самую небольшую) тему из экзаменационного перечня. По мере подготовки с хорошей регулярностью появляются соответствующие посты. &lt;em&gt;Update: В настоящее время автор успешно сдал экзамен&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Хочется отметить, что если вы неплохой .NET-разработчик, если вы понимаете как работает платформа и неплохо помните стандартные классы, то можно почти не готовиться. Разве что, просмотреть те темы, с которыми вам сталкиваться не приходилось (например, криптографию, многопоточность, работу со сборками или профилирование приложений — далеко не всем по работе попадаются все тематики экзамена).&lt;/p&gt;
&lt;h3&gt;Записываемся на экзамен&lt;/h3&gt;
&lt;p&gt;Большую часть времени я нахожусь в Новосибирске, так что экзамен решил проходить тут же. В Нск сертификацией от Microsoft занимается &lt;a href=&quot;http://www.sibinfo.ru/&quot;&gt;Сибинфоцентр&lt;/a&gt;. Если есть какие-то непонятности, то можно туда позвонить и получить подробную консультацию по всем интересующим вас вопросом.&lt;/p&gt;
&lt;p&gt;Непосредственную регистрацию необходимо проходить на сайте &lt;a href=&quot;www.prometric.com&quot;&gt;https://www.prometric.com&lt;/a&gt;. У сайта, мягко говоря, с навигацией проблемы. Дам подсказку: чтобы записаться на экзамен, нужно сначала зарегистрироваться. А регистрация происходит по нажатию на надпись &#171;IT TEST TAKER Account Sign-In&#187; в центре страницы, которая умело маскируется под радиобаттон. После этого всё просто: проходите регистрацию, выбираете экзамен (категория &lt;i&gt;Microsoft (070, 071, 074, MBx)&lt;/i&gt;), выбираете нужный центр тестирования и удобное для вас время. Как правило, свободного времени хватает — отчего-то особых очередей на сдачу Microsoft-овских экзаменов не наблюдается.&lt;/p&gt;
&lt;h3&gt;Сдаём экзамен&lt;/h3&gt;
&lt;p&gt;В Сибинфоцентре мне очень понравилось. Пришёл я с хорошим временным запасом, так что мне предложили дождаться начала экзамене в местной комнате отдыха:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/ms-mcp/subinfocenter.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Комната отдыха хороша: есть чай, кофе и вкусные печеньки. Причём, печеньки действительно вкусные — ощущается, что ребята не набрали каких попало, а именно выбирали повкуснее. Ценю я внимание к мелочам =). Также есть всякие проспектики о проводимых в центре сертификациях, так что вполне можно занять себя кофейком и полезным чтением.&lt;/p&gt;
&lt;p&gt;Вскоре пришёл ответственный за проведение Microsoft-овского тестирования. Надо отдать ему должное — он меня хорошо проинструктировал о процессе прохождении экзамена и подробно ответил на все вопросы. В общем, ребята держат достойный уровень.&lt;/p&gt;
&lt;p&gt;Перед экзаменом необходимо предъявить два удостоверения личности (в моём случае подошли паспорт и водительское удостоверение). Все личные вещи складываются в сейф, т.к. в экзаменационную комнату их проносить нельзя. С собой выдаётся лишь два специальных листа бумаги и два маркера (впрочем, за время экзамена мне не довелось их испытать).&lt;/p&gt;
&lt;p&gt;Перед экзаменом я наподписывал всяких &lt;a href=&quot;https://www.microsoft.com/learning/en-us/certification-exam-policies.aspx&quot;&gt;NDA&lt;/a&gt;, поэтому особо ничего про экзамен рассказать не могу, ограничусь лишь впечатлениями. Экзамен меня порадовал: все вопросы весьма адекватные и корректные (что особенно радует после подготовительной литературы). Было несколько вопросов, которые меня смутили, но тут скорее всего со мной что-то не так, а не с экзаменом. Тестирующая система тоже порадовала: всё понятно, пользоваться удобно, ничего не глючит — сплошное удовольствие. Перед экзаменом также можно пройти быстрый туториал по тому, как ей пользоваться, ввиду чего непонятных моментов не остаётся вовсе. Основная часть экзамена идёт два часа, но этого более, чем достаточно. Если вы всё знаете, то можно успеть прочитать каждый вопрос на несколько раз, подумать, ещё раз перечитать вопрос, ещё раз основательно подумать, выбрать правильный ответ, а по окончанию тестирования ещё раз всё проверить. А если вы что-то не знаете, то дополнительное время не особо поможет. У меня на всё вместе с проверкой ушло 1.5 часа. После окончания тестирования вам предложат написать комментарии к вопросам (они отправляются в Microsoft для улучшения качества тестирования), а также пройти короткий опросник об уровне сертификации (но это всё опционально). Предварительные результаты (а скорее всего они и будут окончательными) сразу показываются на экране.&lt;/p&gt;
&lt;p&gt;После успешного прохождения экзамена вам на руки выдаются ваши результаты в печатном виде с рифлёной печатью и подписью, после чего предлагается ждать письма на почту. Результаты тестирования отправляются сперва в Prometrics, затем в Microsoft, где их должны аккуратно проверить в течении 7 рабочих дней. Начитавшись разных отзывов о получении MCP (&lt;a href=&quot;http://sonyks2007.blogspot.ru/2014/02/mcp.html&quot;&gt;раз&lt;/a&gt;, &lt;a href=&quot;http://www.danshin.ms/2007/12/mcp.html&quot;&gt;два&lt;/a&gt;) я опасался, что эта часть затянется. Но Microsoft меня порадовали: уже на следующий день мне пришло письмо, по ссылке из которого я зарегистировался на сайте &lt;a href=&quot;http://mcp.microsoft.com/&quot;&gt;mcp.microsoft.com&lt;/a&gt;. После этой процедуры выдаётся учётная запись, с которой связывается свежевыданный &lt;em&gt;Micrisoft Certification ID&lt;/em&gt;. Из под этой учётной записи можно в любой момент смотреть все сданные экзамены, планировать будущие экзамены и расшаривать данные о сертификатах заинтересованным лицам. Собственно говоря, после регистрации я увидел у себя две записи: &lt;em&gt;MCPS: Microsoft Certified Professional&lt;/em&gt; и &lt;em&gt;MS: Programming in C# Specialist&lt;/em&gt;. Выглядят они примерно так:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/ms-mcp/mcp.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;У Microsoft есть также более крутые сертификации, для получения которых нужно пройти несколько экзаменов. После 70-483 можно качаться либо в &lt;em&gt;MCSD: Windows Store Apps Using C#&lt;/em&gt;, либо в &lt;em&gt;MCSD: Web Applications&lt;/em&gt;. Но, увы, подобные штуки меня уже не настолько вдохновляют. Так что будем ждать, когда MS проведут очередную реорганизацию системы сертификатов, чтобы в ней появилось что-нибудь более заманчивое =).&lt;/p&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Впечатления от мероприятия сугубо положительные, опыт полезный. Если вы в себе ощущаете силы пройти подобную сертификацию, а также у вас есть на это время и возможности ($80 или ваучер), то я бы посоветовал озадачиться. Как минимум, это достаточно интересно, а бумажка от MS тоже лишней не будет, можно будет включить в резюме.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Рефакторить или не рефакторить?</title>
                <link>http://aakinshin.net/ru/blog/dev/refactoring/</link> 	
                <pubDate>Sat, 19 Jul 2014 11:59:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dev/refactoring/</guid>
                <description>&lt;p&gt;Мне нравится рефакторинг. Нет, не так. Я люблю рефакторинг. Не, даже не так. Я &lt;em&gt;чертовски&lt;/em&gt; люблю рефакторинг.&lt;/p&gt;
&lt;p&gt;Я не переношу плохой код и плохую архитектуру. Меня коробит, когда я пишу новую фичу, а в соседнем классе творится полный бардак. Я просто не могу смотреть на печально названные переменные. Иногда перед сном я закрываю глаза и представляю, что можно было бы улучшить в проекте. Иногда я просыпаюсь в три часа ночи и иду к ноутбуку, чтобы что-нибудь поправить. Мне хочется, чтобы на любой стадии разработки код был не просто кодом, а произведением искусства, на которое приятно смотреть, с которым приятно работать.&lt;/p&gt;
&lt;p&gt;Если вы хоть немного разделяете мои ощущения, то нам есть о чём поговорить. Дело в том, что со временем что-то внутри меня начало подсказывать, что рефакторить всё подряд, везде и всё время — не самая лучшая идея. Поймите меня правильно, код должен быть хорошим (а лучше бы ему быть идеальным), но в условиях суровой реальности не всегда разумно постоянно заниматься улучшением кода. Я вывел для себя несколько правил о своевременности рефакторинга. Если у меня начинают чесаться руки что-нибудь улучшить, то я оглядываюсь на эти правила и начинаю думать: &#171;А действительно ли сейчас тот момент, когда нужно нарефакторить?&#187;. Давайте порассуждаем о том, в каких же случаях рефакторинг уместен, а в каких — не очень.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dev/refactoring/front.png&quot; height=&quot;200px&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
**Дисклеймер.** Скорее всего, многим захочется после прочтения поста сразу сказать: &#171;Да это уже 600 раз обсуждалось!&#187; или &#171;Это же настолько очевидно, зачем же об этом писать?&#187;. Возможно, вы и правы, но только вот какой момент: в окружающем мире по-прежнему творится хаос. Вроде бы всем всё понятно, но на деле получается, что не так уж и понятно. Поэтому я думаю, что не будет слишком вредно ещё разок взглянуть на эту тему. Но если конкретно у вас проблем с рефакторингом нет, то можете просто пропустить этот пост, у вас уже всё хорошо.
&lt;h3&gt;Слишком ранний рефакторинг&lt;/h3&gt;
&lt;p&gt;Можете ли вы припомнить, когда у вас последний раз было постоянное ТЗ, которое месяцами не менялось? У меня вот такое вспомнить не очень получается. Мы живём в реальном мире, требования всё время меняются. Причём это не обязательно внешние требования — это могут быть ваши собственные требования к проекту. Поясню мысль на примере: допустим, вы взяли задачку среднего размера на один-два дня. Первые несколько классов уже написаны, но запустить пока нечего — идёт процесс написания суровой архитектурной части. И тут вы замечаете, что одна из частей проекта написана не особо универсально: &#171;А вот если через полгода понадобится сделать X, то все будут страдать&#187;. Вполне разумно, что вам не хочется отправлять в репозиторий хреновый код, чтобы другие разработчики потом вспоминали вас плохим словом. И вы начинаете рефакторить &lt;em&gt;ещё не готовую фичу&lt;/em&gt;. Иногда это оправдано, но на подобном пути следовало бы повесить табличку &#171;ОПАСНОСТЬ&#187;. Вот поправите вы одну штуку, потом другую, потом третью. Неделя прошла, фича всё ещё не запускается, а вы говорите: &#171;Как-то всё неправильно сделано. Но теперь я &lt;em&gt;точно понял&lt;/em&gt;, как надо делать. Сейчас быстренько всё перепишу с нуля&#187;. Основная проблема заключается в том, что фидбека по фиче ещё не получено, а вы уже начали работать над улучшением кодовой базы. Подобный подход редко приводит к успеху. Не знаю, как у вас, а у меня часто бывает, что после реализации фичи я начинаю понимать, что работать всё должно несколько иначе. И это не из-за того, что я такой глупый, заранее не смог нормально продумать. Просто некоторую функциональность нужно &#171;пощупать&#187;, чтобы понять как всё должно быть в релизе. Иногда нужен небольшой прототипчик (пусть даже с говнокодом и багами), чтобы обсудить фичу с коллегами. Иногда нужно что-то показать заказчику, чтобы он мог сказать: &#171;Не, ну я не так хотел, всё должно быть наоборот&#187;. Порой пользователями не нравятся нововведения, они хотят всё как было. Проблема новых фич в том, что сложно предсказать их судьбу. Нередко случается так, что все наработки отправляются в помойку, т. к. после обсуждения первой версии коллектив принял решение делать всё иначе. Общий вывод: не стоит рефакторить код слишком рано, особенно если вы не уверены, что этот код 100 % останется в проекте.&lt;/p&gt;
&lt;h3&gt;Нецелевой рефакторинг&lt;/h3&gt;
&lt;p&gt;Скорее всего, у вас есть план разработки на ближайшее время. Вполне вероятно, что у вас есть сроки (даже если вы их поставили сами). Релизы нужно делать вовремя, затягивать разработку не стоит. Нужно контролировать себя, нужно заниматься теми вещами, которые входят в ваши непосредственные цели. Допустим, у вас есть кусок кода, который выглядит как полное... Ну, в общем, плохо выглядит. Но, продолжим наше допущение, вы с ним сейчас не работаете. Этот плохой кусок кода стабильно работает, успешно справляется со своими задачами и никак не связан с вашей текущей задачей. Ну так и не трогайте его! Да, вас может крайне печалить то обстоятельство, что на другом конце проекта &lt;em&gt;всё очень плохо&lt;/em&gt;. Но заметьте, что прямо сейчас вам это никак не мешает. У вас есть текущие задачи, занимайтесь ими. Конечно, бывают задачи по улучшению кодовой базы, но нечасто — зачастую важнее добавлять новый функционал или фиксить баги. Концентрируйтесь на текущих задачах и не бросайте их из-за того, что где-то там что-то как-то не так.&lt;/p&gt;
&lt;h3&gt;Рефакторинг ради рефакторинга&lt;/h3&gt;
&lt;p&gt;Ок, вы пришли к выводу, что нужно обязательно отрефакторить часть проекта. Хорошо, давайте отрефакторим. Вроде бы запланированные улучшения выполнены, но тут возникает мысль: &#171;А что я могу ещё улучшить? Ага, вон ту штуку&#187;. А после вон той штуки появится вот эта штука, а потом ещё одна, а потом ещё и т. д. Нужно понимать, что есть плохой код, есть хороший код, есть идеальный код. Последнего в большом проекте у вас никогда не будет. Это не значит, что не нужно к нему стремиться, но нужно понимать его недостижимость. Обычно задача стоит в написании хорошего кода, а не идеального. Допустим, после рефакторинга у вас получился вполне читаемый код, который работает более или менее очевидным образом, в котором нет костылей и которым не так сложно пользоваться. Задайте себе вопрос: &#171;А может, пора остановиться?&#187;. Да, код можно улучшать. Причём в достаточно большом проекте его можно улучшать до бесконечности. Но вот прямо сейчас он справляется со своими функциями, им удобно пользоваться, он практически не вызывает у вас дискомфорта. Очень важно определить для себя &lt;em&gt;приемлемое&lt;/em&gt; качество кода, после которого вы перестанете его улучшать (до тех пор, пока свойство приемлемости не будет утрачено). Вспомните, что есть ещё так много разных клёвых штук, которые можно дописать. Не нужно рефакторить ради самого рефакторинга, ради идеального кода. Нужно рефакторить, когда у вас есть &lt;em&gt;веские&lt;/em&gt; причины на это: код сложно прочитать, код сложно поддерживать, код сложно развивать, код сложно использовать и т. п. Если ни одного &#171;сложно&#187; не возникает, то &lt;em&gt;веских&lt;/em&gt; причин тратить время на рефакторинг у вас нет.&lt;/p&gt;
&lt;h3&gt;Рефакторинг за день до релиза&lt;/h3&gt;
&lt;p&gt;Бывает так, что релиз послезавтра/завтра/сегодня/должен был быть вчера (нужное подчеркнуть). Это важный момент в жизни проекта. Нужно уделить особое внимание тестированию, фиксам критических багов, финальным доделкам. Поверьте, это действительно плохая идея — перерабатывать кодовую базу (а ещё хуже — качественно перерабатывать) в тот момент, когда нужно отдавать проект в продакшн. Опытная практика подсказывает, что нужно зарелизиться, а потом с чистой совестью спокойно улучшать код. Некоторые спросят: &#171;А почему?&#187;. Если такой вопрос возник, то, наверное, вам ещё не приходилось делать сложный рефакторинг. Подскажу: при переписывании код не всегда обязательно улучшается — иногда он может сломаться. Да что там сложный рефакторинг — бывает, поправишь один метод на пять строк, не уследишь за какой-нибудь зависимостью, а на другом конце проекта выползет бага, с которой сразу же встретятся ваши любимые пользователи. Вот вроде бы ничего плохого и не делаешь, а тут внезапно на тебя нападает зверь &#171;Это было неочевидно&#187; и топит тебя в пруду ложной первоначальной оценки. Хотя, может, это просто я такой плохой программист — люблю что-нибудь сломать. Вполне возможно, что вы всегда рефакторите всё абсолютно правильно и с полным контролем всего проекта. В таком случае я могу вас поздравить, но от совета с запретом предрелизного рефакторинга всё-таки не откажусь. Поверьте, за несколько дней рефакторинг никуда не убежит, а сон у всей команды будет чуточку, но спокойней.&lt;/p&gt;
&lt;h3&gt;Рефакторинг очень старого кода&lt;/h3&gt;
&lt;p&gt;Вопрос тяжёлый, очень тяжёлый. Ситуация: есть огромное количество ужасных строк кода, которые достались вам от старых разработчиков (возможно, этими старыми разработчиками были вы несколько лет назад, ещё до того, как научились писать всё правильно и сразу). Код приходится поддерживать. То там, то тут возникают костыли и дублирования, энтропия растёт. С каждым днём всё больше хочется выкинуть всё и переписать с нуля. В такой момент нужно &lt;em&gt;очень хорошо&lt;/em&gt; подумать о рисках. Да, вполне вероятно, что в перспективе такая деятельность будет полезна. Но в какой именно перспективе и насколько полезна? Скорее всего, в процессе большого рефакторинга или переписывания отдельных частей вы замените старый работающий говнокод новым, идеально написанным кодом, но с багами. И вовсе не из-за того, что вы плохой программист и пишете плохо. Просто вы можете не знать этот код &lt;em&gt;в достаточной мере&lt;/em&gt;. Вы можете не знать, почему автор написал всё именно так, а ведь причины могли быть. Иногда приходится писать очень странный и кривой код. Я могу придумать очень много примеров: подавление хитрых оптимизаций процессора, подстройка под баги сторонней библиотеки, подавление каких-нибудь многопоточных косяков и т. д. Я не говорю, что нельзя все эти проблемы решить нормально. Просто иной раз при переписывании казалось бы абсурдного кода на нормальный появляются баги. Да, можно было всё сделать нормально, но вы можете просто не осознать всё величие шалаша из костылей вместо палок, если не узнаете у автора кода, почему он написал именно так (а подобная возможность предоставляется далеко не всегда). Будьте осторожны, когда переписываете старый код, который понимаете не до конца (а особенно, если думаете, что понимать там нечего).&lt;/p&gt;
&lt;h3&gt;А когда рефакторить-то?&lt;/h3&gt;
&lt;p&gt;Я прошу прощения, если из этой статьи у вас сложилось впечатление, что от рефакторинга одни проблемы. Я всё ещё настаиваю на том, что код должен быть читаемым и красивым, им должно быть удобно пользоваться, его должно быть легко развивать. Позитивный подход лучше негативного, так что относитесь к рефакторингу не как к источнику проблем, а как к своему очень хорошему другу, который выручит вас в трудную минуту. Более того, этот друг может сделать так, чтобы в вашем светлом будущем трудных минут было бы поменьше. Хотелось бы в завершении обозначить несколько моментов, когда рефакторинг действительно уместен.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Нечего делать.&lt;/strong&gt;
Бывают спокойные времена простоя, когда все важные задачи закрыты, а новых пока не поставлено. Ну, не то чтобы совсем нечего делать, но определённое количество свободного времени есть. Потратьте его на улучшение кода. Дайте сущностям понятные имена, избавьтесь от дублирования, перепишите неудачный кусок архитектуры. Хоть нового функционала и не добавляется, но вы вкладываете свою лепту в душевное спокойствие разработчиков, которые будут продолжать проект. Поверьте, это важно.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Каждодневные страдания.&lt;/strong&gt;
А бывает так, что есть кусок проекта, который заставляет вас тяжело вздыхать каждый день. А из-за соседних столов слышатся тяжёлые вздохи ваших коллег. Конечно, хоть и релиз и не завтра, но важных задач хватает. Тем не менее, за неделей проходит неделя, а смотреть на этот кусок проекта всё грустнее. Скажите себе: &#171;Хватит это терпеть!&#187;. Если бизнес-план составляет начальник, то объясните ему, что этот код просто необходимо переписать. Если работаете на заказчика, то убедите его, что потраченная на рефакторинг неделя позволит сэкономить много времени на разработку в будущем. Если работаете на пользователей, то примите решение о том, что лучше бы этим пользователям в этот раз подождать релиза на недельку больше, но зато потом наслаждаться стабильным ПО и регулярными обновлениями. Да, договориться со всеми и с самим собой не всегда просто, но вы уж постарайтесь.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Проблема запоздалого рефакторинга.&lt;/strong&gt;
Не стоит абсолютизировать правило про слишком ранний рефакторинг. Некоторые считают так: &#171;Я вот сейчас наулучшаю чего-нибудь, а оно не пригодится — обидно же будет&#187;. Нужно понимать, что в ядре программы вполне могут быть важные части, которым лучше бы быть написанными хорошо. Помните, что чем позже вы проводите рефакторинг — тем выше его цена, ведь вы потратите больше времени и сил на переписывание. Критические базисные вещи (которые используются по всему проекту) должны быть в максимально хорошей форме постоянно. Будет просто прекрасно, если в вашей команде будет работать тезис
&lt;em&gt;&#171;Рефакторинг не опаздывает. Он приходит строго тогда, когда считает нужным&#187;&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Встреча с монстром.&lt;/strong&gt;
Вы начинаете пилить новый функционал, который должен использовать старый кусок проекта, который выглядит как настоящий монстр: вам становится страшно только при взгляде на внешний интерфейс. Если время позволяет, то поправьте сперва базовую часть кода, чтобы потом сосредоточиться на новом функционале и не отвлекаться на то, чтобы вбить пяток костылей ради повторного использования кода.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Разумный перфекционизм.&lt;/strong&gt;
Заметили плохой кусок кода? Хочется его поправить? Очень хочется его поправить? Ну, если прям очень хочется, то можно. Но обратите внимание на слово &#171;разумный&#187;. Соотносите время, потраченное на рефакторинг, с выгодой от улучшения кода. Не стоит срывать сроки и зарываться в бесконечные улучшения. Однако если своевременно и в меру заниматься рефакторингом, то проекту от этого станет только лучше.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Вместо заключения&lt;/h3&gt;
&lt;p&gt;Всё вышеперечисленное является чисто субъективным обобщением опыта работы над рядом проектов. Разумеется, я покрыл далеко не все жизненные ситуации. В каждой команде свои требования к коду, свой бизнес-план и свои правила. Уверен, что у многих найдётся пяток историй из серии &#171;А вот у меня был случай, когда все эти советы не работают&#187;. Это абсолютно нормально, так и должно быть. Нет универсальной серебряной пули для определения количества усилий на улучшение кода (&#171;Мы будем каждый день 47 минут 23 секунды заниматься рефакторингом — и всё у нас будет хорошо&#187;). Вам нужно исходя из собственного опыта в вашем конкретном проекте, в вашей конкретной команде попытаться найти золотую середину между написанием нового кода и улучшением старого. Я агитирую только за то, чтобы ко всему было рациональное отношение без фанатизма (&#171;Зачем улучшать код, нового функционала от этого не появится&#187; / &#171;Нужно срочно весь код сделать идеальным, чтобы потом с ним можно было нормально работать&#187;). Подходите разумно к распределению времени на работу над существующим кодом — и всё у вас будет хорошо.&lt;/p&gt;
&lt;p&gt;Приветствуются любые дополнительные мысли о том, когда стоит или не стоит рефакторить. Одна из наиболее ценных вещей в этой области — опыт реальных разработчиков над реальными проектами.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://habrahabr.ru/company/enterra/blog/229051/&quot;&gt;Оригинал на Хабрахабре&lt;/a&gt;&lt;/p&gt;</description>
            </item>
            <item>
                <title>Раскрашиваем R в терминале: пакет colorout</title>
                <link>http://aakinshin.net/ru/blog/r/colorout/</link> 	
                <pubDate>Fri, 11 Jul 2014 12:00:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/colorout/</guid>
                <description>&lt;p&gt;В последнее время мне часто приходится гонять R-скрипты на удалённом Linux-сервере. Большую часть работы я выполняю на домашней машине, но иногда приходится отлаживать скрипты прямо на сервере. В этом мне очень помогает пакет &lt;strong&gt;colorout&lt;/strong&gt;, который умеет красиво раскрашивать R в терминале. Давайте взглянем на него чуть подробнее.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/colorout/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Пакета нет в &lt;a href=&quot;http://cran.r-project.org/&quot;&gt;CRAN&lt;/a&gt;, но зато он &lt;a href=&quot;%22https://github.com/jalvesaq/colorout&quot;&gt;выложен&lt;/a&gt; на GitHub-е, так что установить последнюю версию проще всего с помощью &lt;a href=&quot;http://cran.r-project.org/web/packages/devtools/index.html&quot;&gt;devtools&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(devtools)
install_github(&#39;jalvesaq/colorout&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Чтобы пакет подключался автоматически, необходимо прописать &lt;code&gt;library(colorout)&lt;/code&gt; в &lt;code&gt;.Rprofile&lt;/code&gt; или &lt;code&gt;Rprofile.site&lt;/code&gt;. Если вы запускаете R из различных окружений, то сперва стоит проверить, что данная сессия запущена из терминала (в этом поможет &lt;code&gt;Sys.getenv(&amp;quot;TERM&amp;quot;)&lt;/code&gt;). Давайте взглянем на то, как теперь выглядит работа с R. Для этого воспользуемся &lt;a href=&quot;http://www.lepem.ufc.br/jaa/colorout.html&quot;&gt;примером&lt;/a&gt; от автора пакета:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;cat(&amp;quot;Different colors for normal text, \&amp;quot;string\&amp;quot;, dates (&amp;quot;,
     as.character(Sys.Date()), &amp;quot;)\n&amp;quot;,
     &amp;quot;numbers (12, -1.3), NULL, NA, NaN, Inf, TRUE and FALSE.\n&amp;quot;, sep = &amp;quot;&amp;quot;)
x &amp;lt;- data.frame(logic=c(T, T, F), factor=factor(c(&amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;, &amp;quot;ghi&amp;quot;)),
                string=c(&amp;quot;ABC&amp;quot;, &amp;quot;DEF&amp;quot;, &amp;quot;GHI&amp;quot;), real=c(1.23, -4.56, 7.89),
                cien.not = c(1.234e-23, -4.56e+45, 7.89e78),
                date=as.Date(c(&amp;quot;2012-02-21&amp;quot;, &amp;quot;2013-02-12&amp;quot;, &amp;quot;2014-03-04&amp;quot;)),
                stringsAsFactors = FALSE)
rownames(x) &amp;lt;- 1:3
x
summary(x[, c(1, 2, 4, 6)])
# Warnings and erros are highlighted (even if not in English):
warning(&amp;quot;This is an example of warning.&amp;quot;)
example.of.error
# Messages sent to stderr are highlighted:
library(KernSmooth)
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/colorout/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Если ваш терминал поддерживает 256 цветов (&lt;code&gt;Sys.getenv(&amp;quot;TERM&amp;quot;)&lt;/code&gt; равно &lt;code&gt;&amp;quot;xterm-256color&amp;quot;&lt;/code&gt;, а не просто &lt;code&gt;&amp;quot;xterm&amp;quot;&lt;/code&gt;), то вы можете тонко подстроить цветовую гамму:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;# The colors are customizable:
setOutputColors()
setOutputColors256(normal = 39, number = 51, negnum = 183, date = 43,
                   string = 79, const = 75, verbose = FALSE)
x
setOutputColors256(202, 214, 209, 184, 172, 179, verbose = FALSE)
x
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/colorout/screen3.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Если поддержки 256-и цветов нет, то выставить нужные цвета поможет обычный &lt;code&gt;setOutputColors&lt;/code&gt;. На сегодняшний день у функций &lt;code&gt;setOutputColors&lt;/code&gt; и &lt;code&gt;setOutputColors256&lt;/code&gt;
имеются следующие аргументы:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  normal: Formating and color of normal text.
  number: Formating and color of numbers.
  negnum: Formating and color of negative numbers.
    date: Formating and color of dates (output in the format
          &#39;yyyy-mm-dd&#39;).
  string: Formating and color of quoted text.
   const: Formating and color of &#39;TRUE&#39;, &#39;FALSE&#39;, &#39;NULL&#39;, &#39;NA&#39;, &#39;NaN&#39;
          and &#39;Inf&#39;.
stderror: Formating and color of text sent to stderr.
    warn: Formating and color of warnings.
   error: Formating and color of errors.
 verbose: Logical value indicating whether to print colored words
          showing the result of the setup.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как и всегда, полную справку вы можете получить с помощью команд &lt;code&gt;?setOutputColors&lt;/code&gt;, &lt;code&gt;?setOutputColors256&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В общем, &lt;strong&gt;colorout&lt;/strong&gt; — отличный штука! Всем рекомендую. А с помощью пакета &lt;strong&gt;txtplot&lt;/strong&gt; можно прямо в консоли смотреть цветные графики =).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(txtplot)
txtcurve(sin(pi*x),from=0,to=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/colorout/screen4.png&quot; /&gt;
&lt;/p&gt;</description>
            </item>
            <item>
                <title>Странное поведение FindElementsInHostCoordinates в WinRT</title>
                <link>http://aakinshin.net/ru/blog/dotnet/findelementsinhostcoordinates/</link> 	
                <pubDate>Tue, 29 Apr 2014 13:24:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/findelementsinhostcoordinates/</guid>
                <description>&lt;p&gt;Есть в Silverlight отличный метод: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.media.visualtreehelper.findelementsinhostcoordinates(v=vs.95).aspx&quot;&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/a&gt; — позволяет выполнять &lt;code&gt;HitTest&lt;/code&gt;, т.е. для некоторой точки или прямоугольника искать все объекты визуального поддерева, которые с этими точкой или прямоугольником пересекаются. Внешне точно такой же метод &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.visualtreehelper.findelementsinhostcoordinates.aspx&quot;&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/a&gt; можно встретить в WinRT. И вроде выглядит-то он точно также, но есть нюанс: работает этот чудо-метод в разных версиях платформы по-разному. Давайте разберёмся.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Сначала создадим простое Silverlight 5 приложение. Основная вёрстка будет выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Grid x:Name=&amp;quot;LayoutRoot&amp;quot;&amp;gt;
  &amp;lt;Grid.RowDefinitions&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;*&amp;quot;/&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;/Grid.RowDefinitions&amp;gt;

  &amp;lt;Canvas MouseLeftButtonDown=&amp;quot;OnMainCanvasMouseLeftButtonDown&amp;quot; 
          x:Name=&amp;quot;MainCanvas&amp;quot; Background=&amp;quot;LightGreen&amp;quot;&amp;gt;
    &amp;lt;Ellipse Width=&amp;quot;200&amp;quot; Height=&amp;quot;200&amp;quot; Fill=&amp;quot;LightCoral&amp;quot; /&amp;gt;
    &amp;lt;Path Fill=&amp;quot;LightBlue&amp;quot; Data=&amp;quot;M 10,100 C 10,300 300,-200 300,100&amp;quot;/&amp;gt;
  &amp;lt;/Canvas&amp;gt;

  &amp;lt;TextBlock Grid.Row=&amp;quot;1&amp;quot; x:Name=&amp;quot;StatusBlock&amp;quot; /&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут всё очень просто: имеется &lt;code&gt;Canvas&lt;/code&gt;, а на нём лежит &lt;code&gt;Ellipse&lt;/code&gt; и &lt;code&gt;Path&lt;/code&gt;. Прямо под этим чудесным произведением искусства находится &lt;code&gt;TextBlock&lt;/code&gt; в который мы можем вывести что-нибудь полезное. Выглядит приложение следующим образом:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Теперь напишем обработчик события для клика мышкой по нашему &lt;code&gt;Canvas&lt;/code&gt;-элементу: будем искать элементы, в которые мы попали. Для этого нам пригодятся две версии &lt;code&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/code&gt; (для точки и для прямоугольника):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static IEnumerable FindElementsInHostCoordinates(
 Point intersectingPoint,
 UIElement subtree
)
public static IEnumerable FindElementsInHostCoordinates(
 Rect intersectingRect,
 UIElement subtree
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Список полученных объектов будем выводить в &lt;code&gt;StatusBlock&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private void OnMainCanvasMouseLeftButtonDown(object sender, 
                                             MouseButtonEventArgs e)
{
  var p = e.GetPosition(MainCanvas);
  var listPoint = VisualTreeHelper.FindElementsInHostCoordinates(
                    new Point(p.X, p.Y), MainCanvas).ToList();
  var listRect = VisualTreeHelper.FindElementsInHostCoordinates(
                    new Rect(p.X, p.Y, 1, 1), MainCanvas).ToList();
  var strPoint = string.Join(&amp;quot;, &amp;quot;, 
                   listPoint.Select(el =&amp;gt; el.GetType().Name.ToString()));
  var strRect = string.Join(&amp;quot;, &amp;quot;, 
                   listRect.Select(el =&amp;gt; el.GetType().Name.ToString()));
  StatusBlock.Text = string.Format(&amp;quot;[{0}] vs [{1}]&amp;quot;, strPoint, strRect);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Наше отличное приложение готово! Что-то внутри подсказывает, что ввиду размеров прямоугольника (1x1) результаты работы двух перегрузок метода не должны отличаться. Давайте проверим, потыкав в разные места. Следующая картинка показывает результаты проведённого опыта:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Ну, вроде всё хорошо, методы отработали, как и ожидалось. А теперь перейдём к WinRT. Создадим новое Windows Store приложение и снабдим его аналогичной вёрсткой:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Grid Background=&amp;quot;{StaticResource ApplicationPageBackgroundThemeBrush}&amp;quot;&amp;gt;
  &amp;lt;Grid.RowDefinitions&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;*&amp;quot;/&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;/Grid.RowDefinitions&amp;gt;

  &amp;lt;Canvas Tapped=&amp;quot;OnMainCanvasTapped&amp;quot; 
          x:Name=&amp;quot;MainCanvas&amp;quot; Background=&amp;quot;LightGreen&amp;quot;&amp;gt;
    &amp;lt;Ellipse Width=&amp;quot;200&amp;quot; Height=&amp;quot;200&amp;quot; Fill=&amp;quot;LightCoral&amp;quot; /&amp;gt;
    &amp;lt;Path Fill=&amp;quot;LightBlue&amp;quot; Data=&amp;quot;M 10,100 C 10,300 300,-200 300,100&amp;quot;/&amp;gt;
  &amp;lt;/Canvas&amp;gt;

  &amp;lt;TextBlock Grid.Row=&amp;quot;1&amp;quot; x:Name=&amp;quot;StatusBlock&amp;quot; /&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Код обработчика &lt;code&gt;OnMainCanvasTapped&lt;/code&gt; полностью совпадает с кодом &lt;code&gt;OnMainCanvasMouseLeftButtonDown&lt;/code&gt;. Давайте запустим приложение и потыкаем в него. Результаты:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen3.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Вот это поворот! Недолгое кликанье по приложению быстро подведёт нас к выводу: точечный HitTest работает точно также, как и в Silverlight, а вот HitTest по прямоугольнику для Path-фигур работает не по самой фигуре, а по её BoundingBox-у (ограничивающему прямоугольнику). WinRT-приложения делаются по принципу Touch First, так что наиболее интересна именно Rect-версия метода. В большинстве случаев этот момент скорее всего будет не особо принципиален, но вот если приложение ориентировано на взаимодействие с различными изогнутыми элементами, то на особенность такого поведения &lt;code&gt;FindElementsInHostCoordinates&lt;/code&gt; лучше бы обратить особое внимание.&lt;/p&gt;</description>
            </item>
            <item>
                <title>CodeFest 2014: Отчёт</title>
                <link>http://aakinshin.net/ru/blog/notes/codefest-2014/</link> 	
                <pubDate>Mon, 31 Mar 2014 20:06:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/notes/codefest-2014/</guid>
                <description>&lt;p&gt;Есть в Сибири одна очень хорошая конференция, &lt;a href=&quot;http://codefest.ru&quot;&gt;CodeFest&lt;/a&gt; называется, бывает раз в год. В минувшие выходные это замечательное мероприятие проводилось уже в пятый раз, мы с друзьями просто не могли такое пропустить. Конференция прошла просто на отличненько, в связи с чем хотелось бы поделиться впечатлениями.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/notes/codefest-2014/front.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3&gt;Организация&lt;/h3&gt;
&lt;p&gt;Мероприятие организовано просто чудесно. Некоторые, конечно, жаловались на разные штуки типа огромных очередей. Но, чёрт возьми, это же конференция на 1700 человек! Бывал я на многих мероприятиях, у большинства проблема что-то нормально организовать даже человек на 50–100. Для масштабов CodeFest-а всё было великолепно, мелкие косяки вполне можно простить. Действо происходило в &lt;a href=&quot;http://www.novosibexpo.ru/&quot;&gt;Новосибирском экспоцентре&lt;/a&gt;. На популярных докладах было, конечно, не протолкнуться, но в целом здание внушающих размеров, парковки на всех хватает. Особо порадовали сушилки для рук в туалете, они прям как для людей сделаны (а какой вид из окна, какой вид).&lt;/p&gt;
&lt;p&gt;Размеры очереди на регистрации в первый день &lt;a href=&quot;http://instagram.com/p/mHIFCeDo0V/&quot;&gt;поражали воображение&lt;/a&gt;, из-за этого начало конференции немного задержалось. Думаю, стоило бы организовать регистрацию в несколько потоков, ну да ладно. Организаторы не растерялись, начали раздавать пакеты участников ожидающим. Помимо прочего всем дали по праздничной дуделке в честь др CodeFest-а. Расчёты показали, что если бы каждый из участников подудел бы 1 секунду, то можно было бы почти на полчаса волну организовать.&lt;/p&gt;
&lt;p&gt;Помимо докладов традиционно были стенды от разных компаний, которые раздавали ништяки, конкурсы всякие проводили. Некоторые даже &lt;a href=&quot;http://instagram.com/p/mIFpmfA1Gv/&quot;&gt;телефоны выигрывали&lt;/a&gt;. Наибольший ажиотаж собрал Oculus Rift, можно было надеть шапочку и погрузиться в мир виртуальной реальности. Отдельно была организована кофе-брейк зона. Правда, кофе и плюшки очень быстро заканчивались (о, как же некоторым не хватало кофе), но запасы относительно быстро пополнялись. Да и вообще, много всего прикольного было, есть на что посмотреть.&lt;/p&gt;
&lt;p&gt;Отдельная проблема была с тем, чтобы накормить всю эту толпу. Организаторы предоставляли обеды по заявкам, но &lt;a href=&quot;http://instagram.com/p/mKElsZodXG/&quot;&gt;очередная очередь&lt;/a&gt;
делала многих грустными. А мы с ребятами накануне наделали вкусных штук, спокойно покушали и даже вовремя успели на доклады.&lt;/p&gt;
&lt;p&gt;А если говорить в целом, то CodeFest безумно завлекает своей атмосферой и вниманием, которое организаторы проявляют к участником в весьма неформальном стиле.&lt;/p&gt;
&lt;h3&gt;Тусовка&lt;/h3&gt;
&lt;p&gt;А вообще, всё это не ради докладов делается. Не, доклады, конечно, были хороши. Но их и в записи посмотреть потом можно, пользы столько же будет. Главное в подобных мероприятиях — живое общение. Было очень приятно встретить несколько десятков знакомых лиц с разных уголков страны. Также удалось познакомиться с кучей новых людей, пообщаться на it-шные тематики, обменяться опытом. Лично я очень долго зависал на стенде от &lt;a href=&quot;http://www.jetbrains.com/&quot;&gt;JetBrains&lt;/a&gt;, там всё время интересные разговоры велись (JetBrains — вообще чудесные ребята, каждый CodeFest радуют).&lt;/p&gt;
&lt;p&gt;География события широка, народ съехался отовсюду, жилищный вопрос для многих стоял достаточно остро. Благо, в моём распоряжении находится квартира в Новосибирске, в которой на время конференции прописались делегации из Барнаула и Томска. Многие подобным образом собирались на квартирах у знакомых, что только добавляло шарма мероприятию — общение можно было вести ночью, днём, ночью, днём и ещё раз ночью. Некоторые товарищи после первого дня пошли на афтепати, а вот мы устроили своё афтепати: шашлыки жарили и за программирование разговаривали.&lt;/p&gt;
&lt;h3&gt;Доклады&lt;/h3&gt;
&lt;p&gt;Доклады были хороши, очень сильную команду спикеров набрали. В прошлом году мне несколько меньше понравилось (я по образованию .NET-разработчик, в связи с чем я чувствовал себя чужим на этом JavaScript-овом празднике жизни). В этом году (исключительно по моему скромному мнению) удалось достичь большего баланса: для каждого нашлось очень много интересного и полезного. Если в прошлом году мою конференцию сделал Кирилл Скрыган из JetBrains с &lt;a href=&quot;http://2013.codefest.ru/lecture/59&quot;&gt;докладом&lt;/a&gt;
про оптимизацию .NET-приложений, то в этом году свою медаль зрительских симпатий я отдал Алексею Шипилёву из Oracle за &lt;a href=&quot;http://2014.codefest.ru/lecture/832&quot;&gt;рассказ&lt;/a&gt;
про бенчмарки. На второй день он же устроил чудесную &lt;a href=&quot;http://2014.codefest.ru/lecture/896&quot;&gt;лекцию&lt;/a&gt; про Java Memory Model. JetBrains также порадовали
&lt;a href=&quot;http://2014.codefest.ru/lecture/842&quot;&gt;докладом&lt;/a&gt; от Сергея Шкредова про управление зависимостями.&lt;/p&gt;
&lt;p&gt;Во второй день наибольшую популярность имела PM секция, которая состояла просто из офигительных докладов. Меня больше всего впечатлили доклады от &lt;a href=&quot;http://2014.codefest.ru/lecture/806&quot;&gt;Григория Бакунова&lt;/a&gt; и &lt;a href=&quot;http://2014.codefest.ru/lecture/887&quot;&gt;Максима Дорофеева&lt;/a&gt; . Как появится видео — обязательно буду пересматривать. Коллеги из области QA свою секцию тоже очень хвалят — доклады читали те, кто действительно понимаю в тестировании.&lt;/p&gt;
&lt;p&gt;Да и вообще, хороших докладов было очень много, каждая секция для своей целевой аудитории была интересна. Увы, не удалось сходить на всё, но как только появится видео (организаторы обещают его в скором времени), нужно будет обязательно наверстать упущенное.&lt;/p&gt;
&lt;h3&gt;Заключение&lt;/h3&gt;
&lt;p&gt;Рассказ у меня получился очень сумбурным, но это просто от переполняющих меня впечатлений. Я просто хотел сказать, что CodeFest — это просто прекрасно, исключительно положительные ощущения. Много полезных знаний в голове, много новых интересных знакомств, много бесценного общения. Побольше было бы таких конференций. В следующем году однозначно нужно опять идти.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Про System.Drawing.Color и оператор ==</title>
                <link>http://aakinshin.net/ru/blog/dotnet/system-drawing-color-equals/</link> 	
                <pubDate>Fri, 21 Feb 2014 18:58:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/system-drawing-color-equals/</guid>
                <description>&lt;p&gt;Для многих стандартных структур в .NET-е переопределён оператор &lt;code&gt;==&lt;/code&gt;, который позволяет легко сравнивать ваши объекты. К сожалению, далеко не все задумываются о том, что на самом деле сравнивается при работе с этим замечательным оператором. В этой короткой заметке мы посмотрим логику сравнения объектов на примере &lt;code&gt;System.Drawing.Color&lt;/code&gt;. Как вы думаете, что выведет следующий код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var redName = Color.Red;
var redArgb = Color.FromArgb(255, 255, 0, 0);
Console.WriteLine(redName == redArgb);
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;&#171;И тут красный, и там красный. Наверное, объекты должны быть равны.&#187;, — подумает читатель. Но давайте откроем &lt;a href=&quot;http://www.dotnetframework.org/default.aspx/Net/Net/3@5@50727@3053/DEVDIV/depot/DevDiv/releases/whidbey/netfxsp/ndp/fx/src/CommonUI/System/Drawing/Color@cs/1/Color@cs&quot;&gt;исходный код&lt;/a&gt; и посмотрим на оператор &lt;code&gt;==&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static bool operator ==(Color left, Color right) {
    if (left.value == right.value
        &amp;amp;&amp;amp; left.state == right.state
        &amp;amp;&amp;amp; left.knownColor == right.knownColor) {

        if (left.name == right.name) {
            return true;
        }

        if (left.name == (object) null || right.name == (object) null) {
            return false;
        }

        return left.name.Equals(right.name);
    }

    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Изучение исходного кода подталкивает нас к интересному выводу: цвета сравниваются не по ARGB-значанию, а по свойству Name. Какое же имя у наших объектов? Давайте посмотрим:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(redName.Name); // Red
Console.WriteLine(redArgb.Name); // ffff0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм, имена-то разные. Таким образом, выражение &lt;code&gt;redName == redArgb&lt;/code&gt; вернёт нам &lt;code&gt;False&lt;/code&gt;. Неприятная ситуация может получится, если, например, исходный &lt;code&gt;Color.Red&lt;/code&gt; был сериализован в ARGB, затем десериализрован обратно, после чего вы вздумали сравнить итоговый цвет с оригиналом. Давайте почитаем, что &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.op_equality(v=vs.110).aspx&quot;&gt;пишут&lt;/a&gt; про оператор &lt;code&gt;==&lt;/code&gt; в &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.op_equality(v=vs.110).aspx&quot;&gt;MSDN&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method compares more than the ARGB values of the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color(v=vs.110).aspx&quot;&gt;Color&lt;/a&gt; structures. It also does a comparison of some state flags. If you want to compare just the ARGB values of two Color structures, compare them using the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.toargb(v=vs.110).aspx&quot;&gt;ToArgb&lt;/a&gt; method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ну, теперь всё понятно, для сравнения ARGB-значений наших цветов нам нужен метод &lt;code&gt;ToArgb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(redName.ToArgb() == redArgb.ToArgb()); // True
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Я думаю, не следует полагаться на догадки о логике работы стандартных методов сравнения, которые изначально могут показаться вам очевидными. Если вы пользуетесь оператором == или методом Equals для значимых типов, то неплохо было бы сначала заглянуть в документацию и проверить, что именно будет сравниваться.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Настраиваем конфигурации сборок в .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/msbuild-configurations/</link> 	
                <pubDate>Fri, 07 Feb 2014 19:16:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/msbuild-configurations/</guid>
                <description>&lt;p&gt;При создании нового проекта в Visual Studio по умолчанию вы получаете две конфигурации сборки: Debug и Release. И для большинства мелких проектов этого вполне достаточно. Но с ростом проекта может возникнуть потребность добавить дополнительные конфигурации. И хорошо, если нужно добавить одну-две новые конфигурации, а если их добрый десяток? А если при этом в солюшене находится штук 20 проектов, для каждого из которых эти конфигурации нужно настроить? В данном случае управлять параметрами сборки и модифицировать их становится достаточно сложно.&lt;/p&gt;
&lt;p&gt;В этом посте будет рассмотрен способ, с помощью которого вы сможете немного упростить себе жизнь, существенно сократив описание конфигураций сборок.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Откройте csproj-файл одного из ваших проектов, вы найдёте в нём строчки такого вида:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
  &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
  &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
  &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
  &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
  &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
  &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
  &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
  &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
  &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
  &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
  &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
  &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
  &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Первая проблема, которая стоит перед нами, состоит в том, что эти строчки дублируются (или практически дублируются) во всех проектах. К счастью, csproj-файлы поддерживают импорт конфигураций, так что создадим в корне солюшена файл &lt;code&gt;Configurations.targets&lt;/code&gt; следующего содержания:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После этого вы сможете заменить соответствующие строчки в исходном csproj-файле на&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Import Project=&amp;quot;..\Configurations.targets&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отлично, теперь дублирование описаний конфигураций ушло, можно сосредоточиться на редактировании единственного файла. Можно заметить, что в Debug и Release конфигурациях некоторые строчки всё ещё дублируются. Предполагается, что разработчик захочет настроить все эти параметры индивидуально для каждой конфигурации. Если такой потребности нет, то можно вынести дублирующиеся строчки в общую &lt;code&gt;PropertyGroup&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Можно ли ещё что-нибудь улучшить? Давайте подумаем. Глаз сразу цепляется за &lt;code&gt;OutputPath&lt;/code&gt;, который можно &#171;вычислить&#187; из названия конфигурации. При наличии двух конфигураций можно оставить для каждой индивидуальную настройку, но вот если конфигураций будет очень много, то здорово было бы сделать так, чтобы &lt;code&gt;OutputPath&lt;/code&gt;
выводился из названия конфигурации. Тут нам на помощь приходит переменная &lt;code&gt;$(Configuration)&lt;/code&gt;, с помощью которой это самое название можно узнать:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Замечательно, дублирование ушло. От чего ещё можно избавиться? Как правило, выставляемые свойства зависят только от конфигурации, изменение платформы ни на что не влияет. Давайте уберём лишнее условие:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)&#39; == &#39;Debug&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)&#39; == &#39;Release&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь добавим новых конфигураций. Положим, мы хотим ввести в наше приложение Demo-режим, в котором будут доступны не все функции. Demo-режим также может потребоваться отладить, поэтому разумно создать конфигурации &lt;code&gt;DebugDemo&lt;/code&gt; и &lt;code&gt;ReleaseDemo&lt;/code&gt;. А ещё, к примеру, мы хотим ввести режим сборки, при котором от пользователя будет требоваться лицензия. Demo-версию также может понадобится лицензировать, так что мы имеем ещё 4 конфигурации: &lt;code&gt;DebugLicense&lt;/code&gt;, &lt;code&gt;ReleaseLicense&lt;/code&gt;, &lt;code&gt;DebugDemoLicense&lt;/code&gt;, &lt;code&gt;ReleaseDemoLicense&lt;/code&gt; (данная ситуация приведена только для примера, в вашем проекте может быть всё иначе). &lt;code&gt;Demo&lt;/code&gt; и &lt;code&gt;License&lt;/code&gt; будут добавлять новые переменные в &lt;code&gt;DefineConstatns&lt;/code&gt;. Казалось бы, для 8 конфигураций нужно сделать 8 отдельных &lt;code&gt;PropertyGroup&lt;/code&gt;, но что-то внутри сознания сразу начинает протестовать. К счастью, в &lt;code&gt;Condition&lt;/code&gt; можно разместить более сложное условие, нежели простое сравнение. В данном примере будем искать заданную подстроку в названии конфигурации:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выглядит вполне неплохо. Но только образовалась проблема: Visual Studio теперь &#171;не видит&#187; список доступных конфигураций. Эту проблему можно решить, добавив пустых &lt;code&gt;PropertyGroup&lt;/code&gt; c таким же &lt;code&gt;Condition&lt;/code&gt; , как были вначале. При этом можно добавлять не все возможные конфигурации, а только те, которые вы реально будете использовать при работе. Например, мы не хотим отлаживать &lt;code&gt;Demo&lt;/code&gt; и &lt;code&gt;License&lt;/code&gt; конфигурации, тогда можно написать так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  

  &amp;lt;!-- Available --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemo|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemoLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если у вас есть врождённая ненависть к дублированию чего угодно, то в получившийся файл можно также вынести дополнительные свойства, которые дублируются во всех проектах. Например так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;Configuration Condition=&amp;quot; &#39;$(Configuration)&#39; == &#39;&#39; &amp;quot;&amp;gt;Release&amp;lt;/Configuration&amp;gt;
    &amp;lt;Platform Condition=&amp;quot; &#39;$(Platform)&#39; == &#39;&#39; &amp;quot;&amp;gt;AnyCPU&amp;lt;/Platform&amp;gt;    
    &amp;lt;TargetFrameworkVersion&amp;gt;v4.0&amp;lt;/TargetFrameworkVersion&amp;gt;
    &amp;lt;SolutionDir Condition=&amp;quot;$(SolutionDir) == &#39;&#39; Or $(SolutionDir) == &#39;*Undefined*&#39;&amp;quot;&amp;gt;..\&amp;lt;/SolutionDir&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  

  &amp;lt;!-- Available --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemo|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemoLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь точно всё дублирование ушло, а настраивать конфигурации стало легко и просто. Хочется отметить, что совершенно не обязательно данный подход подойдёт именно вам, многие проекты отлично пишутся и без правки конфигураций. А иногда каждую конфигурацию для каждого проекта и каждой платформы приходится настраивать вручную — в этом случае не особо получится сэкономить на удалении дублирования. Но если всё-таки возникла проблема с настройкой большого количества конфигураций для большого количество проектов, то, возможно, этот способ вам пригодится. Также будет полезно почитать справочные сведения о сборке в MSDN:&lt;/p&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/0k6kkbsd.aspx&quot;&gt;Справочные сведения о MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/ms164307.aspx&quot;&gt;Условные конструкции MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/7szfhaft.aspx&quot;&gt;Условия MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/dd633440.aspx&quot;&gt;Функции свойств&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/ms171459.aspx&quot;&gt;Использование переменных среды в построении&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/bb629394.aspx&quot;&gt;Общие свойства проектов MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/bb629388.aspx&quot;&gt;Общие элементы проектов MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Изменения в правилах защиты диссертаций от 1 января 2014</title>
                <link>http://aakinshin.net/ru/blog/education/government-decree-842/</link> 	
                <pubDate>Sun, 19 Jan 2014 13:41:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/education/government-decree-842/</guid>
                <description>&lt;p&gt;В нашей стране очень любят принимать разные новые законы. Вот, добрались и до защиты диссертаций: с 1-го января 2014 вступило в силу новое положение. В 2014-ом пройти по старым правилам могут только те, чьи диссертации были приняты к защите до 1-го января при условии, что защита пройдёт до 1-го июля 2014. Вокруг новых правил много шума: все говорят, что многое поменялось, но не все могут сказать, что именно. Давайте разберёмся.&lt;/p&gt;
&lt;p&gt;Было: &lt;a href=&quot;http://elementy.ru/library9/p74.htm&quot;&gt;Постановление Правительства РФ от 30 января 2002 г. № 74 &#171;Об утверждении Единого реестра ученых степеней и ученых званий и Положения о порядке присуждения ученых степеней&#187;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Стало: &lt;a href=&quot;http://government.ru/media/files/41d492460dd8923e356f.pdf&quot;&gt;Постановление Правительства РФ от 24 сентября 2013 г. № 842 &#171;О порядке присуждения ученых степеней&#187;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Новый документ достаточно большой (35 страниц, 86 пунктов), поэтому я решил сделать обзор наиболее важных изменений с ссылками на пункты постановлений.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Для сравнения старого и нового положения я буду обозначать соответствующие пункты положений как 74.a и 842.b. Итак, имеем:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.13)&lt;/strong&gt;
Повысилось количество необходимых публикаций в рецензируемых журналах. Для кандидата в области искусствоведения и культурологии, социально-экономических, общественных и гуманитарных наук — не менее 3, в остальных областях — не менее 2. Для доктора соответственно 15 и 10. Раньше (74.10) кандидатам наук нужно было иметь хотя бы одну публикацию, а для докторов этот вопрос не регламентировался.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.15)&lt;/strong&gt;
Диссертация предоставляется в совет только на правах рукописи. Раньше (74.8) разрешались также научные доклады и опубликованные монографии.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.17)&lt;/strong&gt;
Сделали отдельный пункт про госслужащих: &lt;em&gt;&#171;Соискателю ученой степени, являющемуся руководителем органа государственной власти или органа местного самоуправления, а также государственным (муниципальным) служащим, выполняющим работу, которая влечет за собой конфликт интересов, способных повлиять на принимаемые решения по вопросам государственной научной аттестации, запрещается представлять к защите диссертацию в диссертационные советы, созданные на базе организаций, находящихся в ведении этих органов.&#187;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.19)&lt;/strong&gt;
Решение диссертационного совета о приеме или об отказе в приеме диссертации к защите размещается на официальном сайте организации. В случае отказа из-за несоблюдения требований диссертация размещается на сайте на 10 лет с указанием причины отказа.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.20)&lt;/strong&gt;
Очень подробно расписаны основания для отказа в приёме к защите. Особенно хочется отметить пункт по борьбе с плагиатом: &lt;em&gt;&#171;использование в диссертации заимствованного материала без ссылки на автора и (или) источник заимствования, результатов научных работ, выполненных соискателем ученой степени в соавторстве, без ссылок на соавторов&#187;&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.22)&lt;/strong&gt;
Ужесточили требования к оппонентам по сравнению с пунктом 74.21: теперь оппонентами не могут быть &lt;em&gt;&#171;работники (в том числе работающие по совместительству) организаций, где выполнялась диссертация или работает соискатель ученой степени, его научный руководитель или научный консультант, а также где ведутся научно-исследовательские работы, по которым соискатель ученой степени является руководителем или работником организации-заказчика или исполнителем (соисполнителем). Оппоненты должны являться работниками разных организаций в случае осуществления ими трудовой деятельности&#187;.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.23)&lt;/strong&gt;
Отзывы оппонентов на диссертацию публикуются в интернете.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.24)&lt;/strong&gt;
Также ужесточаются требования к ведущей организации (по сравнению с 74.23): &lt;em&gt;&#171;Ведущей организацией не могут быть организации, в которых работают соискатель ученой степени, научные руководители (научные консультанты) соискателя ученой степени, а также организации, где ведутся научно-исследовательские работы, по которым соискатель ученой степени является руководителем или работником организации-заказчика или исполнителем (соисполнителем)&#187;.&lt;/em&gt; Отзыв ведущей организации также нужно публиковать в интернете.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.26)&lt;/strong&gt; Исходный текст диссертационной работы теперь также публикуется в интернете. Причём, публикация должна быть осуществлена для кандидата наук — минимум за 2 месяца, для доктора — минимум за 3 месяца. Это требование увеличивает и определяет минимальный срок до защиты, за который должен быть готов итоговый вариант текста диссертационной работы. Раньше у соискателей был месяц (за месяц до защиты нужно было опубликовать в интернете автореферат). Впрочем, история знает случаи, когда люди дописывали свои диссертации в последние дни перед защитой — теперь такой фокус не пройдёт.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.28)&lt;/strong&gt;
Все отзывы на автореферат и текст диссертационной работы также публикуются в интернете.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;842.65–77)&lt;/strong&gt;
Очень подробно расписана процедура лишения учёных степеней (раньше в пунктах 74.41–43 этот вопрос был освещён достаточно скудно). Если кратко, то теперь любое физическое или юридическое лицо может подать заявление о лишении учёной степени в течении 10 лет со дня защиты (против 3 лет в старом положении). Если человека всё-таки лишают учёной степени, то в интернете публикуется подробная информация о всех, кто был причастен к защите: о членах диссовета, научном руководителе, оппонентах и ведущей организации.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Как можно заметить, практически все нововведения направлены на борьбу с плагиатом: основной акцент сделан на гласность и увеличение ответственности за недобросовестные работы. Наверное, в чём-то это хорошо, но жизнь честных соискателей также усложниться. Наиболее значительными моментами являются увеличение срока до защиты, за который диссертация должна быть готова (2 месяца для кандидатов и 3 для докторов), и трудности в поисках оппонентов и ведущей организации.&lt;/p&gt;
&lt;p&gt;Для тех, кто собирается писать диссертацию по ГОСТ-у на LaTeX могу посоветовать специальный шаблон: &lt;a href=&quot;https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template&quot;&gt;Russian-Phd-LaTeX-Dissertation-Template&lt;/a&gt;.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Cache-Conscious Binary Search</title>
                <link>http://aakinshin.net/ru/blog/dotnet/cache-conscious-binary-search/</link> 	
                <pubDate>Wed, 20 Nov 2013 13:48:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/cache-conscious-binary-search/</guid>
                <description>&lt;p&gt;
	Рассмотрим простую задачу: есть некоторый достаточно большой неизменный набор чисел, к нему осуществляется множество запросов на наличие некоторого числа в этом наборе, необходимо максимально быстро эти запросы обрабатывать. Одно из классических решений заключается в формировании отсортированного массива и обработке запросов через бинарный поиск. Но можно ли добиться более высокой производительности, чем в классической реализации? В этой статье мне хотелось бы рассказать про Cache-Conscious Binary Search. В данном алгоритме предлагается переупорядочить элементы массива таким образом, чтобы использование кэша процессора происходило максимально эффективно.
&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt; &lt;b&gt;Дисклеймер:&lt;/b&gt;
	я не пытаюсь создать самое эффективное решение данной задачи. Мне хотелось бы просто обсудить подход к построению структур данных на основе учёта особенностей работы с кэшом процессора, т.к. многие при решении оптимизационных задач в принципе не задумываются о процессорной архитектуре. Я также не собираюсь писать идеальную реализацию Cache-Conscious Binary Search, мне хотелось бы посмотреть эффект от подобного подхода на достаточно простом примере (также в целях упрощения кода количество вершин берётся равным N=2^K-1). В качестве языка программирования я буду использовать C# (общее быстродействие для нас не принципиально, т.к. основной акцент делается не на создании самой быстрой программы в мире, а на относительном сравнении различных подходов к решению задачи). Стоит также отметить, что алгоритм эффективен только на больших массивах, поэтому не следует использовать данный подход во всех задачах, сперва нужно убедиться в его целесообразности. Предполагается, что у читателя имеются базовые представления о том, что такое кэш процессора, и как он работает.
&lt;/p&gt;
&lt;p&gt;
	Рассмотрим классическую реализацию бинарного поиска: пусть у нас имеется отсортированный массив
	&lt;code&gt;a&lt;/code&gt;
	и некоторый элемент
	&lt;code&gt;x&lt;/code&gt;
	, который мы будем в нём искать:
&lt;/p&gt;
&lt;pre class=&quot;prettyprint lang-cs&quot;&gt;&lt;br /&gt;public bool Contains(int x)&lt;br /&gt;{&lt;br /&gt;    int l = 0, r = N - 1;&lt;br /&gt;    while (l &amp;lt;= r)&lt;br /&gt;    {&lt;br /&gt;        int m = (l + r) / 2;&lt;br /&gt;        if (a[m] == x)&lt;br /&gt;            return true;&lt;br /&gt;        if (a[m] &gt; x)&lt;br /&gt;            r = m - 1;&lt;br /&gt;        else&lt;br /&gt;            l = m + 1;&lt;br /&gt;    }&lt;br /&gt;    return false;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;
	В данной реализации на первых итерациях алгоритма запросы будут осуществляться к элементам массива, которые находятся далеко друг от друга. Изобразим дерево поиска для массива из 15-и элементов:
&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://3.bp.blogspot.com/-lS77713GjIQ/Uoygymx31cI/AAAAAAAAAOw/o37c1lotLHo/s1600/img1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-lS77713GjIQ/Uoygymx31cI/AAAAAAAAAOw/o37c1lotLHo/s640/img1.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
	Из рисунка видно, что при проходе по такому дереву сперва будет обращение к 7-му элементу, а затем (в случае
	&lt;code&gt;a[7]!=x&lt;/code&gt;
	) к 3-ему или 11-ому. На таком маленьком массиве это не критично, но в большом массиве эти обращения будут соответствовать разным строчкам кэша процессора, что негативно скажется на производительности. Давайте попробуем переупорядочить элементы так, чтобы последовательные обращения к массиву приходились на близкие участки памяти. В первом приближении можно попробовать расположить друг за другом каждый уровень дерева с помощью простого поиска в ширину. На нашем тестовом дереве получим следующий результат:
&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://4.bp.blogspot.com/-7v_UqTv09FM/UoyhCIEiIII/AAAAAAAAAO0/EJmozES7E2w/s1600/img2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://4.bp.blogspot.com/-7v_UqTv09FM/UoyhCIEiIII/AAAAAAAAAO0/EJmozES7E2w/s640/img2.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
	Теперь элементы массива, к которым мы будем обращаться на первых итерациях, находятся недалеко друг от друга. Но с ростом номера итерации мы всё равно получим большое количество cache miss-ов. Чтобы исправить данную ситуацию, разобьём наше &#171;большое&#187; дерево бинарного поиска на небольшие поддеревья. Каждое такое поддерево будет соответствовать нескольким уровням оригинального дерева, а элементы поддерева будут находится недалеко друг от друга. Таким образом, cache miss будут образовываться в основном при переходе к очередному поддереву. Высоту поддерева можно варьировать, подбирая её в соответствии с процессорной архитектурой. Проиллюстрируем данные построения на нашем примере, взяв высоту поддерева равным 2:
&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://4.bp.blogspot.com/-w7UB4jgCGEQ/UoyhFYPW4YI/AAAAAAAAAO8/BUDzRYVmjCY/s1600/img3.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://4.bp.blogspot.com/-w7UB4jgCGEQ/UoyhFYPW4YI/AAAAAAAAAO8/BUDzRYVmjCY/s640/img3.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
	А теперь перейдём к практическим исследованиям. Для чистоты эксперимента и получения точных результатов будем замерять время с помощью проекта
	&lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;
	. Рассмотрим самую тривиальную реализацию рассмотренного алгоритма без каких-либо дополнительных оптимизаций (исходный код
	&lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/CacheConsciousBinarySearchCompetition.cs&quot;&gt;приведён&lt;/a&gt;
	на GitHub). Сравнивать будем классическую реализацию и cache-conscious-реализации с разными высотами поддеревьев (CacheConsciousSearchK соответствует поддереву с высотой K). Высоту дерева возьмём равной 24. На моей машине (Intel Core i7-3632QM CPU 2.20GHz) получились следующие результаты (алгоритм очень чувствителен к процессорной архитектуре, поэтому у вас могут получиться совсем другие временные оценки):
&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;br /&gt;// Microsoft.NET 4.5 x64&lt;br /&gt;SimpleSearch          : 6725ms&lt;br /&gt;CacheConsciousSearch1 : 4428ms&lt;br /&gt;CacheConsciousSearch2 : 3963ms&lt;br /&gt;CacheConsciousSearch3 : 3778ms&lt;br /&gt;CacheConsciousSearch4 : 3774ms&lt;br /&gt;CacheConsciousSearch5 : 3762ms&lt;br /&gt;&lt;/pre&gt;
&lt;div class=&quot;spoiler&quot; title=&quot;Исходный код бенчмарка&quot;&gt;
	&lt;pre class=&quot;prettyprint lang-cs&quot;&gt;&lt;br /&gt;public class CacheConsciousBinarySearchCompetition : BenchmarkCompetition&lt;br /&gt;{&lt;br /&gt;    private const int K = 24, N = (1 &amp;lt;&amp;lt; K) - 1, IterationCount = 10000000;&lt;br /&gt;    private readonly Random random = new Random();&lt;br /&gt;&lt;br /&gt;    private Tree originalTree;&lt;br /&gt;    private int[] bfs;&lt;br /&gt;&lt;br /&gt;    protected override void Prepare()&lt;br /&gt;    {&lt;br /&gt;        originalTree = new Tree(Enumerable.Range(0, N).Select(x =&amp;gt; 2 * x).ToArray());&lt;br /&gt;        bfs = originalTree.Bfs();&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void SimpleSearch()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(originalTree);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch1()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 1));&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch2()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 2));&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch3()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 3));&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch4()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 4));&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch5()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 5));&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;    private int SingleRun(ITree tree)&lt;br /&gt;    {&lt;br /&gt;        int searchedCount = 0;&lt;br /&gt;        for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)&lt;br /&gt;        {&lt;br /&gt;            int x = random.Next(N * 2);&lt;br /&gt;            if (tree.Contains(x))&lt;br /&gt;                searchedCount++;&lt;br /&gt;        }&lt;br /&gt;        return searchedCount;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    interface ITree&lt;br /&gt;    {&lt;br /&gt;        bool Contains(int x);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    class Tree : ITree&lt;br /&gt;    {&lt;br /&gt;        private readonly int[] a;&lt;br /&gt;&lt;br /&gt;        public Tree(int[] a)&lt;br /&gt;        {&lt;br /&gt;            this.a = a;&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        public bool Contains(int x)&lt;br /&gt;        {&lt;br /&gt;            int l = 0, r = N - 1;&lt;br /&gt;            while (l &amp;lt;= r)&lt;br /&gt;            {&lt;br /&gt;                int m = (l + r) / 2;&lt;br /&gt;                if (a[m] == x)&lt;br /&gt;                    return true;&lt;br /&gt;                if (a[m] &amp;gt; x)&lt;br /&gt;                    r = m - 1;&lt;br /&gt;                else&lt;br /&gt;                    l = m + 1;&lt;br /&gt;            }&lt;br /&gt;            return false;&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        public int[] Bfs()&lt;br /&gt;        {&lt;br /&gt;            int[] bfs = new int[N], l = new int[N], r = new int[N];&lt;br /&gt;            int tail = 0, head = 0;&lt;br /&gt;            l[head] = 0;&lt;br /&gt;            r[head++] = N - 1;&lt;br /&gt;            while (tail &amp;lt; head)&lt;br /&gt;            {&lt;br /&gt;                int m = (l[tail] + r[tail]) / 2;&lt;br /&gt;                bfs[tail] = a[m];&lt;br /&gt;                if (l[tail] &amp;lt; m)&lt;br /&gt;                {&lt;br /&gt;                    l[head] = l[tail];&lt;br /&gt;                    r[head++] = m - 1;&lt;br /&gt;                }&lt;br /&gt;                if (m &amp;lt; r[tail])&lt;br /&gt;                {&lt;br /&gt;                    l[head] = m + 1;&lt;br /&gt;                    r[head++] = r[tail];&lt;br /&gt;                }&lt;br /&gt;                tail++;&lt;br /&gt;            }&lt;br /&gt;            return bfs;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    class CacheConsciousTree : ITree&lt;br /&gt;    {&lt;br /&gt;        private readonly int[] a;&lt;br /&gt;        private readonly int level;&lt;br /&gt;&lt;br /&gt;        public CacheConsciousTree(int[] bfs, int level)&lt;br /&gt;        {&lt;br /&gt;            this.level = level;&lt;br /&gt;            int size = (1 &amp;lt;&amp;lt; level) - 1, counter = 0;&lt;br /&gt;            a = new int[N];&lt;br /&gt;            var was = new bool[N];&lt;br /&gt;            var queue = new int[size];&lt;br /&gt;            for (int i = 0; i &amp;lt; N; i++)&lt;br /&gt;                if (!was[i])&lt;br /&gt;                {&lt;br /&gt;                    int head = 0;&lt;br /&gt;                    queue[head++] = i;&lt;br /&gt;                    for (int tail = 0; tail &amp;lt; head; tail++)&lt;br /&gt;                    {&lt;br /&gt;                        a[counter++] = bfs[queue[tail]];&lt;br /&gt;                        was[queue[tail]] = true;&lt;br /&gt;                        if (queue[tail] * 2 + 1 &amp;lt; N &amp;amp;&amp;amp; head &amp;lt; size)&lt;br /&gt;                            queue[head++] = queue[tail] * 2 + 1;&lt;br /&gt;                        if (queue[tail] * 2 + 2 &amp;lt; N &amp;amp;&amp;amp; head &amp;lt; size)&lt;br /&gt;                            queue[head++] = queue[tail] * 2 + 2;&lt;br /&gt;                    }&lt;br /&gt;                }&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        public bool Contains(int x)&lt;br /&gt;        {&lt;br /&gt;            int u = 0, deep = 0, leafCount = 1 &amp;lt;&amp;lt; (level - 1);&lt;br /&gt;            int root = 0, rootOffset = 0;&lt;br /&gt;            while (deep &amp;lt; K)&lt;br /&gt;            {&lt;br /&gt;                int value = a[root + u];&lt;br /&gt;                if (value == x)&lt;br /&gt;                    return true;&lt;br /&gt;                if (++deep % level != 0)&lt;br /&gt;                {&lt;br /&gt;                    if (value &amp;gt; x)&lt;br /&gt;                        u = 2 * u + 1;&lt;br /&gt;                    else&lt;br /&gt;                        u = 2 * u + 2;&lt;br /&gt;                }&lt;br /&gt;                else&lt;br /&gt;                {&lt;br /&gt;                    int subTreeSize = (1 &amp;lt;&amp;lt; Math.Min(level, K - deep)) - 1;&lt;br /&gt;                    if (value &amp;gt; x)&lt;br /&gt;                        rootOffset = rootOffset * leafCount * 2 + (u - leafCount + 1) * 2;&lt;br /&gt;                    else&lt;br /&gt;                        rootOffset = rootOffset * leafCount * 2 + (u - leafCount + 1) * 2 + 1;&lt;br /&gt;                    root = (1 &amp;lt;&amp;lt; deep) - 1 + rootOffset * subTreeSize;&lt;br /&gt;                    u = 0;&lt;br /&gt;                }&lt;br /&gt;            }&lt;br /&gt;            return false;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
	На всякий случай я запустил бенчмарк под различными версиями .NET Framework и с различной битностью. Все конфигурации дали схожие результаты:
&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://3.bp.blogspot.com/-vup5W3aaqRg/UoyhK7lTPaI/AAAAAAAAAPE/JHDLACXG7Eg/s1600/ms.net.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-vup5W3aaqRg/UoyhK7lTPaI/AAAAAAAAAPE/JHDLACXG7Eg/s640/ms.net.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;Под Mono результаты также получились аналогичными:&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://2.bp.blogspot.com/-L8WX6UDHCA4/UoyhOjLKhvI/AAAAAAAAAPM/RBnImyRSQk0/s1600/mono.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://2.bp.blogspot.com/-L8WX6UDHCA4/UoyhOjLKhvI/AAAAAAAAAPM/RBnImyRSQk0/s640/mono.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
	Из этих картинок видно, что классическая реализация бинарного поиска значительно уступает Cache-Conscious-реализации. Стоит отметить, что по началу с ростом высоты поддеревьев быстродействие возрастает, но эта тенденция наблюдается недолго (поддеревья начинают приносить мало пользы, если внутри поддерева возникает большое количество cashe miss-ов).
&lt;/p&gt;
&lt;p&gt;
	Разумеется, Cache-Conscious Binary Search является лишь примером того, как можно адаптировать программу к особенностям работы кэша процессора. Подобные Cache-Conscious Data Structures могут оказать неоценимую помощь при оптимизации приложения, если ваши структуры данных имеют достаточно большой объём, а последовательные запросы к ним приходятся на разные участки памяти. Но не стоит бездумно бросаться переписывать всё под Cache-Conscious: помните, что код станет намного сложнее, а повышение эффективности в значительной степени зависит от используемой процессорной архитектуры. В реальной жизни лучше сперва подумать о выборе наиболее оптимальных алгоритмов с хорошей асимптотикой, различных предподсчётах, эвристиках и т.п., а Cache-Conscious приберечь на времена, когда всё станет совсем плохо.
&lt;/p&gt;
&lt;p&gt;
	Дополнение от Хабраюзера
	&lt;a href=&quot;http://habrahabr.ru/users/MikeMirzayanov/&quot;&gt;MikeMirzayanov&lt;/a&gt;
	: Есть такой трюк. Если надо бинпоиском поискать в массиве длине n, то можно разбить его на sqrt(n) блоков по sqrt(n) элементов. Затем бинпоиском за log(sqrt(n)) подыскать нужный блок и в нём вторым бинпоиском за log(sqrt(n)) найти элемент. В сумме получается всё тот же log(n), но попаданий в кэш значительно больше, т.к. каждый раз ищем на довольно коротком массиве длины sqrt(n).
&lt;/p&gt;
&lt;p&gt;Быстрых вам приложений!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Также можно почитать по теме:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://www.vldb.org/conf/1999/P7.pdf&quot;&gt;Cache Conscious Indexing for Decision-Support in Main Memory&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/trishulc/papers/ccds.pdf&quot;&gt;Cache-Conscious Data Structures&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://mspiegel.github.io/publications/michael-spiegel-dissertation.pdf&quot;&gt;Cache-Conscious Concurrent Data Structures&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://ftp.cse.buffalo.edu/users/azhang/disc/disc01/cd1/out/papers/sigmod/p475-rao/p475-rao.pdf&quot;&gt;Making B+-Trees Cache Conscious in Main Memory&lt;/a&gt;
	&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Переписываем список коммитеров в Git</title>
                <link>http://aakinshin.net/ru/blog/git/rewrite-commiter-list/</link> 	
                <pubDate>Sun, 10 Nov 2013 14:13:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/git/rewrite-commiter-list/</guid>
                <description>&lt;p&gt;Иногда возникает потребность переписать коммитеров в Git-репозитории. Задача достаточно редкая, но иногда всё-таки приходится ей заниматься. Давайте разберёмся в ситуации подробней. Прежде всего, взглянем на текущий список коммитеров:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&amp;quot;%an &amp;lt;%aE&amp;gt;&amp;quot; | sort -u
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Допустим, мы получили следующий список:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ivan &amp;lt;ivan@@gmail.com&amp;gt;
Ivan &amp;lt;ivan.ivanov@@gmail.com&amp;gt;
Ivan &amp;lt;ivan-ivan@@gmail.com&amp;gt;
Ivan Ivanov &amp;lt;ivan.ivanov@@gmail.com&amp;gt;
Vanya Ivanov &amp;lt;ivan.ivanov@@gmail.com&amp;gt;
Vanya &amp;lt;ivan.ivanov@@gmail.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Наблюдаем следующую проблему: некий Иван Иванов делал коммиты, указывая каждый раз разную информацию об имени пользователя и почтовом адресе. Для начала нужно дать по рукам Ивану и сказать, чтобы больше так не делал. Лучше всего использовать для всех коммитов одинаковую учётную информацию (например,
&lt;code&gt;Ivan Ivanov &amp;amp;lt;ivan.ivanov@@gmail.com&amp;amp;gt;&lt;/code&gt;). Проблема может встать особенно остро, если в проекте используются дополнительные сервисы, которые работают с репозиторием (code review system, build server и т.п.). Ну, а пока Иван размышляет над своим поведением, мы займёмся переписыванием истории.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;На текущий момент в репозитории имеется ряд коммитеров с именем &lt;code&gt;Ivan&lt;/code&gt; . Давайте их все объединим! А поможет нам в этом замечательная команда &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-filter-branch.html&quot;&gt;git filter-branch&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git filter-branch --commit-filter &#39;
        if [ &amp;quot;$GIT_AUTHOR_NAME&amp;quot; = &amp;quot;Ivan&amp;quot; ];
        then
                GIT_AUTHOR_NAME=&amp;quot;Ivan Ivanov&amp;quot;;
                GIT_AUTHOR_EMAIL=&amp;quot;ivan.ivanov@@gmail.com&amp;quot;;
                git commit-tree &amp;quot;$@@&amp;quot;;
        else
                git commit-tree &amp;quot;$@@&amp;quot;;
        fi&#39; HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь все Иваны ушли из нашего репозитория, список коммитеров выглядит следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ivan Ivanov &amp;lt;ivan.ivanov@@gmail.com&amp;gt;
Vanya Ivanov &amp;lt;ivan.ivanov@@gmail.com&amp;gt;
Vanya &amp;lt;ivan.ivanov@@gmail.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После перезаписи истории git сохраняет оригинальные указатели на ветки в &lt;code&gt;.git/refs/original&lt;/code&gt; . Для выполнения следующей перезаписи истории (давайте объединим пользователей по почтовому адресу) нам необходимо либо удалить эту папку, либо выполнить команду с ключом &lt;code&gt;-f&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git filter-branch -f --commit-filter &#39;
        if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;ivan.ivanov@@gmail.com&amp;quot; ];
        then
                GIT_AUTHOR_NAME=&amp;quot;Ivan Ivanov&amp;quot;;
                GIT_AUTHOR_EMAIL=&amp;quot;ivan.ivanov@@gmail.com&amp;quot;;
                git commit-tree &amp;quot;$@@&amp;quot;;
        else
                git commit-tree &amp;quot;$@@&amp;quot;;
        fi&#39; HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ура! У нас остался единственный коммитер:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ivan Ivanov &amp;lt;ivan.ivanov@@gmail.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Проверив правильность изменений, можно с чистой совестью удалить папку &lt;code&gt;.git/refs/original&lt;/code&gt; с бэкапом данных. После этого в репозитории будет находится много мусора. Не помешает явно избавиться от него c помощью &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-gc.html&quot;&gt;git gc&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git gc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Далее наступает ответственный этап: отправка изменённой истории на сервер:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git push --all -f origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После этого можно порекомендовать вашим коллегам по репозиторию снести свою локальную копию и скачать все данные с нуля (думаю, это наиболее безболезненный способ перехода на новое дерево коммитов).&lt;/p&gt;
&lt;h3&gt;Важно!&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Помните, что коммиты содержат SHA-1 своих родителей, поэтому будут переписаны SHA-1 не только целевых коммитов, но и всех их потомков. Соответственно, если была привязка сторонних сервисов к коммитам вашего репозитория по SHA-1, то она &#171;погибнет&#187; после перезаписи истории. Да и остальные разработчики в вашей команде будут безмерно удивлены полностью переписанной истории на сервере. Поэтому не используйте перезапись истории на сервере, если у вас нет действительно веских причин для этого.&lt;/li&gt;
&lt;li&gt;Процесс перезаписи истории быстрым не назовёшь, время работы прямо пропорционально общему количеству коммитов. Если ваш репозиторий достаточно большой, то придётся запастись терпением.&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Jon Skeet&#39;s Quiz</title>
                <link>http://aakinshin.net/ru/blog/dotnet/jon-skeet-quiz/</link> 	
                <pubDate>Sun, 03 Nov 2013 08:07:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/jon-skeet-quiz/</guid>
                <description>&lt;p&gt;Однажды Джона Скита попросили сформулировать три интересных вопроса на знание C#. Он спросил следующее (&lt;a href=&quot;http://www.dotnetcurry.com/magazine/jon-skeet-quiz.aspx&quot;&gt;оригинал вопросника&lt;/a&gt;, &lt;a href=&quot;http://timyrguev.blogspot.ru/2013/10/blog-post.html&quot;&gt;перевод статьи&lt;/a&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q1.&lt;/strong&gt; &lt;em&gt;Вызов какого конструктора можно использовать, чтобы следующий код вывел True (хотя бы в реализации Microsoft.NET)?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new /* fill in code here */;
object y = new /* fill in code here */;
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Учтите, что это просто вызов конструктора, вы не можете поменять тип переменных.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q2.&lt;/strong&gt; &lt;em&gt;Как сделать так, чтобы следующий код вызывал три различных перегрузки метода?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;void Foo()
{
    EvilMethod&amp;lt;string&amp;gt;();
    EvilMethod&amp;lt;int&amp;gt;();
    EvilMethod&amp;lt;int?&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q3.&lt;/strong&gt; &lt;em&gt;Как заставить следующий код выбросить исключение во второй строчке с помощью локальной переменной (без хитрого изменения её значения)?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;string text = x.ToString(); // No exception
Type type = x.GetType(); // Bang!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вопросы показались мне интересными, поэтому я решил обсудить их решения.&lt;!--more--&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A1-1.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Одним из самых простых способ является использование &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/1t3y8s4s(v=vs.90).aspx&quot;&gt;Nullable&lt;/a&gt;-типов:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new int?();
object y = new int?();
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Несмотря на явный вызов конструктора, получившиеся значения равны &lt;code&gt;null&lt;/code&gt;, а следовательно совпадают.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A1-2.&lt;/strong&gt; Или можно вспомнить про &lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2009/09/28/string-interning-and-string-empty.aspx&quot;&gt;интернирование строк&lt;/a&gt; и объявить две пустые строчки:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new string(new char[0]);
object y = new string(new char[0]);
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A2.&lt;/strong&gt; Вторая задачка — самая сложная из трёх предложенных. Необходимо придумать такое решение, чтобы запускались именно три &lt;em&gt;разных&lt;/em&gt; перегрузки нашего метода. В качестве варианта решения можно рассмотреть следующий код:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ReferenceGeneric&amp;lt;T&amp;gt; where T : class { }

public class EvilClassBase
{
  protected void EvilMethod&amp;lt;T&amp;gt;()
  {
    Console.WriteLine(&amp;quot;int?&amp;quot;);
  }
}

public class EvilClass : EvilClassBase
{
  public void Run()
  {
    EvilMethod&amp;lt;string&amp;gt;();
    EvilMethod&amp;lt;int&amp;gt;();
    EvilMethod&amp;lt;int?&amp;gt;();
  }

  private void EvilMethod&amp;lt;T&amp;gt;(ReferenceGeneric&amp;lt;T&amp;gt; arg = null) where T : class
  {
    Console.WriteLine(&amp;quot;string&amp;quot;);
  }

  private void EvilMethod&amp;lt;T&amp;gt;(T? arg = null) where T : struct
  {
    Console.WriteLine(&amp;quot;int&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для начала разберёмся с типам &lt;code&gt;string&lt;/code&gt; и &lt;code&gt;int&lt;/code&gt;. Тут всё просто: &lt;code&gt;string&lt;/code&gt; является ссылочным типом, а &lt;code&gt;int&lt;/code&gt; — значимым. При написании кода нам помогут конструкции &lt;code&gt;where T : class&lt;/code&gt;, &lt;code&gt;where T : struct&lt;/code&gt; и параметры по умолчанию, которые явно задействуют тип &lt;code&gt;T&lt;/code&gt; соответствующим образом: в первый метод пойдёт аргумент типа &lt;code&gt;ReferenceGeneric&amp;lt;T&amp;gt;&lt;/code&gt; (он может принимать только ссылочные типы), а во второй — &lt;code&gt;T?&lt;/code&gt; (он может принимать только значимые non-nullable типы). Теперь вызовы &lt;code&gt;EvilMethod&amp;lt;string&amp;gt;()&lt;/code&gt; и &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;()&lt;/code&gt; &#171;найдут&#187; себе правильные перегрузки.&lt;/p&gt;
&lt;p&gt;Едем дальше, вспомним про &lt;code&gt;int?&lt;/code&gt;. Для него создадим перегрузку с сигнатурой без всяких дополнительных условий &lt;code&gt;EvilMethod&amp;lt;T&amp;gt;()&lt;/code&gt; (увы, C# не позволяет написать что-нибудь вроде &lt;code&gt;where T : Nullable&amp;lt;int&amp;gt;&lt;/code&gt;). Но если мы объявим такой метод в том же классе, то он &#171;заберёт&#187; себе вызовы первых двух методов. Поэтому следует &#171;отправить&#187; его в базовый класс, там он нам мешать не будет.&lt;/p&gt;
&lt;p&gt;Давайте взглянем на то, что получилось. Вызовы &lt;code&gt;EvilMethod&amp;lt;string&amp;gt;()&lt;/code&gt; и &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;()&lt;/code&gt; &#171;увидят&#187; подходящие перегрузки в текущем классе и будут их использовать. Вызов &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;;()&lt;/code&gt; подходящей перегрузки в текущем классе &#171;не найдёт&#187;, поэтому &#171;пойдёт&#187; за ней в базовый класс. Сила &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa691336%28v=vs.71%29.aspx&quot;&gt;C# Overload resolution rules&lt;/a&gt; опять помогла нам!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A3.&lt;/strong&gt; И снова Nullable-типы спешат на помощь!&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var x = new int?();
string text = x.ToString(); // No exception
Type type = x.GetType(); // Bang!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9hd15ket.aspx&quot;&gt;Вспомним&lt;/a&gt;, что метод &lt;code&gt;ToString()&lt;/code&gt; перегружен в &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, для null-значения он вернёт пустую строчку. Увы, для &lt;code&gt;GetType()&lt;/code&gt; такой фокус не пройдёт, он не может быть перегружен и на null-значении выбросит исключение. Также вы &lt;a href=&quot;http://stackoverflow.com/questions/12725631/nullable-type-gettype-throws-exception&quot;&gt;можете почитать&lt;/a&gt; оригинальный ответ Джона на свой вопрос.&lt;/p&gt;
&lt;p&gt;Не забываем, что при очень большом желании через неуправляемый код мы всегда можем долезть до таблицы методов и ручками подменить ссылку на &lt;code&gt;GetType()&lt;/code&gt;, но сегодня нас просили не хитрить =).&lt;/p&gt;</description>
            </item>
            <item>
                <title>Внутреннее устройство массивов в .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/arrays-internal-structure/</link> 	
                <pubDate>Fri, 11 Oct 2013 14:56:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/arrays-internal-structure/</guid>
                <description>&lt;p&gt;Иногда бывает полезно понимать, как выглядит внутреннее представление объектов, с которыми мы работаем. В этой статье я хотел бы поговорить о массивах: как именно они хранятся в памяти, какие IL-команды используются для работы с ними, как выглядит ассемблерный код при обращении к их элементам. Я рассмотрю три вида массивов: single (&lt;code&gt;T[]&lt;/code&gt;), rectangular (&lt;code&gt;T[,]&lt;/code&gt;), jagged (&lt;code&gt;T[][]&lt;/code&gt;). Также будет затронута тема массивов с ненулевой нижней границей (&lt;code&gt;T[*]&lt;/code&gt;) и нюансов работы с ними.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;При рассмотрении низкоуровневых данных (например, дампов памяти) следует понимать, что адреса различных объектов будут меняться от одного запуска программы к запуску. В примерах нас больше будет интересовать относительное размещение объектов. В качестве целевой архитектуры взята
&lt;code&gt;x86&lt;/code&gt;
. Для удобства восприятия многие данные переведены из родной шестнадцатеричной формы в десятичную (за исключением адресов, они начинаются с префикса
&lt;code&gt;0x&lt;/code&gt;
). Данная статья не претендует на фундаментальное описание внутреннего представления массивов, скорее это просто краткий обзор организации различных массивов на низком уровне. В качестве реализации платформы рассматривается стандартная MS.NET, Mono обсуждать не будем.&lt;/p&gt;
&lt;h3&gt;Single array&lt;/h3&gt;
&lt;p&gt;Такие массивы часто называются также &lt;em&gt;SZ-массивами&lt;/em&gt; (single-dimensional, zero-based) или &lt;em&gt;векторами&lt;/em&gt;. Создадим обычный &lt;code&gt;int[]&lt;/code&gt;-массив (каждый элемент занимает 4 байта) длинной 5 элементов, который заполним числами от 0 до 4:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int[] a = new int[5];
for (int i = 0; i &amp;lt; 5; i++)
    a[i] = i;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В памяти он будет представлен следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x03022424           0  // SyncBlockIndex
0x03022428  0x61B9C448  // *MethodTable
0x0302242C           5  // a.Length
0x03022430           0  // a[0]
0x03022434           1  // a[1]
0x03022438           2  // a[2]
0x0302243C           3  // a[3]
0x03022440           4  // a[4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Воспользуемся расширением отладчика &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/bb190764.aspx&quot;&gt;SOS&lt;/a&gt; и через Immediate Window посмотрим чуть больше информации о нашем массиве:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.load sos.dll
!DumpArray 0x03022428
Name:        System.Int32[]
MethodTable: 61b9c448
EEClass:     6180c0d0
Size:        32(0x20) bytes
Array:       Rank 1, Number of elements 5, Type Int32
Element Methodtable: 61b9c480
[0] 03022430
[1] 03022434
[2] 03022438
[3] 0302243c
[4] 03022440
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут всё достаточно просто. Переменная &lt;code&gt;a&lt;/code&gt; указывает на адрес &lt;code&gt;0x03022428&lt;/code&gt;, по которому хранится указатель на таблицу методов соответствующего типа (в данном случае
&lt;code&gt;System.Int32[]&lt;/code&gt;), которая занимает 4 байта (для &lt;code&gt;x64&lt;/code&gt; — 8 байт). Перед ней находится SyncBlockIndex (отсчитывается от 1, 0 означает пустое значение; размер под
&lt;code&gt;x86&lt;/code&gt; — 4 байта, под &lt;code&gt;x64&lt;/code&gt; — 8 байт). После &lt;code&gt;*MethodTable&lt;/code&gt; идёт сначала размер массива, а затем по порядку все его элементы.&lt;/p&gt;
&lt;p&gt;Для операций с SZ-массивами предусмотрены следующие IL-команды:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newarr &amp;lt;etype&amp;gt;&lt;/code&gt; : создание нового массива с элементами типа etype&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldelem &amp;lt;typeTok&amp;gt;&lt;/code&gt;: добавить значение элемента по заданному индексу в стек&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldelema &amp;lt;class&amp;gt;&lt;/code&gt;: добавить адрес элемента по заданному индексу в стек&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldlen&lt;/code&gt;: добавить длину массива в стек&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stelem &amp;lt;typeTok&amp;gt;&lt;/code&gt;: заменить значение элемента по заданному индексу значением из стека&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Обращение к элементу на уровне ассемблера имеет примерно следующий вид: &lt;code&gt;[ebx+ecx*4+8]&lt;/code&gt;. Здесь &lt;code&gt;ebx&lt;/code&gt; обозначает базовый адрес массива, &lt;code&gt;ecx&lt;/code&gt; — индекс элемента (он умножается на 4, т.к. Int32 занимает в памяти 4 байта), &lt;code&gt;8&lt;/code&gt; — смещение для нулевого элемента (пропускаем MethodTable и количество элементов массива, т.е. два значения по 4 байта).&lt;/p&gt;
&lt;h3&gt;Rectangular array&lt;/h3&gt;
&lt;p&gt;Создадим двумерный массив&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int[,] a = new int[2, 3];
for (int i = 0; i &amp;lt; 2; i++)
    for (int j = 0; j &amp;lt; 3; j++)
        a[i, j] = i * 3 + j;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и по аналогии взглянем на дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x03022444           0  // SyncBlockIndex
0x03022448  0x61B5E938  // *MethodTable
0x0302244C           6  // a.Length
0x03022450           2  // a.GetLength(0)
0x03022454           3  // a.GetLength(1)
0x03022458           0  // a.GetLowerBound(0)
0x0302245C           0  // a.GetLowerBound(1)
0x03022460           0  // a[0, 0]
0x03022464           1  // a[0, 1]
0x03022468           2  // a[0, 2]
0x0302246C           3  // a[1, 0]
0x03022470           4  // a[1, 1]
0x03022474           5  // a[1, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;!DumpArray 0x03022448
Name:        System.Int32[,]
MethodTable: 61b5e938
EEClass:     617fd0c4
Size:        52(0x34) bytes
Array:       Rank 2, Number of elements 6, Type Int32
Element Methodtable: 61b9c480
[0][0] 03022460
[0][1] 03022464
[0][2] 03022468
[1][0] 0302246c
[1][1] 03022470
[1][2] 03022474
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Структура немного усложнилась. Сперва (как и в первом случае), идут &lt;code&gt;SyncBlockIndex&lt;/code&gt; и &lt;code&gt;*MethodTable&lt;/code&gt; (&lt;code&gt;a&lt;/code&gt; указывает именно на *MethodTable, т.е. на &lt;code&gt;0x03022448&lt;/code&gt;). Далее точно также идёт длина массива, т.е. общее количество элементов, которые в нём содержатся. А после этого идут отличительные данные для rectangular-массива: длины по каждому измерению и нижние границы (их мы подробнее обсудим чуть позже, по умолчанию они равны нулю). Количество измерений массива (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.array.rank.aspx&quot;&gt;a.Rank&lt;/a&gt;) можно узнать из типа (&lt;code&gt;System.Int32[,]&lt;/code&gt;). Далее идут непосредственно сами элементы.&lt;/p&gt;
&lt;p&gt;Для работы с элементами rectangular-массива на IL-уровне нет специальных команд, приходится вызывать методы &lt;code&gt;Get&lt;/code&gt; и &lt;code&gt;Set&lt;/code&gt;. На уровне ассемблера для двумерного массива мы будем иметь инструкцию вида &lt;code&gt;[ebx+ecx*4+18h]&lt;/code&gt;. &lt;code&gt;ebx&lt;/code&gt; — базовый адрес массива, &lt;code&gt;ecx&lt;/code&gt; — номер элемента (который высчитывается на основе индексов i, j), &lt;code&gt;18h&lt;/code&gt;
— смещение (больше, чем в &lt;code&gt;single&lt;/code&gt;-версии, т.к. теперь нам нужно пропустить больше служебных значений: &lt;code&gt;18h=24=6*4&lt;/code&gt; — &lt;code&gt;TypeHandle&lt;/code&gt;, &lt;code&gt;a.Length&lt;/code&gt;, &lt;code&gt;a.GetLength(0)&lt;/code&gt;, &lt;code&gt;a.GetLength(1)&lt;/code&gt;, &lt;code&gt;a.GetLowerBound(0)&lt;/code&gt;, &lt;code&gt;a.GetLowerBound(1))&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Jagged array&lt;/h3&gt;
&lt;p&gt;Создадим двумерный изломанный массив&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int[][] a = new int[2][];
for (int i = 0; i &amp;lt; 2; i++)
{
    a[i] = new int[3];
    for (int j = 0; j &amp;lt; 3; j++)
        a[i][j] = i * 3 + j;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и по аналогии взглянем на дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x03022478           0  // SyncBlockIndex (a)
0x0302247C  0x61B8D5BC  // *MethodTable (a)
0x03022480           2  // a.Length
0x03022484  0x617A4C8A  // *TypeDesc (int[])
0x03022488  0x03022494  // a[0]
0x0302248C  0x030224AC  // a[1]
0x03022490           0  // SyncBlockIndex (a[0])
0x03022494  0x61B9C448  // *MethodTable (a[0])
0x03022498           3  // a[0].Length
0x0302249C           0  // a[0][0]
0x030224A0           1  // a[0][1]
0x030224A4           2  // a[0][2]
0x030224A8           0  // SyncBlockIndex (a[1])
0x030224AC  0x61B9C448  // *MethodTable (a[1])
0x030224B0           3  // a[1].Length
0x030224B4           3  // a[1][0]
0x030224B8           4  // a[1][1]
0x030224BC           5  // a[1][2]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;!DumpArray 0x0302247C
Name:        System.Int32[]
MethodTable: 61b8d5bc
EEClass:     618ab450
Size:        24(0x18) bytes
Array:       Rank 1, Number of elements 2, Type SZARRAY
Element Methodtable: 617a4c8a
[0] 03022494
[1] 030224ac

!DumpObj 0x0302247C
Name:        System.Int32[][]
MethodTable: 61b8d5bc
EEClass:     618ab450
Size:        24(0x18) bytes
Array:       Rank 1, Number of elements 2, Type SZARRAY
Fields:
None

!DumpArray 0x03022494
Name:        System.Int32[]
MethodTable: 61b9c448
EEClass:     6180c0d0
Size:        24(0x18) bytes
Array:       Rank 1, Number of elements 3, Type Int32
Element Methodtable: 61b9c480
[0] 0302249c
[1] 030224a0
[2] 030224a4

!DumpArray 0x030224AC
Name:        System.Int32[]
MethodTable: 61b9c448
EEClass:     6180c0d0
Size:        24(0x18) bytes
Array:       Rank 1, Number of elements 3, Type Int32
Element Methodtable: 61b9c480
[0] 030224b4
[1] 030224b8
[2] 030224bc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;По сути &lt;code&gt;int[][]&lt;/code&gt; представляет собой массив массивов. Т.е. это одномерный массив, элементами которого являются ссылки на другие массивы. Команда &lt;code&gt;DumpArray&lt;/code&gt;
не может нормально восстановить тип объекта, для этой цели необходимо пользоваться командой &lt;code&gt;DumpObj&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Методы по работе с jagged-массивом на IL и ASM уровнях аналогичны single-массиву с той лишь разницей, что теперь нам необходимо перейти к нужному элементу одномерного массива не один раз, а несколько (в зависимости от количества размерностей). По адресу &lt;code&gt;0x03022484&lt;/code&gt; находится указатель на TypeDesc для &lt;code&gt;int[]&lt;/code&gt; (&lt;a href=&quot;a%20href=%22http://aakinshin.blogspot.ru/2013/09/dotnet-typehandle.html%22&quot;&gt;a href=&amp;quot;http://aakinshin.blogspot.ru/2013/09/dotnet-typehandle.html&amp;quot;&lt;/a&gt;тут&lt;/a&gt; можно почитать подробнее).&lt;/p&gt;
&lt;h3&gt;Non-zero based single array&lt;/h3&gt;
&lt;p&gt;Явно объявить одномерный массив с ненулевой нижней границей нельзя, для этого нам понадобится метод &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.array.createinstance.aspx&quot;&gt;Array.CreateInstance&lt;/a&gt;, в который передаётся тип элементов, массив длин и массив нижних границ. Создадим элемент из 5-ти элементов с нижней границей 2:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Array a = Array.CreateInstance(typeof(int), new[] { 5 }, new[] { 2 });
for (int i = 2; i &amp;lt; 7; i++)
    a.SetValue(i, i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Взглянем на соответствующий дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x030224FC           0  // SyncBlockIndex
0x03022500  1639311728  // *MethodTable
0x03022504           5  // a.Length
0x03022508           5  // a.GetLength(0)
0x0302250C           2  // a.GetLowerBound(0)
0x03022510           2  // a[2]
0x03022514           3  // a[3]
0x03022518           4  // a[4]
0x0302251C           5  // a[5]
0x03022520           6  // a[6]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;!DumpArray 0x03022500
Name:        System.Int32[]
MethodTable: 61b5e970
EEClass:     617fd110
Size:        40(0x28) bytes
Array:       Rank 1, Number of elements 5, Type Int32
Element Methodtable: 61b9c480
[0] 03022508
[1] 0302250c
[2] 03022510
[3] 03022514
[4] 03022518
[5] 0302251c
[6] 03022520

!DumpObj 0x03022500
Name:        System.Int32[*]
MethodTable: 61b5e970
EEClass:     617fd110
Size:        40(0x28) bytes
Array:       Rank 1, Number of elements 5, Type Int32
Fields:
None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тип данного объекта: &lt;code&gt;System.Int32[*]&lt;/code&gt;. Знак &lt;code&gt;*&lt;/code&gt; означает, что CLR знает о ненулевой нижней границе. Синтаксис C# не позволяет явно объявить переменную такого типа, также запрещается явное обращение к его элементам посредствам стандартного синтаксиса, поэтому приходится пользоваться методами &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.array.getvalue.aspx&quot;&gt;GetValue&lt;/a&gt; и &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.array.setvalue.aspx&quot;&gt;SetValue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Обратите внимание, что команда &lt;code&gt;DumpArray&lt;/code&gt; не умеет корректно отображать тип одномерного массива с ненулевой нижней границей. Правильный тип можно получить, используя команду &lt;code&gt;DumpObj&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Что касается структуры массива в памяти, то она полностью аналогична структуре rectangular-массива. Для доступа к элементам массива специальных IL-команд не предусмотрено, приходится вновь явно вызывать методы.&lt;/p&gt;
&lt;h3&gt;Non-zero based rectangular array&lt;/h3&gt;
&lt;p&gt;А теперь создадим двумерный массив 2 на 3 с нижними границами 4 и 5. Поможет нам в этом уже знакомый метод &lt;code&gt;Array.CreateInstance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Array a = Array.CreateInstance(typeof(int), new[] { 2, 3 }, new[] { 4, 5 });
for (int i = 4; i &amp;lt; 6; i++)
    for (int j = 5; j &amp;lt; 8; j++)
        a.SetValue(i * 3 + j - 17, i, j);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x03022588           0  // SyncBlockIndex
0x0302258C  1639311672  // *MethodTable
0x03022590           6  // a.Legnth
0x03022594           2  // a.GetLength(0)
0x03022598           3  // a.GetLength(1)
0x0302259C           4  // a.GetLowerBound(0)
0x030225A0           5  // a.GetLowerBound(1)
0x030225A4           0  // a[4, 5]
0x030225A8           1  // a[4, 6]
0x030225AC           2  // a[4, 7]
0x030225B0           3  // a[5, 5]
0x030225B4           4  // a[5, 6]
0x030225B8           5  // a[5, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;!DumpArray 0x0302258C
Name:        System.Int32[,]
MethodTable: 61b5e938
EEClass:     617fd0c4
Size:        52(0x34) bytes
Array:       Rank 2, Number of elements 6, Type Int32
Element Methodtable: 61b9c480
[4][5] 030225a4
[4][6] 030225a8
[4][7] 030225ac
[5][5] 030225b0
[5][6] 030225b4
[5][7] 030225b8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Заметим, что для rectangular-массивов с ненулевой нижней границей команда &lt;code&gt;DumpArray&lt;/code&gt; прекрасно работает. Несложно понять, что структура хранения и организации rectangular-массива не зависит от нижней границы: представление в памяти всегда будет одинаковое, тип всегда будет &lt;code&gt;System.Int32[,]&lt;/code&gt;, IL и ASM инструкции будут аналогичны.&lt;/p&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Общее устройство массива выглядит следующим образом:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SyncBlockIndex&lt;/code&gt; (по отрицательному смещению)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*MethodTable&lt;/code&gt; (по нулевому смещению)&lt;/li&gt;
&lt;li&gt;Общая длина массива&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*TypeDesc&lt;/code&gt; для элементов массива (только для массивов из элементов ссылочного типа; &lt;code&gt;int[][]&lt;/code&gt; является частным случаем, т.к. это массив из &lt;code&gt;int[]&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Длины по каждому измерению массива (только для одномерных массивов с заданной нижней границей и многомерных массивов)&lt;/li&gt;
&lt;li&gt;Нижние индексы по каждому измерению массива (только для одномерных массивов с заданной нижней границей и многомерных массивов)&lt;/li&gt;
&lt;li&gt;Элементы массива&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Учимся округлять в C#</title>
                <link>http://aakinshin.net/ru/blog/dotnet/cheatsheet-rounding/</link> 	
                <pubDate>Wed, 18 Sep 2013 02:18:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/cheatsheet-rounding/</guid>
                <description>&lt;p&gt;А знаете ли вы, что &lt;code&gt;Math.Round(1.5) == Math.Round(2.5) == 2&lt;/code&gt;? Можете ли сходу сказать, сколько будет &lt;code&gt;-7%3&lt;/code&gt; и &lt;code&gt;7%-3&lt;/code&gt;? Помните ли, чем отличаются
&lt;code&gt;Math.Round&lt;/code&gt;, &lt;code&gt;Math.Floor&lt;/code&gt;, &lt;code&gt;Math.Ceiling&lt;/code&gt;, &lt;code&gt;Math.Truncate&lt;/code&gt;? А как происходит округление при использовании &lt;code&gt;string.Format&lt;/code&gt;? Давайте немного погрузимся в мир округлений и разберёмся с нюансами, которые не для всех могут быть очевидными.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;Math.Round&lt;/h3&gt;
&lt;p&gt;MSDN:
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.math.round.aspx&quot;&gt;Round&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static decimal Round(decimal value)
public static double Round(double value)
public static decimal Round(decimal value, int digits)
public static double Round(double value, int digits)
public static decimal Round(decimal value, MidpointRounding mode)
public static double Round(double value, MidpointRounding mode)
public static decimal Round(decimal value, int digits, MidpointRounding mode)
public static double Round(double value, int digits, MidpointRounding mode)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Math.Round&lt;/code&gt; — это метод округления к ближайшему числу или к ближайшему числу с заданным количеством знаков после запятой. Работает с типами &lt;code&gt;decimal&lt;/code&gt; и &lt;code&gt;double&lt;/code&gt;, в параметрах можно встретить три вида параметров:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;: округляемое число&lt;/li&gt;
&lt;li&gt;&lt;code&gt;digits&lt;/code&gt;: количество знаков в дробной части, которые нужно оставить&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mode&lt;/code&gt;: параметр, который определяет в какую сторону округлять число, которое находится ровно посередине между двумя вариантами&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Параметр &lt;code&gt;mode&lt;/code&gt; используется, когда округляемое значение находится ровно посередине между двумя вариантами. Принимает значение из следующего перечисления:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public enum MidpointRounding { AwayFromZero, ToEven}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AwayFromZero&lt;/code&gt;: округление происходит к тому числу, которое дальше от нуля.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ToEven&lt;/code&gt;: округление происходит к чётному числу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Обратите внимание, что по умолчанию &lt;code&gt;mode == MidpointRounding.ToEven&lt;/code&gt;, поэтому &lt;code&gt;Math.Round(1.5) == Math.Round(2.5) == 2&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Math.Floor, Math.Ceiling, Math.Truncate&lt;/h3&gt;
&lt;p&gt;MSDN:
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.math.floor.aspx&quot;&gt;Floor&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.math.ceiling.aspx&quot;&gt;Ceiling&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.math.truncate.aspx&quot;&gt;Truncate&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static decimal Floor(decimal value)
public static double Floor(double value)
public static decimal Ceiling(decimal value)
public static double Ceiling(double value)
public static decimal Truncate(decimal value)
public static double Truncate(double value)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Math.Floor&lt;/code&gt; округляет вниз по направлению к отрицательной бесконечности.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Math.Ceiling&lt;/code&gt; округляет вверх по направлению к положительной бесконечности.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Math.Truncate&lt;/code&gt; округляет вниз или вверх по направлению к нулю.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Сводная таблица&lt;/h3&gt;
&lt;p&gt;Сориентироваться в методах округления может помочь следующая табличка:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value               | -2.9 | -0.5 | 0.3 | 1.5 | 2.9 |
--------------------+------+------+-----+-----+-----+
Round(ToEven)       |   -3 |    0 |   0 |   2 |   3 |
Round(AwayFromZero) |   -3 |   -1 |   0 |   2 |   3 |
Floor               |   -3 |   -1 |   0 |   1 |   2 |
Ceiling             |   -2 |    0 |   1 |   2 |   3 |
Truncate            |   -2 |    0 |   0 |   1 |   2 |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Округление проводится в соответствии со стандартом &lt;em&gt;IEEE Standard 754, section 4&lt;/em&gt;.&lt;/p&gt;
&lt;h3&gt;Целочисленное деление и взятие по модулю&lt;/h3&gt;
&lt;p&gt;В C# есть два замечательных оператора над целыми числами: &lt;code&gt;/&lt;/code&gt; для целочисленного деления (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/3b1ff23f.aspx&quot;&gt;MSDN&lt;/a&gt;) и &lt;code&gt;%&lt;/code&gt;
для взятия остатка от деления (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/0w4e0fzs.aspx&quot;&gt;MSDN&lt;/a&gt;). Деление производится по следующим правилам:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;При целочисленном делении результат всегда округляется по направлению к нулю.&lt;/li&gt;
&lt;li&gt;При взятии остатка от деления должно выполняться следующее правило: &lt;code&gt;x % y = x – (x / y) * y&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Также можно пользоваться шпаргалкой:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; a |  b | a/b | a%b |
---+----+-----+-----+
 7 |  3 |  2  |  1  |
-7 |  3 | -2  | -1  |
 7 | -3 | -2  |  1  |
-7 | -3 |  2  | -1  |
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;string.Format&lt;/h3&gt;
&lt;p&gt;При форматировании чисел в виде строки можно пользоваться функцией &lt;code&gt;string.Format&lt;/code&gt; (см. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dwhawy9k.aspx&quot;&gt;Standard Numeric Format Strings&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/0c899ak8.aspx&quot;&gt;Custom Numeric Format Strings&lt;/a&gt;). Например, для вывода числа с двумя знаками после десятичной точки можно воспользоваться &lt;code&gt;string.Format(&amp;quot;{0:0.00}&amp;quot;, value)&lt;/code&gt; или &lt;code&gt;string.Format(&amp;quot;{0:N2}&amp;quot;, value)&lt;/code&gt;. Округление происходит по принципу &lt;code&gt;AwayFromZero&lt;/code&gt;. Проиллюстрируем правила округления очередной табличкой:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value  | string.Format(&amp;quot;{0:N2}&amp;quot;, value) |
-------+--------------------------------+
-2.006 | -2.01                          |
-2.005 | -2.01                          |
-2.004 | -2.00                          |
 2.004 |  2.00                          |
 2.005 |  2.01                          |
 2.006 |  2.01                          |
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Задачи&lt;/h3&gt;
&lt;p&gt;На приведённую тему есть две задачки в &lt;a href=&quot;http://problembook.net&quot;&gt;ProblemBook.NET&lt;/a&gt;: &lt;a href=&quot;http://problembook.net/content/ru/Math/Rounding1-P.html&quot;&gt;Rounding1&lt;/a&gt;, &lt;a href=&quot;http://problembook.net/content/ru/Math/Rounding2-P.html&quot;&gt;Rounding2&lt;/a&gt;.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Вся правда о TypeHandle в .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/typehandle/</link> 	
                <pubDate>Sat, 14 Sep 2013 11:55:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/typehandle/</guid>
                <description>&lt;p&gt;В разных умных книжках и статьях про .NET я часто наталкивался на упоминания про TypeHandle. Чаще всего пишут, что у каждого .NET-объекта в заголовке находится некоторый TypeHandle, который представляет собой ссылку на тип. Ещё пишут, что TypeHandle — это всегда указатель на таблицу методов типа. А в некоторых местах мне доводилось встречать информацию о том, что TypeHandle указывает на некий TypeDesc. В общем, я устал от неразберихи: давайте вместе разберёмся что к чему. А для этого нам придётся немного подизассемблировать, поизучать дампы памяти и залезть в исходники CLI.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;Что нам понадобится?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Нам нужна будет Visual Studio. А в ней нам понадобится консольное приложение, над которым мы будем ставить наши эксперименты. Для чистоты эксперимента не забываем поставить сборку проекта в &lt;code&gt;Release mode&lt;/code&gt;, а для честного дебага уберём галочку Suppress JIT optimization on module load (&lt;code&gt;Tools&lt;/code&gt; -&amp;gt; &lt;code&gt;Options&lt;/code&gt; -&amp;gt; &lt;code&gt;Debugging&lt;/code&gt; -&amp;gt; &lt;code&gt;General&lt;/code&gt;). В свойствах проекта на вкладке &lt;code&gt;Debug&lt;/code&gt; нужно включить опцию &lt;code&gt;Enable native code debugging&lt;/code&gt;. Для простоты примера будем собирать наш проект под &lt;code&gt;x86&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Расширение отладки &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/bb190764.aspx&quot;&gt;SOS&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.microsoft.com/en-us/download/details.aspx?id=4917&quot;&gt;Shared Source Common Language Infrastructure 2.0&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Пример 1&lt;/h3&gt;
&lt;p&gt;Начнём с совсем простого примера:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object a = new object();
Console.WriteLine(a);
Console.ReadLine();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Последние пара строчек нужна затем, чтобы можно было нормально подебажить (в дальнейшем я их приводить не буду). Давайте поставим точку останова на второй строчке и запустим наше приложение из студии (через &lt;code&gt;F5&lt;/code&gt;). Для удобной отладки нам понадобится несколько окошек: &lt;code&gt;Disassembly&lt;/code&gt;, &lt;code&gt;Registers&lt;/code&gt;, &lt;code&gt;Memory&lt;/code&gt; (их можно найти в &lt;code&gt;Debug&lt;/code&gt; -&amp;gt; &lt;code&gt;Windows&lt;/code&gt;).&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/typehandle/screen.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Наш объект только что создался, а его адрес вернулся нам через регистр &lt;code&gt;eax&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;;       object a = new object();
00000000  push        ebp 
00000001  mov         ebp,esp 
00000003  push        esi 
00000004  mov         ecx,65C4B060h 
00000009  call        FE6BF7A0      ; адрес нового объекта записывается в eax
0000000e  mov         esi,eax 
;       Console.WriteLine(a);
00000010  call        63ECA5E4 
;       ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В окне &lt;code&gt;Registers&lt;/code&gt; находим значение eax (у вас адреса будут другие)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EAX = 01ED1598 EBX = 0543EA64 
ECX = 65C4B060 EDX = 005495E8 
ESI = 01ED1598 EDI = 0543E9D0 
EIP = 01CF2970 ESP = 0543E9B0 
EBP = 0543E9B4 EFL = 00000212 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и копируем его в поле Address окна Memory:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x01ED1594  00000000  
0x01ED1598  65c4b060  
0x01ED159C  00000000  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Заметьте, что я привёл дамп памяти размером 12 байт — именно столько занимает сейчас наш объект. Разберёмся более подробно: в заголовке каждого объекта всегда присутствует два поля: &lt;code&gt;SyncBlockIndex&lt;/code&gt; (который размещается непосредственно перед объектом, т.е. обладает отрицательным смещением) и то, что мы пока назовём &#171;ссылкой на тип&#187;. Под архитектуру &lt;code&gt;x86&lt;/code&gt; каждое из этих полей занимает 4 байта. Но особенности работы GC требуют, чтобы минимальный размер объекта был 12 байт. Поэтому CLR аккуратненько дополняет объект 4 байтами до нужного размера. Давайте посмотрим на наш объект с помощью SOS. Откроем Immediate Window (для каждой дебаг-сессии необходимо включить SOS с помощью команды &lt;code&gt;.load sos.dll&lt;/code&gt;) и воспользуемся командой &lt;code&gt;!DumpObj&lt;/code&gt;, которой отдадим адрес нашего объекта:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.load sos.dll
!DumpObj 0x01ED1598
Name:        System.Object
MethodTable: 65c4b060
EEClass:     65854920
Size:        12(0xc) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
Object
Fields:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ага, теперь понятно: значение &lt;code&gt;0x65c4b060&lt;/code&gt; — это адрес таблицы методов (MethodTable) для нашего объекта. Давайте проверим эту гипотезу: воспользуемся командой
&lt;code&gt;!DumpMT&lt;/code&gt; для просмотра таблицы методов (если вы запустите эту команду с ключом &lt;code&gt;-MD&lt;/code&gt;
, то кроме заголовочной информации увидите ещё и все методы):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;!DumpMT 65c4b060
EEClass:         65854920
Module:          65851000
Name:            System.Object
mdToken:         02000002
File:            C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
BaseSize:        0xc
ComponentSize:   0x0
Slots in VTable: 12
Number of IFaces in IFaceMap: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Казалось бы всё понятно: в начале каждого объекта хранится ссылка на MethodTable — так CLR узнаёт к какому типу относится объект. Но не будем делать выводы по одному примеру: давайте взглянем на исходники CLI. В этом нам поможет &lt;a href=&quot;http://en.wikipedia.org/wiki/Shared_Source_Common_Language_Infrastructure&quot;&gt;SSCLI&lt;/a&gt; (в узких кругах известная как Rotor) — это открытые исходники реализации CLI от Microsoft. Увы, последняя версия SSCLI 2.0 датируется 2006-ым годом и относится к .NET Framework 2.0. Понадеемся, что базовые принципы хранения объектов в памяти не сильно поменялись за последнее время. Если открыть файл &lt;code&gt;sscli20\clr\src\vm\object.h&lt;/code&gt;, то ближе к началу можно найти такие строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Object
{
  protected:
    MethodTable*    m_pMethTab;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну, вроде всё верно: в объекте действительно хранится указатель на MethodTable. Такое заключение вы можете встретить во многих статьях и книжках. Только вот некоторые называют его просто указателем на MethodTable, а некоторые — TypeHandle. Как считаете, правильно ли это? Давайте разбираться дальше.&lt;/p&gt;
&lt;h3&gt;Пример 2&lt;/h3&gt;
&lt;p&gt;А теперь перейдём к устройству массива:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var a = new object[1];
a[0] = new object();  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Точно также перейдём в дебаггер, найдём адрес массива через регистры и посмотрим дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x02F9240C  00000000  // SyncBlockIndex (a)
0x02F92410  65bfab98  // System.Object[] MethodTable (a)
0x02F92414  00000001  // a.Length
0x02F92418  65c4b060  // (???) Type of elements in a
0x02F9241C  02f92424  // &amp;amp;a[0]
0x02F92420  00000000  // SyncBlockIndex (a[0])
0x02F92424  65c4b060  // System.Object MethodTable (a[0])
0x02F92428  00000000  // Free space (a[0])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После ссылки на таблицу методов для массива &lt;code&gt;a&lt;/code&gt; идёт количество элементов в массиве (1), а затем — &#171;ссылка на тип&#187; элементов массива. Обратите внимание, я ещё ничего не утверждаю об этих данных в общем случае. Просто имеется известный факт о том, что у массивов, элементы которых являются ссылочным типом, имеются дополнительные данные, которые некоторым образом характеризуют тип элементов массива. После всех этих служебных данных находится содержание массива — единственный элемент, хранящий адрес созданного &lt;code&gt;object&lt;/code&gt;. Легко видеть, что поле&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x02F92418  65c4b060 // System.Object[] MethodTable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;указывает на таблицу методов для &lt;code&gt;System.Object&lt;/code&gt;. Ну, вроде бы всё понятно: в массивах, элементы которого являются ссылочным типом, появляется дополнительное поле, которое указывает на MethodTable типа элементов. Но так ли это? Продолжим наше исследование.&lt;/p&gt;
&lt;h3&gt;Пример 3&lt;/h3&gt;
&lt;p&gt;А теперь создадим jagged-массив:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var a = new object[1][];
a[0] = new object[1];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Обратимся к дампу памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x0301240C  00000000  // SyncBlockIndex (a)
0x03012410  011731d4  // System.Object[][] MethodTable (a)
0x03012414  00000001  // a.Length
0x03012418  65854d7a  // (???) Type of elements in a
0x0301241C  03012424  // &amp;amp;a[0]
0x03012420  00000000  // SyncBlockIndex (a[0])
0x03012424  65bfab98  // System.Object[] MethodTable
0x03012428  00000001  // a[0].Length
0x0301242C  65c4b060  // Type of elements in a[0] = System.Object MethodTable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В этом дампе можно увидеть нечто странное: поле, которое должно определять тип элементов массива &lt;code&gt;a&lt;/code&gt; (по адресу &lt;code&gt;0x03012418&lt;/code&gt;) не ведёт на &lt;code&gt;System.Object[]&lt;/code&gt;
MethodTable — ведь адрес этой таблицы можно найти по адресу (&lt;code&gt;0x03012424&lt;/code&gt;) при описании MethodTable для &lt;code&gt;a[0]&lt;/code&gt; — и они различаются. Давайте убедимся, что значение
&lt;code&gt;0x65854d7a&lt;/code&gt; не определяет MehtodTable:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;!DumpMT 65854d7a
65854d7a is not a MethodTable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Но что же это тогда такое? Давайте обратимся к исходникам CLI за объяснением. В фале &lt;code&gt;sscli20\clr\src\vm\object.h&lt;/code&gt; также можно найти следующий код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// ArrayBase encapuslates all of these details.  In theory you should never
// have to peek inside this abstraction
class ArrayBase : public Object
{
    ...
    // This MUST be the first field, so that it directly follows Object.  This is because
    // Object::GetSize() looks at m_NumComponents even though it may not be an array (the
    // values is shifted out if not an array, so it&#39;s ok). 
    DWORD       m_NumComponents;
    ...
    // What comes after this conceputally is:
    // TypeHandle elementType;        Only present if the method table is shared among many types (arrays of pointers)
    // INT32      bounds[rank];       The bounds are only present for Multidimensional arrays   
    // INT32      lowerBounds[rank];  Valid indexes are lowerBounds[i] &amp;lt;= index[i] &amp;lt; lowerBounds[i] + bounds[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мы видим, что для массивов из элементов ссылочного типа (arrays of pointers) действительно появляется дополнительное поле, а тип его — TypeHandle. Но что же это такое? Перейдём к файлу &lt;code&gt;sscli20\clr\src\vm\typehandle.h&lt;/code&gt; . В самом начале файла к комментариях можно найти следующую полезную информацию:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// A TypeHandle is the FUNDAMENTAL concept of type identity in the CLR.
// That is two types are equal if and only if their type handles
// are equal.  A TypeHandle, is a pointer sized struture that encodes 
// everything you need to know to figure out what kind of type you are
// actually dealing with.  

// At the present time a TypeHandle can point at two possible things
//
//      1) A MethodTable    (Intrinsics, Classes, Value Types and their instantiations)
//      2) A TypeDesc       (all other cases: arrays, byrefs, pointer types, function pointers, generic type variables)  
//
// or with IL stubs, a third thing:
//
//      3) A MethodTable for a native value type.
//
// MTs that satisfy IsSharedByReferenceArrayTypes are not 
// valid TypeHandles: for example no allocated object will
// ever return such a type handle from Object::GetTypeHandle(), and
// these type handles should not be passed across the JIT Interface
// as CORINFO_CLASS_HANDLEs.  However some code in the EE does create 
// temporary TypeHandles out of these MTs, so we can&#39;t yet assert 
// !IsSharedByReferenceArrayTypes() in the TypeHandle constructor.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ага, значит TypeHandle может быть как указателем на MethodTable, так и указателем на TypeDesc, в зависимости от типа объекта. Для массивов он указывает на TypeDesc. Тип &lt;code&gt;object[][]&lt;/code&gt; — это массив, элементами которого являются &lt;code&gt;object[]&lt;/code&gt;, для которых TypeHandle=TypeDesc. Эта информация объясняет наш пример, но всё ещё остаются некоторые вопросы. Например: а как же отличить, на что именно указывает TypeHandle? Поможет нам в этом дальнейшее изучение исходников CLI:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   FORCEINLINE BOOL IsUnsharedMT() const {
        LEAF_CONTRACT;
        STATIC_CONTRACT_SO_TOLERANT;
        return((m_asTAddr &amp;amp; 2) == 0);
    }

    FORCEINLINE BOOL IsTypeDesc() const  {
        WRAPPER_CONTRACT;
        return(!IsUnsharedMT());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Всё зависит от второго бита в адресе: нулевое значение определяет MethodTable, а единичное — TypeDesc. Если мы работаем с шестнадцатеричными адресами, то можно легко определить вид TypeHandle по последней цифре:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MethodTable: 0, 1, 4, 5, 8, 9, C, D
TypeDesc   : 2, 3, 6, 7, A, B, E, F
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь взглянем ещё раз на дамп памяти нашего примера. Можно видеть, что для &lt;code&gt;System.Object[]&lt;/code&gt; в дампе присутствуют указатели как на его TypeDesc, так и на MethodTable. Не смотря на то, что под TypeHandle в данном случае подразумевается TypeDesc, заголовочный указатель для &lt;code&gt;a[0]&lt;/code&gt; всё-таки указывает на MethodTable. Поэтому некорректно говорить о том, что в заголовке каждого объекта хранится TypeHandle: там хранится указатель на MethodTable, а это далеко не всегда одно и то же.&lt;/p&gt;
&lt;h3&gt;Пример 4&lt;/h3&gt;
&lt;p&gt;Последний пример проиллюстрирует недавно полученное правило про последнюю цифру адреса. Мы можем получить TypeHandle прямо из управляемого кода, а по этому значению мы можем определить, что именно под ним подразумевается:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private void Run()
{
    Print(typeof(int));
    Print(typeof(object));
    Print(typeof(Stream));
    Print(typeof(int[]));
    Print(typeof(int[][]));
    Print(typeof(object[]));
}

private void Print(Type type)
{
    bool isTypeDesc = ((int)type.TypeHandle.Value &amp;amp; 2) &amp;gt; 0;
    Console.WriteLine(&amp;quot;{0}: {1} =&amp;gt; {2}&amp;quot;, 
        type.Name.PadRight(10), 
        type.TypeHandle.Value.ToString(&amp;quot;X&amp;quot;), 
        (isTypeDesc ? &amp;quot;TypeDesc&amp;quot; : &amp;quot;MethodTable&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;У меня этот код выводит следующее:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Int32     : 65C4C480 =&amp;gt; MethodTable
Object    : 65C4B060 =&amp;gt; MethodTable
Stream    : 65C4D954 =&amp;gt; MethodTable
Int32[]   : 65854C8A =&amp;gt; TypeDesc
Int32[][] : 658F6BD6 =&amp;gt; TypeDesc
Object[]  : 65854D7A =&amp;gt; TypeDesc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;В ходе нашего маленького исследования были получены следующие выводы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeHandle является указателем либо на MethodTable, либо на TypeDesc (зависит от типа объекта)&lt;/li&gt;
&lt;li&gt;В заголовке каждого объекта для идентификации его типа всегда хранится указатель на MethodTable (это не всегда TypeHandle)&lt;/li&gt;
&lt;li&gt;Для массивов, чьи элементы должны представлять ссылочный тип, хранится дополнительное поле, которое представляет собой TypeHandle для типа элементов.&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Сравнение производительности массивов в .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/arrays-access-performance/</link> 	
                <pubDate>Sat, 31 Aug 2013 01:32:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/arrays-access-performance/</guid>
                <description>&lt;h2&gt;Часть 1&lt;/h2&gt;
&lt;p&gt;Платформа .NET поддерживает два способа задания многомерных массивов: прямоугольные (rectangular) и изломанные (jagged). Второй способ по сути представляет собой массив массивов. Это обстоятельство создаёт у многих программистов иллюзию того, что jagged-массивы должны работать медленнее, т.к. обращение к их элементам реализуется через многократные переходы по ссылкам в управляемой куче. Но на самом деле jagged-массивы могут работают быстрее (если речь идёт непосредственно о работе с массивами, а не о их инициализации), ведь они представляют собой комбинацию одномерных (single) массивов, работа с которыми в CLR весьма оптимизирована (за счёт IL-команд &lt;code&gt;newarr&lt;/code&gt;, &lt;code&gt;ldelem&lt;/code&gt;, &lt;code&gt;ldelema&lt;/code&gt;, &lt;code&gt;ldlen&lt;/code&gt;, &lt;code&gt;stelem&lt;/code&gt;). Другим подходом к представлению многомерных данных является использование одномерного массива с ручным преобразованием координат (в массиве размерности N&lt;em&gt;M для обращения к элементу [i,j] будем писать [i&lt;/em&gt;M+j]). Если производительности не хватает, то можно использовать неуправляемый код, но этот случай мы сейчас рассматривать не будем, остановимся на трёх вышеозначенных способах. Для замеров времени используется
&lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;. Рассмотрим C# код, который замеряет время работы каждого варианта (полный вариант кода:
&lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs&quot;&gt;MultidimensionalArrayProgram.cs&lt;/a&gt;, тестировать следует в &lt;strong&gt;Release mode without debugging&lt;/strong&gt;). Данные результаты получены в сборке под x64 для процессора Intel Core i7-3632QM CPU 2.20GHz и параметров N=M=100, IterationCount=100000. Исследование вопроса о влиянии используемой архитектуры и параметров запуска на результат бенчмарка можно найти во второй части статьи.&lt;!--more--&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int N = 100, M = 100, IterationCount = 100000;
private int[] single;
private int[][] jagged;
private int[,] rectangular;

public void Run()
{
    var competition = new BenchmarkCompetition();

    competition.AddTask(&amp;quot;Single&amp;quot;,
        () =&amp;gt; single = new int[N * M],
        () =&amp;gt; SingleRun(single));

    competition.AddTask(&amp;quot;Jagged&amp;quot;,
        () =&amp;gt;
        {
            jagged = new int[N][];
            for (int i = 0; i &amp;lt; N; i++)
                jagged[i] = new int[M];
        },
        () =&amp;gt; JaggedRun(jagged));

    competition.AddTask(&amp;quot;Rectangular&amp;quot;,
        () =&amp;gt; rectangular = new int[N, M],
        () =&amp;gt; RectangularRun(rectangular));

    competition.Run();
}

private int SingleRun(int[] a)
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            for (int j = 0; j &amp;lt; M; j++)
                sum += a[i * M + j];
    return sum;
}

private int JaggedRun(int[][] a)
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            for (int j = 0; j &amp;lt; M; j++)
                sum += a[i][j];
    return sum;
}

private int RectangularRun(int[,] a)
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            for (int j = 0; j &amp;lt; M; j++)
                sum += a[i, j];
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот пример на моём ноутбуке даёт следующие результаты (запускать следует в Release mode):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Single:      542ms
Jagged:      346ms
Rectangular: 755ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как можно видеть, доступ к элементам jagged-массива всегда осуществляется заметно быстрее, чем доступ к элементам rectangular-массива. Работа с single-массивом будет происходить быстрее, чем с rectangular, но чуть медленнее, чем с jagged. Мне думается, что single работает чуть медленнее jagged в большей степени из-за следующей причины:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;На расчёт индекса i*M+j требуется время, не дающее оптимизации в сравнении с лишним вызовом &lt;code&gt;ldelem.ref&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Чтобы лучше разобраться рассмотрим IL-код каждого из методов в release режиме (для упрощения чтения из каждого метода был убран цикл итераций по &lt;code&gt;iteration&lt;/code&gt;).&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;single.il&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.method private hidebysig instance 
    int32 SingleAccessTest(int32[] a) cil managed
{
    .maxstack 4
    .locals init (
        [0] int32 sum,
        [1] int32 i,
        [2] int32 j)
    L_0000: ldc.i4.0     // Stack = [0]
    L_0001: stloc.0      // sum = 0, Stack = []
    L_0002: ldc.i4.0     // Stack = [0]
    L_0003: stloc.1      // i = 0, Stack = []
    L_0004: br.s L_0022  // GoTo L_0022
CY1 L_0006: ldc.i4.0     // Stack = [0]
    L_0007: stloc.2      // j = 0, Stack = []
    L_0008: br.s L_0019  // GoTo L_0019
CY2 L_000a: ldloc.0      // Stack = [sum]
    L_000b: ldarg.1      // Stack = [sum, a]
    L_000c: ldloc.1      // Stack = [sum, a, i]
    L_000d: ldc.i4.s 100 // Stack = [sum, a, i, 100]
    L_000f: mul          // Stack = [sum, a, i * 100]
    L_0010: ldloc.2      // Stack = [sum, a, i * 100, j]
    L_0011: add          // Stack = [sum, a, i * 100 + j]
    L_0012: ldelem.i4    // Stack = [sum, a[i * 100 + j]]
    L_0013: add          // Stack = [sum + a[i * 100 + j]]
    L_0014: stloc.0      // sum = sum + a[i * 100 + j], Stack = []
    L_0015: ldloc.2      // Stack = [j]
    L_0016: ldc.i4.1     // Stack = [j, 1]
    L_0017: add          // Stack = [j + 1]
    L_0018: stloc.2      // j = j + 1, Stack = []
CY2 L_0019: ldloc.2      // Stack = [j]
    L_001a: ldc.i4.s 100 // Stack = [j, 100]
    L_001c: blt.s L_000a // GoTo L_000a (if j &amp;lt; 100), Stack = []
    L_001e: ldloc.1      // Stack = [i]
    L_001f: ldc.i4.1     // Stack = [i, 1]
    L_0020: add          // Stack = [i + 1]
    L_0021: stloc.1      // i = i + 1, Stack = []
CY1 L_0022: ldloc.1      // Stack = [i]
    L_0023: ldc.i4.s 100 // Stack = [i, 100]
    L_0025: blt.s L_0006 // GoTo L_0006 (if i &amp;lt; 100), Stack = []
    L_0027: ldloc.0      // Stack = [sum]
    L_0028: ret          // return sum, Stack = []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;jagged.il&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.method private hidebysig instance 
    int32 JaggedAccessTest(int32[][] a) cil managed
{
    .maxstack 3
    .locals init (
        [0] int32 sum,
        [1] int32 i,
        [2] int32 j)
    L_0000: ldc.i4.0     // Stack = [0]
    L_0001: stloc.0      // sum = 0, Stack = []
    L_0002: ldc.i4.0     // Stack = [0]
    L_0003: stloc.1      // i = 0, Stack = []
    L_0004: br.s L_001f  // GoTo L_001f
CY1 L_0006: ldc.i4.0     // Stack = [0]
    L_0007: stloc.2      // j = 0, Stack = []
    L_0008: br.s L_0016  // Stack = []
CY2 L_000a: ldloc.0      // Stack = [sum]
    L_000b: ldarg.1      // Stack = [sum, a]
    L_000c: ldloc.1      // Stack = [sum, a, i]
    L_000d: ldelem.ref   // Stack = [sum, a[i]]
    L_000e: ldloc.2      // Stack = [sum, a[i], j]
    L_000f: ldelem.i4    // Stack = [sum, a[i][j]]
    L_0010: add          // Stack = [sum + a[i][j]]
    L_0011: stloc.0      // sum = sum + a[i][j], Stack = []
    L_0012: ldloc.2      // Stack = [j]
    L_0013: ldc.i4.1     // Stack = [j + 1]
    L_0014: add          // Stack = [j + 1]
    L_0015: stloc.2      // j = j + 1, Stack = []
CY2 L_0016: ldloc.2      // Stack = [j]
    L_0017: ldc.i4.s 100 // Stack = [j, 100]
    L_0019: blt.s L_000a // GoTo L_000a (if j &amp;lt; 100)
    L_001b: ldloc.1      // Stack = [i]
    L_001c: ldc.i4.1     // Stack = [i, 1]
    L_001d: add          // Stack = [i + 1]
    L_001e: stloc.1      // i = i + 1, Stack = []
CY1 L_001f: ldloc.1      // Stack = [i]
    L_0020: ldc.i4.s 100 // Stack = [i, 100]
    L_0022: blt.s L_0006 // GoTo L_0006 (if i &amp;lt; 100)
    L_0024: ldloc.0      // Stack = [sum]
    L_0025: ret          // return sum, Stack = []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;rectangular.il&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.method private hidebysig instance 
    int32 RectangularAccessTest(int32[0...,0...] a) cil managed
{
    .maxstack 4
    .locals init (
        [0] int32 sum,
        [1] int32 i,
        [2] int32 j)
    L_0000: ldc.i4.0     // Stack = [0]
    L_0001: stloc.0      // sum = 0, Stack = []
    L_0002: ldc.i4.0     // Stack = [0]
    L_0003: stloc.1      // i = 0, Stack = []
    L_0004: br.s L_0022  // GoTo L_0022
CY1 L_0006: ldc.i4.0     // Stack = [0]
    L_0007: stloc.2      // j = 0, Stack = []
    L_0008: br.s L_0019  // GoTo L_0019
CY2 L_000a: ldloc.0      // Stack = [sum]
    L_000b: ldarg.1      // Stack = [sum, a]
    L_000c: ldloc.1      // Stack = [sum, a, i]
    L_000d: ldloc.2      // Stack = [sum, a, i, j]
    L_000e: call instance int32 int32[0...,0...]::Get(int32, int32)
                         // Stack = [sum, a[i, j]]
    L_0013: add          // Stack = [sum + a[i, j]]
    L_0014: stloc.0      // sum = sum + a[i, j], Stack = []
    L_0015: ldloc.2      // Stack = [j]
    L_0016: ldc.i4.1     // Stack = [j, 1]
    L_0017: add          // Stack = [j + 1]
    L_0018: stloc.2      // j = j +1, Stack = []
CY2 L_0019: ldloc.2      // Stack = [j]
    L_001a: ldc.i4.s 100 // Stack = [j, 100]
    L_001c: blt.s L_000a // GoTo L_000a (if j &amp;lt; 100), Stack = []
    L_001e: ldloc.1      // Stack = [i]
    L_001f: ldc.i4.1     // Stack = [i, 1]
    L_0020: add          // Stack = [i + 1]
    L_0021: stloc.1      // i = i + 1, Stack = []
CY1 L_0022: ldloc.1      // Stack = [i]
    L_0023: ldc.i4.s 100 // Stack = [i, 100]
    L_0025: blt.s L_0006 // GoTo L_0006 (if i &amp;lt; 100), Stack = []
    L_0027: ldloc.0      // Stack = [sum]
    L_0028: ret          // return sum, Stack = []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Часть 2&lt;/h2&gt;
&lt;p&gt;В первой части статьи я задался задачей сравнить производительность многомерных массивов. Рассматривались данные в виде двумерного массива N*M, тестировалась скорость доступа к элементу &lt;code&gt;[i,j]&lt;/code&gt; при итерировании по всему массиву двумя циклами. Для сравнения было выбрано три варианта: одномерный массив &lt;code&gt;single[i * N + j]&lt;/code&gt; и двумерные массивы &lt;code&gt;jagged[i][j]&lt;/code&gt;, &lt;code&gt;rectangular[i, j]&lt;/code&gt;. Изначально у меня получилось, что &lt;code&gt;jagged&lt;/code&gt;-версия работает быстрее &lt;code&gt;single&lt;/code&gt; версии, но более детальное изучение проблемы показало, что дело может измениться в зависимости от используемых JIT-оптимизаций. Разберёмся с проблемой более подробно.&lt;/p&gt;
&lt;p&gt;Рассмотрим методы из &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs&quot;&gt;бенчмарка&lt;/a&gt; с наборами параметров &lt;code&gt;&#171;100&#187;&lt;/code&gt; (N=M=100, IterationCount=100000) и &lt;code&gt;&#171;101&#187;&lt;/code&gt; (N=M=101, IterationCount=100001) под x86 и x64. На моей машине (Intel Core i7-3632QM CPU 2.20GHz) получились следующие результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  100-x86
Single      : 1012ms
Jagged      :  772ms
Rectangular : 1460ms

  101-x86
Single      : 1036ms
Jagged      :  785ms
Rectangular : 1485ms  

  100-x64
Single      : 544ms
Jagged      : 346ms
Rectangular : 741ms

  101-x64
Single      :  785ms
Jagged      :  793ms
Rectangular : 1050ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Любопытно, не правда ли? Ну, давайте разбираться. Сразу видно, что &lt;code&gt;Rectangular&lt;/code&gt;-версия всегда работает медленнее двух других. Так происходит из-за того, что работа с одномерными массивами реализуется через команды &lt;code&gt;newarr&lt;/code&gt;, &lt;code&gt;ldelem&lt;/code&gt;, &lt;code&gt;ldelema&lt;/code&gt;, &lt;code&gt;ldlen&lt;/code&gt;, &lt;code&gt;stelem&lt;/code&gt;, которые CLR в достаточной мере оптимизирует. Поэтому отложим рассмотрение &lt;code&gt;Rectangular&lt;/code&gt;-метода на будущее, а сейчас сосредоточимся на сравнении &lt;code&gt;Single&lt;/code&gt; и &lt;code&gt;Jagged&lt;/code&gt; методов.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;x86&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Single-100-x86.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push ebp 
01 mov  ebp,esp 
03 push edi 
04 push esi 
05 push ebx 
06 push eax 
07 xor  ecx,ecx                       ; sum = 0
09 mov  dword ptr [ebp-10h],ecx       ; iteration = 0
0c xor  ebx,ebx                       ; i = 0
0e xor  esi,esi                       ; j = 0
10 mov  edi,dword ptr [edx+4]         ; edi = a.Length
13 imul eax,ebx,64h                   ; eax = i * 100
16 add  eax,esi                       ; eax = i * 100 + j
18 cmp  eax,edi                       ; if i * 100 + j &amp;gt;= a.Length then
1a jae  00000040                      ; throw IndexOutOfRangeException
1c add  ecx,dword ptr [edx+eax*4+8]   ; sum += a[i * 100 + j]
20 inc  esi                           ; j++
21 cmp  esi,64h                       ; if j &amp;lt; 100 then
24 jl   00000013                      ; loop by j
26 inc  ebx                           ; i++
27 cmp  ebx,64h                       ; if i &amp;lt; 100 then
2a jl   0000000E                      ; loop by i
2c inc  dword ptr [ebp-10h]           ; iteration++
2f cmp  dword ptr [ebp-10h],186A0h    ; if iteration &amp;lt; 100000 then
36 jl   0000000C                      ; loop by iteration
38 mov  eax,ecx                       ; eax = sum (Result)
3a pop  ecx 
3b pop  ebx 
3c pop  esi 
3d pop  edi 
3e pop  ebp 
3f ret   
40 call 65BC5A15                      ; IndexOutOfRangeException
45 int  3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Jagged-100-x86.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00  push ebp 
01  mov  ebp,esp 
03  push edi 
04  push esi 
05  push ebx 
06  push eax 
07  mov  ecx,edx                       ; ecx = &amp;amp;a
09  xor  ebx,ebx                       ; sum = 0
0b  mov  dword ptr [ebp-10h],ebx       ; iteration = 0
0e  xor  edx,edx                       ; i = 0
10  xor  esi,esi                       ; j = 0
12  mov  eax,dword ptr [ecx+4]         ; eax = a.Length
15  cmp  edx,eax                       ; if i &amp;gt;= a.Length then
17  jae  00000048                      ; throw IndexOutOfRangeException
19  mov  eax,dword ptr [ecx+edx*4+0Ch] ; eax = &amp;amp;a[i]
1d  mov  edi,dword ptr [eax+4]         ; edi = a[i].Length
20  cmp  esi,edi                       ; if j &amp;gt;= a[i].Length
22  jae  00000048                      ; throw IndexOutOfRangeException
24  add  ebx,dword ptr [eax+esi*4+8]   ; sum += a[i][j]
28  inc  esi                           ; j++
29  cmp  esi,64h                       ; if j &amp;lt; 100 then
2c  jl   00000020                      ; loop by j
2e  inc  edx                           ; i++
2f  cmp  edx,64h                       ; if i &amp;lt; 100 then
32  jl   00000010                      ; loop by i
34  inc  dword ptr [ebp-10h]           ; iteration++
37  cmp  dword ptr [ebp-10h],186A0h    ; if iteration &amp;lt; 100000 then
3e  jl   0000000E                      ; loop by iteration
40  mov  eax,ebx                       ; eax = sum (Result)
42  pop  ecx 
43  pop  ebx 
44  pop  esi 
45  pop  edi 
46  pop  ebp 
47  ret    
48  call 66935A55                      ; IndexOutOfRangeException
4d  int  3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Большая часть кода в обоих методах совпадает. Сравним непосредственный код обращения к элементу:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;; Single
13 imul eax,ebx,64h                    ; eax = i * 100
16 add  eax,esi                        ; eax = i * 100 + j
1c add  ecx,dword ptr [edx+eax*4+8]    ; sum += a[i * 100 + j]
; Jagged
19 mov  eax,dword ptr [ecx+edx*4+0Ch] ; eax = &amp;amp;a[i]
24 add  ebx,dword ptr [eax+esi*4+8]   ; sum += a[i][j]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отсюда можно понять, почему же &lt;code&gt;jagged&lt;/code&gt;-версия лидирует в скорости: для доступа к массиву нам необходимо всего навсего перейти по паре ссылок, а вот в &lt;code&gt;single&lt;/code&gt;-версии приходится использовать &#171;тяжёлые&#187; операции &lt;code&gt;imul&lt;/code&gt; и &lt;code&gt;add&lt;/code&gt; для подсчёта индекса массива.&lt;/p&gt;
&lt;p&gt;Оптимизаций по развертке цикла (см. &lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_unwinding&quot;&gt;Loop unwinding&lt;/a&gt;) в данных методах не наблюдается, поэтому версия методов &lt;code&gt;101-x86&lt;/code&gt;
не будет отличаться от &lt;code&gt;100-x86&lt;/code&gt; за исключением подставленных констант.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;100-x64&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Single-100-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;000 push   rbx 
001 push   rbp 
002 push   rsi 
003 push   rdi 
004 push   r12 
006 push   r13 
008 push   r14 
00a push   r15 
00c sub    rsp,28h 
010 mov    rbx,rdx                     ; rbx = &amp;amp;a
013 xor    r11d,r11d                   ; iteration = 0
016 mov    r9d,r11d                    ; sum = 0
019 nop    dword ptr [rax+00000000h] 
020 xor    edi,edi                     ; (i*100) = 0
022 lea    eax,[rdi+64h]                
025 movsxd rcx,eax                      
028 lea    rbp,[rcx*4+00000000h]        ; rbp = 400  
030 movsxd rax,edi                     
033 lea    r10,[rax*4+00000000h]        ; j = 0
03b movsxd rax,edi 
03e lea    r8,[rax*4+00000000h] 
046 mov    rdx,qword ptr [rbx+8]        ; rdx = a.Length
04a lea    rsi,[rdx*4+00000000h]        ; rsi = a.Length * 4
052 lea    eax,[rdi+1] 
055 movsxd rcx,eax 
058 lea    r12,[rcx*4+00000000h]        ; r12 = 1 * 4
060 sub    r12,r8 
063 lea    r14,[rdx*4+00000000h]        ; r14 = a.Length * 4
06b lea    eax,[rdi+2] 
06e movsxd rcx,eax                        
071 lea    r13,[rcx*4+00000000h]        ; r13 = 2 * 4
079 sub    r13,r8                       
07c lea    r15,[rdx*4+00000000h]        ; r15 = a.Length * 4
084 lea    eax,[rdi+3]                  
087 movsxd rcx,eax                         
08a shl    rcx,2                           
08e sub    rcx,r8                       ; rcx = 3 * 4
091 shl    rdx,2                        ; rdx = a.Length * 4
095 cmp    r10,rsi                      ; if j &amp;gt;= a.Length then
098 jae    0000000000000110             ; throw IndexOutOfRangeException
09a mov    eax,dword ptr [rbx+r10+10h]  ; eax = a[j]
09f add    r9d,eax                      ; sum += a[j]
0a2 lea    rax,[r10+r12]                ; rax = (j + 1)*4
0a6 cmp    rax,r14                      ; if j + 1 &amp;gt;= a.Length then
0a9 jae    0000000000000110             ; throw IndexOutOfRangeException
0ab mov    eax,dword ptr [rbx+rax+10h]  ; eax = a[j + 1]
0af add    r9d,eax                      ; sum += a[j + 1]
0b2 lea    rax,[r10+r13]                ; rax = (j + 2)*4
0b6 cmp    rax,r15                      ; if j + 2 &amp;gt;= a.Length
0b9 jae    0000000000000110             ; throw IndexOutOfRangeException
0bb mov    eax,dword ptr [rbx+rax+10h]  ; eax = a[j + 2]
0bf add    r9d,eax                      ; sum += a[j + 2]
0c2 lea    rax,[r10+rcx]                ; rax = (j + 3)*4
0c6 cmp    rax,rdx                      ; if j &amp;gt;= a.Length
0c9 jae    0000000000000110             ; throw IndexOutOfRangeException
0cb mov    eax,dword ptr [rbx+rax+10h]  ; eax = a[j + 3]
0cf add    r9d,eax                      ; sum += a[j + 3]
0d2 add    r10,10h                      ; j += 4
0d6 cmp    r10,rbp                      ; if j &amp;lt; 100 then
0d9 jl     0000000000000095             ; loop by j
0db add    edi,64h                      ; (i*100) += 100
0de cmp    edi,2710h                    ; if (i*100) &amp;lt; 10000 then
0e4 jl     0000000000000022             ; loop by i
0ea inc    r11d                         ; iteration++
0ed cmp    r11d,186A0h                  ; if iteration &amp;lt; 100000 then
0f4 jl     0000000000000020             ; loop by iteration
0fa mov    eax,r9d                      ; eax = sum (Result)
0fd add    rsp,28h 
101 pop    r15 
103 pop    r14 
105 pop    r13 
107 pop    r12 
109 pop    rdi 
10a pop    rsi 
10b pop    rbp 
10c pop    rbx 
10d ret      
10e xchg   ax,ax 
110 call   000000005FA5AC24             ; IndexOutOfRangeException
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Jagged-100-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push rbx                                 
01 sub  rsp,20h                           
05 mov  r10,rdx                        ; r10 = &amp;amp;a
08 xor  edx,edx                        ; iteration = 0
0a mov  r8d,edx                        ; sum = 0
0d nop  dword ptr [rax]                    
10 xor  ecx,ecx                        ; i = 0
12 xor  r9d,r9d                        ; j = 0
15 mov  rax,qword ptr [r10+8]          ; rax = a.Length
19 cmp  rcx,rax                        ; if i &amp;gt;= a.Length
1c jae  0000000000000099               ; throw IndexOutOfRangeException
1e mov  r11,qword ptr [r10+rcx*8+18h]  ; r11 = &amp;amp;a[i]
23 mov  rax,qword ptr [r11+8]          ; rax = a[i].Length
27 mov  ebx,60h                        ; ebx = 96
2c cmp  rbx,rax                        ; if 96 &amp;gt;= a[i].Length
2f jae  0000000000000099               ; throw IndexOutOfRangeException
31 mov  ebx,61h                        ; ebx = 97
36 cmp  rbx,rax                        ; if 97 &amp;gt;= a[i].Length
39 jae  0000000000000099               ; throw IndexOutOfRangeException
3b mov  ebx,62h                        ; ebx = 98
40 cmp  rbx,rax                        ; if 98 &amp;gt;= a[i].Length
43 jae  0000000000000099               ; throw IndexOutOfRangeException
45 mov  ebx,63h                        ; ebx = 99
4a cmp  rbx,rax                        ; if 99 &amp;gt;= a[i].Length
4d jae  0000000000000099               ; throw IndexOutOfRangeException
4f nop                                      
50 mov  eax,dword ptr [r11+r9+10h]     ; eax = a[i][j]
55 add  r8d,eax                        ; sum += a[i][j]
58 mov  eax,dword ptr [r11+r9+14h]     ; eax = a[i][j + 1]
5d add  r8d,eax                        ; sum += a[i][j + 1]
60 mov  eax,dword ptr [r11+r9+18h]     ; eax = a[i][j + 2]
65 add  r8d,eax                        ; sum += a[i][j + 2]
68 mov  eax,dword ptr [r11+r9+1Ch]     ; eax = a[i][j + 3]
6d add  r8d,eax                        ; sum += a[i][j + 3]
70 add  r9,10h                         ; j + 4
74 cmp  r9,190h                        ; if j &amp;lt; 100 then
7b jl   0000000000000050               ; loop by j
7d inc  rcx                            ; i++
80 cmp  rcx,64h                        ; if i &amp;lt; 100 then
84 jl   0000000000000012               ; loop by i
86 inc  edx                            ; iteration++
88 cmp  edx,186A0h                     ; if iteration &amp;lt; 100000 then
8e jl   0000000000000010               ; loop by iteration
90 mov  eax,r8d                        ; eax = sum (Result)
93 add  rsp,20h                            
97 pop  rbx                               
98 ret                                      
99 call 000000005FA69BF4               ; IndexOutOfRangeException
9e nop              
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут тоже всё понятно: &lt;code&gt;single&lt;/code&gt;-версия тормозит из-за кучи операций с высчитыванием индексов, в то время как в &lt;code&gt;jagged&lt;/code&gt; достаточно просто пару раз перейти по ссылкам. Обе версии работают намного быстрее своего x86-аналога, т.к. теперь у нас достаточно регистров, чтобы сделать оптимизацию по развёртке цикла (см. &lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_unwinding&quot;&gt;Loop unwinding&lt;/a&gt;).&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;101-x64&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Single-101-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push   rbx 
01 sub    rsp,20h 
05 mov    r10,rdx                      ; r10 = &amp;amp;a
08 xor    edx,edx                      ; iteration = 0
0a mov    r9d,edx                      ; sum = 0
0d nop    dword ptr [rax] 
10 xor    r8d,r8d                      ; i = 0
13 nop    word ptr [rax+rax+00000000h] 
20 lea    eax,[r8+65h]                 ; eax = (i*101)+101
24 movsxd rcx,eax                      ; rcx = (i*101)+101
27 lea    rbx,[rcx*4+00000000h]        ; rbx = ((i*101)+101) * 4
2f movsxd rax,r8d                      ; rax = (i*101) * 4
32 lea    rcx,[rax*4+00000000h]        ; j = (i*101)
3a mov    rax,qword ptr [r10+8]        ; rax = a.Length
3e lea    r11,[rax*4+00000000h]        ; r11 = a.Length * 4
46 cmp    rcx,r11                      ; if j &amp;lt; a.Length
49 jae    0000000000000080             ; throw IndexOutOfRangeException
4b mov    eax,dword ptr [r10+rcx+10h]  ; eax = a[i * 101 + j]
50 add    r9d,eax                      ; sum += a[i * 101 + j]
53 add    rcx,4                        ; j++
57 cmp    rcx,rbx                      ; if j &amp;lt; (i*101)+101 then
5a jl     0000000000000046             ; loop by j
5c add    r8d,64h                      ; (i*100) += 100
60 cmp    r8d,2774h                    ; if (i*100) &amp;lt; 10100
67 jl     0000000000000020             ; loop by i
69 inc    edx                          ; iteration++
6b cmp    edx,186A1h                   ; if iteration &amp;lt; 100001 then
71 jl     0000000000000010             ; loop by iteration
73 mov    eax,r9d                      ; eax = sum (Result)
76 add    rsp,20h 
7a pop    rbx 
7b ret       
7c nop    dword ptr [rax] 
80 call   000000005FA5AC24             ; IndexOutOfRangeException
85 nop       
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Jagged-101-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push rbx 
01 sub  rsp,20h 
05 mov  r10,rdx                        ; r10 = &amp;amp;a
08 xor  edx,edx                        ; iteration = 0
0a mov  r9d,edx                        ; sum = 0
0d nop  dword ptr [rax] 
10 xor  ecx,ecx                        ; i = 0
12 xor  r8d,r8d                        ; j = 0
15 mov  rax,qword ptr [r10+8]          ; rax = a.Length
19 cmp  rcx,rax                        ; if i &amp;gt;= a.Length then
1c jae  0000000000000062               ; throw IndexOutOfRangeException
1e mov  r11,qword ptr [r10+rcx*8+18h]  ; r11 = &amp;amp;a[i]
23 mov  rax,qword ptr [r11+8]          ; rax = a[i].Length
27 mov  ebx,64h                        ; ebx = 100
2c cmp  rbx,rax                        ; if 100 &amp;gt;= a[i].Length then
2f jae  0000000000000062               ; throw IndexOutOfRangeException
31 mov  eax,dword ptr [r11+r8+10h]     ; eax = a[i][j]
36 add  r9d,eax                        ; sum += a[i][j]
39 add  r8,4                           ; j++
3d cmp  r8,194h                        ; if j &amp;lt; 101 then
44 jl   0000000000000031               ; loop by j
46 inc  rcx                            ; i++
49 cmp  rcx,65h                        ; if i &amp;lt; 101 then
4d jl   0000000000000012               ; loop by i
4f inc  edx                            ; iteration++
51 cmp  edx,186A1h                     ; if iteration &amp;lt; 100001 then
57 jl   0000000000000010               ; loop by iteration
59 mov  eax,r9d                        ; eax = sum (Result)
5c add  rsp,20h 
60 pop  rbx 
61 ret   
62 call 000000005FA69D04               ; IndexOutOfRangeException
67 nop   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как можно видеть, в &lt;code&gt;101&lt;/code&gt;-версии оптимизации развёртки цикла по очевидным причинам не стало. Однако, скорость работы методов сравнялась. Так произошло из-за того, что JIT под &lt;code&gt;x64&lt;/code&gt; более оптимально реализовал &lt;code&gt;Single&lt;/code&gt;-версию: он не стал явно высчитывать индекс каждый раз, а вместо этого он для каждой строки матрицы данных перед циклом по &lt;code&gt;j&lt;/code&gt; высчитывает смещение, относительно которого берутся элементы. Таким образом, &lt;code&gt;Single&lt;/code&gt; и &lt;code&gt;Jagged&lt;/code&gt; версии выполняют практически одни и те же операции для получения элементов массива.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Быстродействие многих методов сильно зависит от произведённых JIT-оптимизаций, которые в свою очередь зависят от используемой архитектуры. Оптимизация развёртки цикла применяется в обоих случаях по самому вложенному циклу и не влияет на сравнение быстродействий разных способов. &lt;code&gt;Rectangular&lt;/code&gt; версия всегда работает медленнее своих &#171;конкурентов&#187;, т.к. в CLR работа с многомерными массивами такого рода организована сложнее, чем с одномерными.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Single&lt;/code&gt;-метод (&lt;code&gt;single[i*M+j]&lt;/code&gt;) &lt;em&gt;обычно&lt;/em&gt; работает медленнее, чем &lt;code&gt;Jagged&lt;/code&gt; (&lt;code&gt;jagged[i][j]&lt;/code&gt;), т.к. вычисление индекса &lt;code&gt;i*N+j&lt;/code&gt; на каждой итерации является более затратной операцией, чем явный переход по двум ссылкам. Однако, они &lt;em&gt;могут сравняться&lt;/em&gt; по времени работы, если JIT нужным образом соптимизирует &lt;code&gt;Single&lt;/code&gt; версию. Если же говорить о непосредственном доступе к элементу без расчёта индекса, то &lt;code&gt;single[i]&lt;/code&gt; будет лидировать в скорости по сравнению с &lt;code&gt;jagged[i][j]&lt;/code&gt;.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Об итерировании статичных массивов в .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/static-array-iteration/</link> 	
                <pubDate>Thu, 29 Aug 2013 00:45:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/static-array-iteration/</guid>
                <description>&lt;h2&gt;Часть 1&lt;/h2&gt;
&lt;p&gt;Управляемый подход платформы .NET делает жизнь разработчиков достаточно простой, беря на себя многие рутинные операции. Большую часть времени программист может вообще не вспоминать о технической реализации платформы, сосредоточившись исключительно на логике своего приложения. Но иногда попадаются задачи, критичные по производительности. Существует множество различных подходов к оптимизации кода в таких ситуациях вплоть до переписывания наиболее важных частей кода через неуправляемый код. Однако, зачастую для увеличения скорости приложения достаточно понимать, сколько времени тратится на ту или иную операцию. Знание подобных вещей позволит оптимизировать некоторые методы с помощью достаточно простых модификаций исходного кода.&lt;/p&gt;
&lt;p&gt;В этой статье мне хотелось бы поговорить о скорости доступа к массивам, ссылки на которые хранятся в статичных переменных. Дело в том, что в скорость итерирования по ним в зависимости от условий запуска может быть ниже, чем для массива, ссылка на который хранится в обычном поле экземпляра класса или локальной переменной. Рассмотрим пример.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;В примере будем решать простую задачу: подсчёт суммы элементов массива. В первом случае мы будем использовать обычное боле класса, а во втором — статическое. Для замеров времени будем использовать &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; (исходный код примера: &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/ArrayIterationProgram.cs&quot;&gt;ArrayIterationProgram.cs&lt;/a&gt;, тестировать следует в &lt;strong&gt;Release mode without debugging&lt;/strong&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int N = 1000, IterationCount = 1000000;

private int[] nonStaticField;
private static int[] staticField;

public void Run()
{
    nonStaticField = staticField = new int[N];

    var competition = new BenchmarkCompetition();
    competition.AddTask(&amp;quot;Non-static&amp;quot;, () =&amp;gt; NonStaticRun());
    competition.AddTask(&amp;quot;Static&amp;quot;, () =&amp;gt; StaticRun());
    competition.Run();
}

private int NonStaticRun()
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += nonStaticField[i];
    return sum;
}

private int StaticRun()
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += staticField[i];
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;На своей машине я получил следующие результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static : 346ms
Static     : 535ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если мы взглянем на IL-код целевых методов, то увидим, что они различаются только в одном месте, при обращении к полю:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static:
L_000b: ldarg.0 
L_000c: ldfld int32[] Benchmarks.StaticFieldBenchmark::nonStaticField
Static:
L_000b: ldsfld int32[] Benchmarks.StaticFieldBenchmark::staticField
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Заметим, что физически оба поля ссылаются на одну и ту же область памяти. Мы можем ускорить работу со статическим полем, если перед многократным обращением к полю сохраним его в локальную переменную:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private int StaticRun()
{
    var localField = staticField;
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += localField[i];
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В итоге &lt;code&gt;StaticRun&lt;/code&gt; будет работать столько же, сколько и &lt;code&gt;NonStaticRun&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Объяснение такого поведения можно прочитать во второй части статьи.&lt;/p&gt;
&lt;h2&gt;Часть 2&lt;/h2&gt;
&lt;p&gt;В первой части я встретился с весьма интересной ситуацией. Были измерены скорости работы двух методов, в первом из которых считалась сумма элементов массива, ссылка на который хранилась в обычном поле объекта, а во втором — массива, ссылка на который хранилась в статичном поле. Результаты меня удивили: массивы были одинаковые, но второй метод работал ощутимо дольше. Сперва я подумал, что дело в организации скорости доступа к статичным полям, но более детальный анализ ситуации и разговоры с коллегами помогли мне понять, что истинная причина такого поведения намного интересней: для массивов, длина которых кратна 4, JIT использует различные оптимизации в случае обычных и статичных массивов. Давайте разберёмся с ситуацией более детально.&lt;/p&gt;
&lt;p&gt;Напомню методы, поведение которых мы будем изучать:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private const int N = 1000, IterationCount = 1000000;
private int[] nonStaticField;
private static int[] staticField;

public void Run()
{
    nonStaticField = staticField = new int[N];
    NonStaticRun();
    StaticRun();
}

private int NonStaticRun()
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += nonStaticField[i];
    return sum;
}

private int StaticRun()
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += staticField[i];
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для начала поменяем Platform target на x86 и запустим &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/ArrayIterationProgram.cs&quot;&gt;бенчмарк&lt;/a&gt;. Получим следующие результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static : 708ms
Static     : 709ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Интересный вывод: на x86 результаты тестов одинаковы. Чтобы лучше разобраться в проблеме взглянем на нативный код, который получается после JIT-оптимизаций (изучается версия в Release mode without debugging). Конфигурация моей машины, на которой я проводил тестирование: Intel Core i7-3632QM CPU 2.20GHz.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NonStaticRun-x86.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push ebp 
01 mov  ebp,esp 
03 push edi 
04 push esi 
05 push ebx 
06 xor  edi,edi                     ; sum = 0
08 xor  ebx,ebx                     ; iteration
0a xor  edx,edx                     ; i = 0
0c mov  eax,dword ptr [ecx+4]       ; eax = &amp;amp;nonStaticField
0f mov  esi,dword ptr [eax+4]       ; esi = nonStaticField.Length
12 cmp  edx,esi                     ; if i &amp;gt;= nonStaticField.Length then
14 jae  00000033                    ; throw IndexOutOfRangeException
16 add  edi,dword ptr [eax+edx*4+8] ; sum += nonStaticField[i];
1a inc  edx                         ; i++
1b cmp  edx,3E8h                    ; if i &amp;lt; 1000 then
21 jl   00000012                    ; loop by i
23 inc  ebx                         ; iteration++
24 cmp  ebx,0F4240h                 ; if iteration &amp;lt; 1000000 then
2a jl   0000000A                    ; loop by iteration
2c mov  eax,edi                     ; eax = sum (Result)
2e pop  ebx 
2f pop  esi 
30 pop  edi 
31 pop  ebp 
32 ret 
33 call 63495C4D                    ; IndexOutOfRangeException
38 int  3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;StaticRun-x86.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push ebp 
01 mov  ebp,esp 
03 push edi 
04 push esi 
05 push ebx 
06 xor  edi,edi                      ; sum = 0
08 xor  ebx,ebx                      ; iteration = 0
0a xor  eax,eax                      ; i = 0
0c mov  edx,dword ptr ds:[03943380h] ; edx = &amp;amp;staticField
12 mov  esi,dword ptr [edx+4]        ; esi = staticField.Length 
15 cmp  eax,esi                      ; if i &amp;gt;= staticField.Length then
17 jae  00000035                     ; throw IndexOutOfRangeException
19 add  edi,dword ptr [edx+eax*4+8]  ; sum += staticField[i];
1d inc  eax                          ; i++
1e cmp  eax,3E8h                     ; if i &amp;lt; 1000 then
23 jl   00000015                     ; loop by i
25 inc  ebx                          ; iteration++
26 cmp  ebx,0F4240h                  ; if iteration &amp;lt; 1000000 then
2c jl   0000000A                     ; loop by iteration
2e mov  eax,edi                      ; eax = sum (Result)
30 pop  ebx 
31 pop  esi 
32 pop  edi 
33 pop  ebp 
34 ret 
35 call 639E52D5                     ; IndexOutOfRangeException
3a int  3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Из этого кода становится понятно, что разнице во времени взяться неоткуда: методы отличаются только в одной строчке, в которой берётся адрес интересующего нас массива. В обоих случаях используется команда &lt;code&gt;move&lt;/code&gt; , просто её аргументы разнятся, это не должно сказаться на производительности.&lt;/p&gt;
&lt;p&gt;Теперь поменяем платформу на x64 и запустим бенчмарк:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static : 347ms
Static     : 533ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Любопытно: в обоих случаях быстродействие значительно возросло, но только в случае статичного поля оптимизация вышла &#171;слабее&#187;. В чём же дело? Обратимся опять к машинному коду:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NonStaticRun-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 sub  rsp,28h
04 mov  r8,rcx
07 xor  ecx,ecx
09 mov  edx,ecx                      ; sum = 0
0b nop  dword ptr [rax+rax]
10 xor  r10d,r10d                    ; i = 0
13 mov  r9,qword ptr [r8+8]          ; r9 = &amp;amp;nonStaticField
17 mov  rax,qword ptr [r9+8]         ; rax = nonStaticField.Length
1b mov  r11d,3E4h                    ; r11 = 996
21 cmp  r11,rax                      ; if r11 &amp;gt;= nonStaticField.Length then
24 jae  000000000000008A             ; throw IndexOutOfRangeException
26 mov  r11d,3E5h                    ; r11 = 997
2c cmp  r11,rax                      ; if r11 &amp;gt;= nonStaticField.Length then
2f jae  000000000000008A             ; throw IndexOutOfRangeException
31 mov  r11d,3E6h                    ; r11 = 998
37 cmp  r11,rax                      ; if r11 &amp;gt;= nonStaticField.Length then
3a jae  000000000000008A             ; throw IndexOutOfRangeException
3c mov  r11d,3E7h                    ; r11 = 999
42 cmp  r11,rax                      ; if r11 &amp;gt;= nonStaticField.Length then
45 jae  000000000000008A             ; throw IndexOutOfRangeException
47 nop  word ptr [rax+rax+00000000h]
50 mov  eax,dword ptr [r9+r10+10h]   ; eax = nonStaticField[i]
55 add  edx,eax                      ; sum += eax
57 mov  eax,dword ptr [r9+r10+14h]   ; eax = nonStaticField[i+1]
5c add  edx,eax                      ; sum += eax
5e mov  eax,dword ptr [r9+r10+18h]   ; eax = nonStaticField[i+2]
63 add  edx,eax                      ; sum += eax
65 mov  eax,dword ptr [r9+r10+1Ch]   ; eax = nonStaticField[i+3]
6a add  edx,eax                      ; sum += eax
6c add  r10,10h                      ; i += 4
70 cmp  r10,0FA0h                    ; if i &amp;lt; 1000 then
77 jl   0000000000000050             ; loop by i
79 inc  ecx                          ; iteration++
7b cmp  ecx,0F4240h                  ; if iteration &amp;lt; 1000000  then
81 jl   0000000000000010             ; loop by iteration
83 mov  eax,edx                      ; eax = sum (Result)
85 add  rsp,28h
89 ret   
8a call 000000005FA4AE14             ; IndexOutOfRangeException
8f nop 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот пример намного интересней! Вспомним, что в x86 нам доступно только 8 регистров по 32 бита (EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, R8D), а в x64 доступно 16 регистров по 64 бита (RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI, R8 — R15). Увеличение количества регистров позволило произвести JIT-оптимизацию &#171;размотка цикла&#187; (см.
&lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_unwinding&quot;&gt;Loop unwinding&lt;/a&gt;). При этом важную роль играет то обстоятельство, что количество итераций в каждом из циклов кратно четвёрке. Мы ещё вернёмся к этому моменту, а пока взглянем на static-версию.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StaticRun-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 sub  rsp,28h 
04 xor  ecx,ecx                       ; iteration = 0
06 mov  edx,ecx                       ; sum = 0
08 nop  dword ptr [rax+rax+00000000h] 
10 xor  r8d,r8d                       ; i = 0
13 mov  r9,12D756F0h                  ; r9 = staticField
1d mov  r9,qword ptr [r9]             ; r9 = &amp;amp;staticField
20 mov  r10,qword ptr [r9+8]          ; r10 = staticField.Length
24 cmp  r8,r10                        ; if r8 &amp;gt;= staticField.Length then
27 jae  0000000000000080              ; throw IndexOutOfRangeException
29 mov  eax,dword ptr [r9+r8*4+10h]   ; eax = staticField[i]
2e add  edx,eax                       ; sum += eax
30 lea  rax,[r8+1]                    ; rax = i+1
34 cmp  rax,r10                       ; if rax &amp;gt;= staticField.Length then
37 jae  0000000000000080              ; throw IndexOutOfRangeException
39 mov  eax,dword ptr [r9+rax*4+10h]  ; eax = staticField[i+1]
3e add  edx,eax                       ; sum += eax
40 lea  rax,[r8+2]                    ; rax = i+2
44 cmp  rax,r10                       ; if rax &amp;gt;= staticField.Length then
47 jae  0000000000000080              ; throw IndexOutOfRangeException
49 mov  eax,dword ptr [r9+rax*4+10h]  ; eax = staticField[i+2]
4e add  edx,eax                       ; sum += eax
50 lea  rax,[r8+3]                    ; rax = i+3
54 cmp  rax,r10                       ; if rax &amp;gt;= staticField.Length then
57 jae  0000000000000080              ; throw IndexOutOfRangeException
59 mov  eax,dword ptr [r9+rax*4+10h]  ; eax = staticField[i+3]
5e add  edx,eax                       ; sum += eax
60 add  r8,4                          ; i += 4
64 cmp  r8,3E8h                       ; if i &amp;lt; 1000 then
6b jl   0000000000000013              ; loop by i
6d inc  ecx                           ; iteration++
6f cmp  ecx,0F4240h                   ; if iteration &amp;lt; 1000000 then
75 jl   0000000000000010              ; loop by iteration
77 mov  eax,edx                       ; eax = sum (result)
79 add  rsp,28h 
7d ret     
7e xchg ax,ax 
80 call 000000005FA49F64              ; IndexOutOfRangeException
85 nop   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Из примера видно, что для статичного массива оптимизация размотки цикла прошла несколько иначе. Причём, если в методе &lt;code&gt;StaticRun&lt;/code&gt; сохранить ссылку на статический массив в локальную переменную и итерировать по ней, то машинный код будет аналогичен примеру NonStaticRun-x64.asm, а производительность обоих методов станет одинаковой. В текущей версии static-версия &#171;проседает&#187; по скорости из-за следующих обстоятельств:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Вместо того, чтобы явно хранить смещения элементов, хранится индекс, который в момент вычисления адреса умножается на 4 для получения смещения.&lt;/li&gt;
&lt;li&gt;Вычисление адресов элементов [i+1], [i+2], [i+3] происходит в регистрах вместо того, чтобы использовать константные смещения в 4h, 8h, bh, относительно элемента [i].&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Теперь попробуем изменить длину массива, чтобы она больше не делилась на 4: N = 1001. Результаты бенчмарка:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static : 550ms
Static     : 719ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Static-версия по скорости &#171;вернулась&#187; к результату без оптимизации, который мы видели в x86-версии. В NonStatic-версии результат интереснее: текущая версия работает медленнее, чем для N=1000, но быстрее, чем для x86. Опять обратимся к машинному коду, чтобы разобраться:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NonStaticRun-x64-1001.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 sub  rsp,28h 
04 mov  r9,rcx 
07 xor  ecx,ecx 
09 mov  edx,ecx 
0b nop  dword ptr [rax+rax] 
10 xor  r8d,r8d 
13 mov  r10,qword ptr [r9+8] 
17 mov  rax,qword ptr [r10+8] 
1b mov  r11d,3E8h 
21 cmp  r11,rax 
24 jae  0000000000000055 
26 nop  word ptr [rax+rax+00000000h] 
30 mov  eax,dword ptr [r10+r8+10h] 
35 add  edx,eax 
37 add  r8,4 
3b cmp  r8,0FA4h 
42 jl   0000000000000030 
44 inc  ecx 
46 cmp  ecx,0F4240h 
4c jl   0000000000000010 
4e mov  eax,edx 
50 add  rsp,28h 
54 ret    
55 call 000000005FA5AE14 
5a nop    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;StaticRun-x64-1001.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 sub  rsp,28h 
04 xor  ecx,ecx 
06 mov  edx,ecx 
08 nop  dword ptr [rax+rax+00000000h] 
10 xor  r8d,r8d 
13 mov  r9,12B556F0h 
1d mov  r9,qword ptr [r9] 
20 mov  rax,qword ptr [r9+8] 
24 cmp  r8,rax 
27 jae  0000000000000050 
29 mov  eax,dword ptr [r9+r8*4+10h] 
2e add  edx,eax 
30 inc  r8 
33 cmp  r8,3E9h 
3a jl   0000000000000013 
3c inc  ecx 
3e cmp  ecx,0F4240h 
44 jl   0000000000000010 
46 mov  eax,edx 
48 add  rsp,28h 
4c ret   
4d nop  dword ptr [rax] 
50 call 000000005FA69FA4 
55 nop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Из примеров можно заметить, что в методах NonStaticRun-x86, StaticRun-x86, StaticRun-x64-1001 для вычисления очередного элемента массива используется формула:
&lt;code&gt;BaseAddress + i * 4 + 10h&lt;/code&gt;, а в методе NonStaticRun: &lt;code&gt;BaseAddress + offset + 10h&lt;/code&gt;, где &lt;code&gt;offset = i * 4&lt;/code&gt; — уже готовое смещение. Этим и объясняется разница в скорости.&lt;/p&gt;
&lt;p&gt;Данную тему можно изучать ещё очень долго: пробовать менять конфигурацию сборки, пробовать различные длины массивов и т.п. Но я ограничусь формулировкой основного вывода.&lt;/p&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Скорость итерирования может значительно зависеть от следующих обстоятельств:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Тип ссылки на массив: статичное поле или обычное поле/локальная переменная&lt;/li&gt;
&lt;li&gt;Используемая архитектура процессора&lt;/li&gt;
&lt;li&gt;Делимость количества элементов на степени двойки&lt;/li&gt;
&lt;li&gt;Версия CLR&lt;/li&gt;
&lt;li&gt;Фаза луны&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Всем хороших бенчмарков =)&lt;/p&gt;</description>
            </item>
            <item>
                <title>Совершенный код и реальные проекты</title>
                <link>http://aakinshin.net/ru/blog/dev/perfect-code-and-real-projects/</link> 	
                <pubDate>Tue, 27 Aug 2013 20:07:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dev/perfect-code-and-real-projects/</guid>
                <description>&lt;p&gt;У меня есть проблема — я перфекционист. Я люблю совершенный код. Ведь это не только правильный подход к написанию программ, но и настоящее искусство. От чтения хорошего листинга я получаю не меньше удовольствия, чем от чтения хорошей книги. Проектировать архитектуру большого проекта ничуть не легче, чем проектировать архитектуру большого здания, а в случае хорошей работы — результат не менее прекрасен. Порой меня завораживает то, как изящно переплелись паттерны проектирования в создании совершенной программной системы. Меня восхищает внимание к деталям, когда абсолютно каждый метод настолько прост и понятен, что претендует на место классического примера совершенного кода.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dev/perfect-code-and-real-projects/front.png&quot; height=&quot;200px&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Но, увы, всё это великолепие разбивается о суровую действительность и реальные проекты. Если мы говорим о продакшн-проекте, то пользователей не волнует, насколько красив ваш код и насколько хороша архитектура, их волнует, чтобы проект хорошо работал. Но я всё равно считаю, что в любом случае нужно стремиться писать правильно, просто при этом фанатизма быть не должно. После чтения различных холиваров на тему правильных подходов к написанию кода мне в глаза бросилась одна тенденция: каждый пытается применить означенные подходы не в целом к программированию, а только к своему опыту разработки, к своим проектам. Многие не осознают, что хорошие практики — это не абсолютные правила, которые должны строго соблюдаться в 100% сценариев, это лишь советы о том, как следовало бы поступать в большинстве ситуаций. На каждую хорошую практику всегда можно придумать несколько дюжин примеров, в которых она работать не будет. Но это вовсе не означает, что хорошая практика не такая уж и хорошая, просто её применили не к месту.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Есть и другая проблема — некоторые программисты не настолько хороши, как им кажется. Часто приходится видеть такую ситуацию: подобный разработчик увидел в большой статье про совершенный код какое-то одно соображение (не вникая в контекст) и начал его повсюду применять, отчего код этого разработчика стал значительно хуже. А потом приходится слышать: &lt;em&gt;&#171;вот начитаются тут статей про такие-то подходы, а потом начинают так-то писать&#187;&lt;/em&gt;. А может виноваты тут вовсе не статьи? Если некоторые программисты криво и не по месту применяют где-то услышанные хорошие практики, то это вовсе не значит, что правильные подходы к программированию не нужно обсуждать. Стремление писать хорошо — это похвально, но при этом нужно трезво оценивать свои способности. Для пилотов самолётов описано много манёвров из разряда &#171;высшего пилотажа&#187;, но это вовсе не значит, что каждый начинающий пилот должен все их попробовать в свой первый же полёт. Так и джуниор-программист после прочтения книги банды четырёх не должен в свой следующий проект лепить все несколько десятков паттернов, которые он теперь &#171;знает&#187;.&lt;/p&gt;
&lt;p&gt;Но вернёмся к обсуждению совершенного кода. Подходы к правильной разработке зависят от очень многих факторов: от целей, сроков, команды и т.п. Мне хотелось бы рассмотреть вместе с вами несколько типов проектов, которые резко отличаются друг от друга по своим задачам. Давайте вместе подумаем, насколько код должен быть чистым и насколько должна быть проработана архитектура в каждом из случаев. В одних проектах будут находится практики, которые в других проектах применять явно не уместно. Когда вы в следующий раз возмутитесь советами в очередной статье про программирование, то подумайте перед вступлением в холивар, а какие именно задачи были у автора. Может это не советы плохие, а просто проекты автора отличаются от ваших. Итак, приступим.&lt;/p&gt;
&lt;h2&gt;Размер проектов&lt;/h2&gt;
&lt;h3&gt;Маленькие проекты&lt;/h3&gt;
&lt;p&gt;Например, имеется 1 человек, который пишет проект несколько дней. Это какая-нибудь мелкая утилита для решения какой-нибудь небольшой отдельно взятой задачи. Скорее всего она не будет особо развиваться и превращаться в нечто большое. В таких проектах все элементы системы (а может и все переменные) можно удержать в уме. В таком проекте вам не нужна крутая архитектура: если появилась какая-то подзадача, которую можно решить костылём на две строчки, то лучше так и сделать. Конечно же, можно потратить пару дней на выработку сложной архитектуры, которую будет очень удобно использовать при появлении новых сложных подзадач. Но есть нюанс: эти подзадачи вряд ли появятся в маленьком проекте, а время уже будет потрачено. В данной ситуации не стоит особо заморачиваться на написании сверхчистого кода. Быдлокодить тоже не следует, просто старайтесь писать нормально.&lt;/p&gt;
&lt;h3&gt;Средние проекты&lt;/h3&gt;
&lt;p&gt;Допустим, у нас уже 5-6 человек и проект на несколько месяцев. Тут уже особо похалтурить не получится, нужно более или менее продумать систему, структурировать весь код. Лучше бы следить, чтобы костыли особо не накапливались. Можно потратить какое-то время на предварительный анализ и проектирование, но не сильно много. Это похвально, если до дедлайна вы успеете составить идеальный план построения идеальной системы, но лучше бы вы успели написать не особо идеальную, но работающую систему. На худой конец, если всё пошло не так, то за несколько дней совместными усилиями не так уж и сложно всю архитектуру переделать. ( &lt;i&gt;Мне приходилось несколько раз поступать подобным образом, это не так страшно.&lt;/i&gt;
) Если это, скажем, проект на заказ, то заказчик будет вам платить не за чудесный код, а за рабочий функционал, реализованный в срок. Не стоит об этом забывать.&lt;/p&gt;
&lt;h3&gt;Большие проекты&lt;/h3&gt;
&lt;p&gt;А теперь у нас несколько десятков человек, а проект будет писаться несколько лет. Вот тут бы лучше бы нам очень хорошо продумать архитектуру с самого начала. И если появилась потребность вставить костыль, то, возможно, стоит на ранних этапах переделать архитектуру так, чтобы новая функциональность красиво в неё вписалась. Каждая халтура, сделанная сейчас, обернётся ужасными страданиями через год-другой. Читайте книги про чистый код и правильную архитектуру — там много советов, которые вам пригодятся. Только их нужно применять по месту, а не везде подряд.&lt;/p&gt;
&lt;p&gt;Мне очень нравится байка из &lt;a href=&quot;http://www.ozon.ru/context/detail/id/1308678/&quot;&gt;книжки Мартина Фаулера&lt;/a&gt;: Фаулер занимался консультированием одной фирмы по разработке достаточно большого проекта. Проект был написан ужасно, и Мартин настоял на небольшом рефакторинге. После пары дней работы удалось удалить половину кода без какого-либо ущерба для функциональности системы. Программисты очень радовались, а вот начальство не было довольно — ведь эта работа не привела к появлению нового функционала. Старый код прекрасно работал, деятельность по его &#171;чистке&#187; не казалась экономически оправданной. Поэтому дальнейшим консультационным советам руководство не вняло, настаивая на скорейшем появлении нового функционала без какой-либо дополнительной работы над кодом. Через полгода проект закрылся, т.к. код стал слишком сложным для поддержки.&lt;/p&gt;
&lt;h2&gt;Поддержка проекта&lt;/h2&gt;
&lt;h3&gt;Проекты без поддержки&lt;/h3&gt;
&lt;p&gt;Деятельность, хорошая знакомая различным фрилансерам и аутсорсерам. После сдачи проекта вам больше никогда не придётся вспоминать про весь этот ужас, который таится под капотом. В глубине души вы надеетесь, что проектом будут просто пользоваться, а исходники никто никогда открывать не будет. И это допустимый подход, ведь от нас требуется не замечательный код, а рабочее приложение. В начале проекта вы ещё можете позволить себе попроектировать архитектуру, пописать чистый код, но когда до дедлайна останется два дня, а функционал реализован лишь наполовину, то тут не до высоких материй. Позволительно вбивать любые костыли, нарушать мыслимые и немыслимые подходы к хорошему коду. И в данном случае это нормально. Я не говорю, что это хорошо, я не агитирую всех всегда так поступать. Но это нормально. Тут не идёт речь о программировании, как об искусстве, тут идёт речь о проекте, который нужно сдать в срок и не нужно поддерживать. Если вы начнёте писать всё идеальным образом, то вы просто рискуете не уложиться в сроки — вы подведёте заказчика, не получите денег, потратите своё время, а код всё равно окажется никому не нужным. Всегда помните о своих непосредственных целях.&lt;/p&gt;
&lt;h3&gt;Проекты с поддержкой&lt;/h3&gt;
&lt;p&gt;А вот тут я бы постарался писать нормально. Чтобы и архитектура нормальная была, и код был бы чистенький. Это такое прекрасное ощущение, когда заказчик просит добавить какую-нибудь нетривиальную функциональность, а вы справляетесь с задачей за час — ведь новый код добавить легко, ведь прекрасно ложится на существующую архитектуру. С уже готовой кодовой базой очень легко работать, код весьма понятен, в нём просто ориентироваться. А есть и другое ощущение, когда заказчик просит сделать какую-нибудь мелочь (а заказчику-то безумно очевидно, что это действительно мелочь, сделать её должно быть очень-очень просто), а вы смотрите на сложившуюся какофонию классов, прикидываете сколько дней нужно потратить на эту мелочь, но к клавиатуре прикасаться уже почему-то не хочется. Да и смотреть на этот код просто противно.&lt;/p&gt;
&lt;h2&gt;Масштаб проекта&lt;/h2&gt;
&lt;h3&gt;Внутренние проекты&lt;/h3&gt;
&lt;p&gt;Вы пишете проект для себя или своей команды, не собираясь его никому показывать. В этом случае вам позволено очень много вольностей. Никто, конечно, не заставляет вас отклоняться от идеалов к подходам разработки ПО, но если очень хочется, то можно — ничего предосудительного в этом нет. Нет нужды разрабатывать грамотную документацию, комментарии можно писать на родном языке (если его понимают все вовлечённые в разработку лица), а какие-то нетривиальные архитектурные решения (совсем не очевидные из кода) можно на словах объяснить товарищам по команде. Я не говорю, что обязательно нужно так делать. Но если, скажем, вы куда-то очень торопитесь, то некоторыми хорошими практиками можно пренебречь.&lt;/p&gt;
&lt;h3&gt;Публичные проекты&lt;/h3&gt;
&lt;p&gt;Тут у нас уже совсем другая ситуация. Лучше бы вам нормально документировать ваш проект, чтобы по нему не возникало каждый день по сотне вопросов от ваших любимых пользователей. И лучше бы писать документацию на английском (как, впрочем, и комментарии). Да и код лучше бы писать почище, чтобы человеку со стороны было легко в нём разобраться. Если же у вас есть API, то хорошо бы его &lt;em&gt;продумать&lt;/em&gt;, а не просто налепить какой-то интерфейс, из которого при большом желании как-то можно вытащить все нужные данные. Помните, что проект принадлежит уже не только вам, но и сторонним программистам — уважайте тех, кто будет работать с вашим кодом. Пишите программу так, чтобы вас потом не хотели поймать в тёмной подворотне и сделать с вами плохие вещи.&lt;/p&gt;
&lt;h2&gt;Проекты со спецификой&lt;/h2&gt;
&lt;h3&gt;Проекты с высокой нагрузкой&lt;/h3&gt;
&lt;p&gt;Highload — это отдельный разговор. На практике в жертву высокой производительности приходится приносить очень многое, включая хорошую архитектуру и читаемый код. Порой хочется плакать кровавыми слезами, глядя на то, во что превратился ваш уютненький проект после оптимизации. Но что поделать? Зато время работы программы сократилось вдвое. Порой выбирать особо не приходится.&lt;/p&gt;
&lt;h3&gt;Проекты с использованием сторонних библиотек&lt;/h3&gt;
&lt;p&gt;Когда я начинаю говорить о сторонних библиотеках, то некоторые мои коллеги начинают смотреть на меня понимающим взглядом. И я вижу по их лицам — они испытали те же страдания, что и я. В реальных условиях большого проекта вы редко будете писать сами абсолютно весь функционал. Обычно попадаются весьма распространённые задачи, которые уже кто-то решал. В данной ситуации намного разумней будет взять готовое решение, чем самому изобретать велосипед. Так-то оно так, но порой оказывается, что авторы этого готового решения не очень хорошие программисты. Их проект справляется со своей основной задачей, но написан он... Ну, не совсем профессионально. И интегрировать его в ваш проект... Ну, несколько сложновато. Это обстоятельство в очередной раз заставляет вас писать ужасные костыли, уродующие вашу милую архитектуру. Но это очередная производственная необходимость, ведь реализовывать этот функционал самостоятельно зачастую бывает нерентабельно. (&lt;em&gt;Скажу по секрету, несколько раз я не выдерживал и писал свою библиотеку вместо сторонней. Но это скорее исключение, чем правило.&lt;/em&gt;)&lt;/p&gt;
&lt;h3&gt;Проект команды новичков&lt;/h3&gt;
&lt;p&gt;Часто можно слышать заявление, что любой средний разработчик должен знать то, сё и это. Предполагается, что разработчик неплохо владеет языком (скажем, если речь идёт об ООП-языке, то нужно хотя бы знать что такое полиморфизм и наследование), может без проблем воспринимать сложные синтаксические конструкции, понимает основные механизмы платформы, знает элементарные паттерны проектирования (увидев класс с названием Visitor он сразу поймёт определённый фрагмент системы), легко читает комментарии на английском и ещё много чего умеет. Но до становления хотя бы средним разработчиком все в своё время были новичками. И на сегодняшний день в мире программирования существует много людей, которые только начинают постигать это ремесло. Вполне нормально, что они не знают и не умеют многих вещей. Вполне нормальна ситуация, когда собираются несколько начинающих программистов и пишут небольшой проект. В процессе разработки они многому научатся. Разумеется, они будут делать многие вещи не совсем правильно. Но от них и не стоит этого ожидать. Хорошо бы, чтобы старшие коллеги подсказывали разные моменты: как переписать код получше, какие книжки почитать. Но именно предъявлять к ним требования наравне с сеньорами не следует. В проекте новичков позволительны очень многие отступления от того &#171;как надо&#187;, ведь они только учатся. Советы и рекомендации — это хорошо, а требование написать с первого раза идеальную архитектуру с идеально чистым кодом — это не совсем хорошо.&lt;/p&gt;
&lt;h2&gt;Не-продакшн проекты&lt;/h2&gt;
&lt;h3&gt;Демонстрационные проекты&lt;/h3&gt;
&lt;p&gt;Порой мне приходится писать демо-проекты, чтобы показать своим коллегам какие-то клёвые штуки. Это может быть язык, движок, библиотека или ещё что-нибудь, с чем эти люди до этого никогда не сталкивались. Как правило, демо-проект приходится писать очень подробно и просто, обильно снабжая код комментариями. В некоторых отдельных случаях на одну строчку кода может приходиться несколько десятков строк комментариев — и это нормально. Вы не пишите совершенный проект, вы просто используете код, как иллюстрацию. А сам код при этом может быть очень кривым и долго работать, но всё это неважно — ведь у нас другие цели, заключающиеся в демонстрации публике некоторой технологии.&lt;/p&gt;
&lt;h3&gt;Академические проекты&lt;/h3&gt;
&lt;p&gt;В этом проекте мы уже особо ничего никому не показываем, а сами разбираемся с какой-нибудь интересной штукой. Скажем, изучаем какой-нибудь алгоритм. Вполне нормально написать рядышком 10 версий алгоритма. Возможно, версии будут на разных языках. Вполне нормально будет наплевать на соглашения об именованиях (которые хорошо бы соблюдать при разработки реального проекта) и назвать одинаковые вещи одинаковыми именами — такими, которые указаны в книжке. Да какая разница как там в каком языке принято писать? Мы тут с алгоритмом разбираемся, сейчас нас не должны волновать такие вещи. Если вы собираетесь показывать кому-то результат, то тут над кодом можно уже поработать, но это будет совсем другая история. А пока вы находитесь в стадии изучения, ваша основная цель — это именно изучение, а не написание совершенного кода. Конечно, эти вещи можно совместить, можно постараться написать самую идеальную реализацию алгоритма, но это вовсе не обязательно. Главное — не подменять основную академическую цель целью совершенного кода.&lt;/p&gt;
&lt;h3&gt;Локальные проекты&lt;/h3&gt;
&lt;p&gt;Ну, многие скажут, что нужно сразу привыкать везде писать правильно. Но локальный код обладает своей спецификой — его не нужно никому показывать, нет нужды ни перед кем отчитываться, можно руководствоваться какими-то своими соображениями при разработке. Во время рабочего процесса может возникать много промежуточного плохого кода. Можно поиграться с платформой, провести несколько экспериментов. Можно вести разработку так, как нам удобно. Скажем, можно сделать какой-нибудь дамп данных, не считаясь с общей архитектурой, просто сделав сохранение в локальный файл из самого неподходящего места. В процессе работы можно писать любое количество комментариев на любом языке — если так нам удобней работать.&lt;/p&gt;
&lt;p&gt;Но помните, что ситуация совершенно меняется, когда творческий процесс заканчивается и нужно будет показать свои результаты другим (скажем, отправить локальные наработки в центральный репозиторий). Перед этим код обязательно нужно &#171;причесать&#187;. Все наши эксперименты, костыли и лишние комментарии нужно убрать, оставшийся код сделать максимально понятным и читаемым. Уважайте тех, кто будет разбираться с вашей писаниной.&lt;/p&gt;
&lt;h3&gt;Проекты-прототипы&lt;/h3&gt;
&lt;p&gt;Задача таких проектов — по-быстрому накидать определённую функциональность, чтобы стало более понятно, как она будет выглядеть. Это весьма разумный подход. Скажем, есть у нас штук 5 вариантов реализации: мы пробуем кратко накидать общий концепт каждого варианта. После этого можно посмотреть все подходы на живых примерах и выбрать тот, на основе которого будет строится основной проект. Очень важно правильно понимать задачи прототипирования. Вам не нужно вычитывать такой код, вам не нужно пытаться написать его идеально. Меня всегда печалят люди, которые ругаются на прототип с заявлениями вида &lt;em&gt;&#171;вот эту переменную можно назвать немного понятнее&#187;&lt;/em&gt; или &lt;em&gt;&#171;а вот эту кнопку в интерфейсе хорошо бы подвинуть на 1 пиксель влево&#187;&lt;/em&gt;. Да какая тебе разница, как там переменная названа, это прототип, отстань от него. Такие обсуждения можно проводить уже на готовом проекте, но на уровне прототипа это делать бессмысленно.&lt;/p&gt;
&lt;h3&gt;Увеселительные проекты&lt;/h3&gt;
&lt;p&gt;Помню, как-то раз, мы с друзьями решили сделать одному хорошему человеку подарок на день рождения. Мы сделали Java-проект, который в ООП-виде представлял его жизнь, его друзей и разные интересности, с которыми он взаимодействует. Причём программа действительно работала, из консоли можно было выполнять разные весёлые команды. Что касается исходного кода, то абсолютно все именования (классы, методы, переменные и т.п.) были написаны на русском (добрая Java позволяет так делать). Javadoc был также написан на русском и не нёс в себе никакой полезной информации. Логика была реализована самым простым способом. Вместо быстрых сложных алгоритмов мы использовали самые простые. Архитектура была не особо красива, ведь мы её даже не пытались продумывать.&lt;/p&gt;
&lt;p&gt;А подарок удался, хоть мы и не использовали ни одной хорошей практики по написанию совершенного кода. А всё дело в том, что цели у проекта были совершенно иные.&lt;/p&gt;
&lt;h2&gt;Резюме&lt;/h2&gt;
&lt;p&gt;Хотелось бы ещё раз зафиксировать ваше внимание на некоторых основных мыслях. Если вы хотите стать хорошим программистом, то вы постоянно должны развиваться, учиться писать лучше, расти над собой. Вы всегда должны стараться писать максимально чисто и хорошо. Но нужно понимать, что в большом проекте у вас код никогда не будет совершенным. С говнокодом не следует мириться, пишите так, чтобы вам не было стыдно. Но при этом не следует забывать о целях вашего текущего проекта, ведь стремление к совершенному коду в большинстве случаев — это не цель, а только способ её достижения. Намеренно быдлокодить, правда, не нужно, старайтесь всегда писать грамотно, но особого фанатизма тоже проявлять не следует. Помните о своих целях, помните о ситуации, в которой вы находитесь. Написать совершенный код — не так просто. Соизмеряйте усилия на улучшение кода и эффект, который эти улучшения дадут. Если вы прочитали какую-то статью про хороший код, то не нужно вырывать отдельные советы, которые вы всюду ринетесь принимать без лишних раздумий. Обращайте внимание на контекст, в котором эти советы приводятся. Думайте, о какой именно ситуации идёт речь. Думайте, в каких случаях уместно применять известные хорошие в практики, а в каких — не очень. Да и вообще, побольше думайте, в программировании это полезно. И всё у вас будет хорошо.&lt;/p&gt;
&lt;h2&gt;Кросс-посты&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/topic/edit/183360/&quot;&gt;Хабрахабр&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Комментировать или не комментировать?</title>
                <link>http://aakinshin.net/ru/blog/dev/comments/</link> 	
                <pubDate>Tue, 27 Aug 2013 20:04:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dev/comments/</guid>
                <description>&lt;p&gt;&lt;em&gt;По-настоящему хороший комментарий — тот, без которого вам удалось обойтись. &#169; Дядюшка Боб&lt;/em&gt;&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dev/refactoring/front.png&quot; height=&quot;250px&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;В последнее время меня стали очень утомлять оживлённые дебаты о том, нужно ли комментировать код. Как правило, по одну сторону баррикад — самоуверенные джуниоры, имеющие непререкаемую позицию вида &lt;em&gt;&#171;А как же его не комментировать, ведь без комментариев непонятно будет!&#187;&lt;/em&gt;. По другую — умудрённые опытом сеньоры. Они понимают, что если возможно обойтись без комментариев, то &lt;em&gt;&#171;Лучше бы, чёрт возьми, так и сделать!&#187;&lt;/em&gt;. Наверное, у многих жажда комментировать идёт со студенческой скамьи, когда товарищи преподаватели заставляли комментировать каждую строчку,
&lt;em&gt;&#171;чтобы студент лучше разобрался&#187;&lt;/em&gt;. В реальном проекте не должно быть кучи комментариев, которые только и делают, что засоряют код. Впрочем, я не агитирую вообще не писать комментарии, но если вам удалось написать такой код, который не требует пояснений, то расценивайте это, как свою маленькую победу. Сразу хотелось бы сослаться на нескольких очень умных книжек, на основе которых формировалась моя позиция. Я люблю и уважаю авторов этих работ, полностью разделяя их мнение.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ozon.ru/context/detail/id/5508646/&quot;&gt;С. Макконнелл, &#171;Совершенный код. Мастер-класс&#187;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ozon.ru/context/detail/id/20216991/&quot;&gt;Р. Мартин, &#171;Чистый код. Создание, анализ и рефакторинг&#187;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ozon.ru/context/detail/id/8466390/&quot;&gt;Д. Босуэлл, Т. Фаучер, &#171;Читаемый код, или Программирование как искусство&#187;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt;Итак, что же меня так раздражает в комментариях? Приведу несколько основных тезисов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Комментарии захламляют непосредственный код, ухудшают его читаемость&lt;/li&gt;
&lt;li&gt;Комментарии требуют время на написание и поддержку&lt;/li&gt;
&lt;li&gt;Комментарии лгут (начинаем от криво написанных, заканчиваем устаревшими)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В принципе, я согласен с тем, что в некоторых случаях комментарии всё-таки нужны. Но ваш код будет тем прекраснее, чем будет меньше таких случаев. Кроме того, написание хорошего комментария — это тоже искусство. Увы, им обладают не так много программистов, большинство пишут комментарии абы как. Польза от этого зачастую сомнительная. А чем тратить время и силы на написание хорошего грамотного комментария, не лучше ли потратиться на переписывание кода, чтобы он больше не требовал комментария?&lt;/p&gt;
&lt;p&gt;Давайте обсудим некоторые типичные сценарии, в которых можно сказать что-нибудь определённое про надобность комментария. Примеры кода я привожу на C#, но для данной темы это не принципиально.&lt;/p&gt;
&lt;h2&gt;Когда без комментариев можно обойтись&lt;/h2&gt;
&lt;h3&gt;Комментарии, которые повторяют код&lt;/h3&gt;
&lt;p&gt;Давайте взглянем на код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Этот метод отвечает за подсчёт суммы элементов массива
public int CalcSumOfElement(int[] elements) // Метод принимает на вход массив элементов
{
  int result = 0; // Заводим специальную переменную под результат
  int n = elements.Length; // Узнаём длину массива, т.е. количество элементов
  for (int i = 0; i &amp;lt; n; i++) // Запускаем цикл по всем элементам
    result += elements[i]; // Прибавляем к результату очередной элемент
  return result; // Возвращаем результат
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот пример, конечно, искусственный, но, увы, я не утрирую. Я действительно не раз встречал подобный код. В данном примере комментарии не несут нам ничего нового — абсолютно всё и так понятно из кода. Но при этом прочитать этот код без захламляющего комментирования намного проще. Я уж не говорю про развитие кода: поддерживать такой уровень комментирования очень утомительно. Скорее всего при усложнении функционала половина кода останется вообще без комментариев, а другая — с кривыми устаревшими комментариями.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые поясняют синтаксис&lt;/h3&gt;
&lt;p&gt;Ну, а вот такой пример:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Item
{
  private int value; // Это приватное поле, извне оно не доступно

  // Это конструктор
  public Item(int twoValue)
  {
    value = twoValue &amp;gt;&amp;gt; 1; // Два знака больше означают побитовый сдвиг вправо
    // таким образом мы делим число на два
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если это лабораторная работа первокурсника, то всё нормально. А вот если это продакшн код, и ваши программисты нуждаются  в таких комментариях, то у меня для вас плохие новости. Наверное, эта статья не для вас.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые поясняют стандартные классы&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;HashSet&amp;lt;int&amp;gt; set; // Это структура данных, которая называется Хеш-Сет
// Она представляет собой множество элементов
// Мы очень быстро можем узнать, есть ли элемент в этом множестве или нет
// Подробнее про хеш-таблицы можно почитать в википедии: http://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если программист действительно не знает назначение какого-то стандартного класса или метода, то он всегда может погуглить / почитать документацию / спросить у товарища. А большинство нормальных программистов скорее всего и так всё знает. Поэтому польза таких комментариев ну очень сомнительна.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые компенсируют плохие наименования&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Устанавливаем соединение с сервером
// public void DoIt()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Я согласен, что далеко не всегда удаётся придумать хорошее название для класса/метода/свойства/переменной. А если проект сдавать вчера, то времени на придумывание красивого названия просто нет. А давайте возьмём какое-нибудь произвольное название, а в комментарии объясним то, что происходит. Это же намного проще и быстрее! Или же всё-таки вы найдёте минутку-другую на придумывание понятного названия?&lt;/p&gt;
&lt;h3&gt;Комментарии, которые объясняют абзац&lt;/h3&gt;
&lt;p&gt;Часто приходится слышать подобные заявления: &lt;em&gt;&#171;Не, ну этот метод занимает 300 строк, он очень много всего делает. Без комментариев в нём не разобраться. Сейчас я напишу перед каждыми 10-строчками о том, что в них делается&#187;&lt;/em&gt;. Если действительно дела обстоят так, то, возможно, что-то вы делаете не так. Возможно стоит разбить большой 300-строчный метод на несколько маленьких методов. И каждому маленькому методу дать понятное название — тогда и комментарии будут не нужны.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые поясняют константы&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public int GetSeconds(int hours)
{
  return hours * 3600; // 3600 - это количество секунд, образующих час
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну, в таком варианте, наличие комментария — это более адекватный вариант, чем просто магическое число, которое закралось в код и непонятно что обозначает. Но ещё лучше бы было сделать именованную константу, из названия которой всё было бы понятно. Например, так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int SecondsInHour = 3600;
public int GetSeconds(int hours)
{
  return hours * SecondsInHour;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Комментарии, которые не относятся к программированию&lt;/h3&gt;
&lt;p&gt;Мне очень нравится байка из &#171;Совершенного кода&#187; про то, как один программист всю ночь пытался расшифровать вот такой комментарий.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;MOV AX, 723h ; R. I. P. L. V. В. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А несколько месяцев спустя он встретился с автором этого кода и узнал, что комментарий расшифровывается следующим образом: &#171;Rest in peace, Ludwig van Beethoven&#187;, т.к. 723 — это шестнадцатеричное представление года смерти Бетховена.&lt;/p&gt;
&lt;p&gt;Увы, некоторые программисты считают программный код своеобразным форумом, в котором можно общаться. Некоторые пытаются проявить своё остроумие (чуть ли не анекдоты рассказывают), другие пытаются нам что-то рассказать о себе (типа &lt;em&gt;&#171;Сейчас уже три часа ночи, но я всё равно пишу этот класс, ведь я так люблю программировать&#187;&lt;/em&gt;). Не нужно так делать, для общения есть сотни других способов. Если комментарий вставлен в код, то он должен нести в себе что-то полезное для проекта.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые содержат мысли&lt;/h3&gt;
&lt;p&gt;Бывает, что в комментарии содержатся очень умные мысли, от которых много проку. Но в большинстве случаев это совсем не так.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Main()
{
  // Ну, это очень полезный метод.
  // Он выполняет основную логику этого класса.
  // Сначала я хотел назвать его Run.
  // Но потом подумал, Run переводится &#171;бежать&#187;.
  // А этот метод никуда не бежит, он очень медленный.
  // Я думал об этом, пока мыл посуду.
  // И когда я её домыл, я вернулся к компьютеру и переименовал метод в Main.
  // Ведь это главный метод данного класса, пусть он называется Main.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Комментарии, которые содержат примеры использования&lt;/h3&gt;
&lt;p&gt;Иногда автор метода не уверен, что все правильно поймут, как пользоваться его методом. И тогда он приводит примеры использования, которые как бы говорят, что вернёт метод на определённых входных данных.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Sum(1, 2) == 3
// Sum(2, 1) == 3
// Sum(2, 2) == 4
public int Sum(int a, int b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А я так считаю — для каждой задачи должен быть свой инструмент. Для этой задачи люди давно придумали удобный инструмент, он называется Unit-тесты. Очень толковая штука. Нужны ли на самом деле Unit-тесты или нет — также дискуссионная тема. Но если в проекте всё-таки возникла потребность описать для метода примеры возвращаемых результатов, то почему бы просто не сделать соответствующий Unit-тест?&lt;/p&gt;
&lt;h3&gt;Комментарии, которые содержат историю написания&lt;/h3&gt;
&lt;p&gt;К счастью, давненько я подобного не видел, но иногда доводится встречать комментарии вида:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// 11.06.13: Исправил багу в методе. Раньше он работал так-то так-то, а теперь работает иначе. // 12.06.13: Ой, та бага — была не бага. Вернул всё обратно.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Повторю ещё раз свою мысль: для каждой задачи — свой инструмент. Системы контроля версий прекрасно умеют хранить историю изменений. Не нужно нагружать исходники никому не нужной историей того, как вы что писали. Если кого-то будет это интересовать, то он всегда может посмотреть в репозитории.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые содержат код&lt;/h3&gt;
&lt;p&gt;Эти комментарии меня особенно печалят. Читаешь, скажем, код какого-нибудь хорошего класса. И тут:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// int number = GetNumber()
// int number = 4;
// int number = 5;
int number = 4;
// double number = 4.5;
// decimal number = 4.5;
// string number = &amp;quot;Это число&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вот что этим хотел сказать автор? Некоторые авторы хотят этим сказать: я провожу эксперименты по изменению кода, но при этом не хочу терять старые версии этих строчек, вдруг к ним придётся вернуться. Этот тезис возвращает нас к мысли про репозиторий, который умеет хранить все промежуточные версии вашей писанины — никуда они не пропадут. Пожалейте других разработчиков, которые будут читать ваш код. А хуже всего, что этот код в проекте теперь надолго. Автор после кучки экспериментов забывает удалить плохие версии, а его коллеги опасаются бездумно удалять то, назначение чего непонятно: &lt;em&gt;&#171;я вот сейчас всё удалю, а потом окажется, что оно было ну очень нужно, тут был великий замысел, а я всё испортил&#187;.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Комментарии, которые непонятны&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;bool flagA = true;
bool flagB = false;
bool flagC = true;
if (Condition(flagA, flagB, flagC))
  Foo();
// else флаг равен true, выключение сервера
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В подобных случаях никогда нельзя догадаться что хотел сказать автор. Какой флаг равен true? Он всегда равен true в else-ветке или тут нужно дописать код, в котором нужно присвоить флагу значение true. А что за сервер, почему он выключается? Он выключится сам или нам нужно самим его выключить?&lt;/p&gt;
&lt;p&gt;От подобных комментариев вреда больше, чем пользы. Сведений он в себе по факту не несёт, а вместо этого только смущает читателя. Не смущайте читателя вашего кода! Или не пишите ничего вовсе, или потратьте время на написание доходчивого сообщения, которое всем будет понятно.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые содержат ну очень много текста&lt;/h3&gt;
&lt;p&gt;Некоторые комментаторы очень боятся быть непонятыми. Ну, или написать слишком мало. Поэтому комментарий к методу из трёх строчек может занимать несколько экранов. В этом обширном сочинении вы узнаете об используемых алгоритмах, их временной сложности, почитаете псевдокод метода, блок-схему в ASCII-графике, обоснование именования переменных, соображения общего характера. Причём всё будет расписано настолько подробно, чтобы даже первоклассник понял.&lt;/p&gt;
&lt;p&gt;Это плохой подход, он заставляет тратить читателя очень много времени на изучение вашего сочинения. Если вы уж решили писать комментарий, то вам следует озаботиться его лаконичностью (разумеется, не в ущерб понятности или информативности).&lt;/p&gt;
&lt;h3&gt;Комментарии, которые врут&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Произведение двух чисел
public int Sum(int a, int b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вы опять смущаете вашего читателя. Что тут происходит? Возможно, метод когда-то считал произведение, а потом его переделали в сумму, комментарий стал устаревшим. А может наоборот: комментарий обновили, а про название метода забыли. А может метод с самого начала считал сумму, а программист ошибся при комментировании. А метод может быть на самом деле очень сложный, придётся потратить много времени, чтобы разобраться, какая из черепашек обманывает.&lt;/p&gt;
&lt;h2&gt;Когда можно и прокомментировать&lt;/h2&gt;
&lt;h3&gt;Комментарии, которые повышают уровень абстракции&lt;/h3&gt;
&lt;p&gt;Предметная область может быть очень сложна, не всегда возможно подобрать краткие названия для классов, из которых сразу будет понятно, чему они соответствуют. Поэтому вполне нормально подобрать какой-нибудь ёмкий термин для обозначения сложной сущности предметной области. Основные программисты команды и так его наизусть знают, а вот для новичков можно составить краткий комментарий, из которого всё сразу станет понятно.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые объясняют необъяснимое&lt;/h3&gt;
&lt;p&gt;Увы, не всегда удаётся написать код, который понятен сам по себе. Возможно, используется очень хитрый алгоритм. Возможно, из-за требований к скорости пришлось написать быстрый, но не очень понятный код. Возможно, проект нужно сдавать вчера, и у вас просто нет времени &#171;причёсывать&#187; код. Не важно как, но в вашем проекте появился код, который ну очень трудно понять. Если с комментарием код становится более читаемым, то пусть этот комментарий действительно присутствует в проекте.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые TODO&lt;/h3&gt;
&lt;p&gt;Вопрос опять-таки дискуссионный. Одни скажут, что есть IssueTacker, давайте все задачи хранить там. Другие скажут, что зачем нам создавать много мелких Issue, когда можно просто расставить комментарии специального вида, которые будут обращать внимание разработчиков на то, что тут надо бы дописать функционал. Благо, современные IDE умеют находить все TODO-комментарии и выдавать их большим красивым списком, так что не нужно бояться потерять подобные инструкции на будущее. Нужно сразу договориться в команде о том, какая методология будет использоваться. Многие программисты считают TODO-комментарии очень удобными, ничего особо криминального в их использовании нет.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые обращают внимание&lt;/h3&gt;
&lt;p&gt;Иногда в коде появляются какие-то важные моменты, на которые обязательно нужно обратить внимание читателя, но средствами кода это сделать не удаётся. Например, нужно предупредить читателя, что метод выполняется очень долго. Или, класс сейчас активно разрабатывается и рефакторится несколькими людьми, в нём есть какой-то невзрачный кусок кода, который так и хочется удалить или переписать. Но лучше бы этого не делать, т.к. на самом деле он очень важный, без него всё сломается. В общем, если есть какие-то важные, но не особо очевидные аспекты вашего кода — можно и прокомментировать, лишним такой комментарий не назовёшь.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые документируют&lt;/h3&gt;
&lt;p&gt;Многие генерируют документацию на основе комментариев специального вида (такой подход используется во многих языках). Есть и другие инструменты по созданию документации без комментариев, но в силу разных обстоятельств в некоторых проектах принципиально использовать именно комментарии для документирования, тут уж никуда не деться. Но тут речь идёт скорее о публичном API, а не о private-методе во внутреннем проекте. В команде должна быть договорённость о том, когда и где будет использоваться подобный подход к документации. Ваше время очень ценно, не следует его тратить на создание такой документации, которая никогда никем не будет использоваться.&lt;/p&gt;
&lt;h3&gt;Комментарии, которые содержат юридическую информацию&lt;/h3&gt;
&lt;p&gt;В ряде проектов необходимо в каждый файл с кодом вставлять шапку-комментарий с информацией о копирайте, лицензии и т.п. Ну, если надо — то надо, обсуждения тут излишни.&lt;/p&gt;
&lt;h2&gt;Резюме&lt;/h2&gt;
&lt;p&gt;Ещё раз хотелось бы акцентировать внимание на основной мысли: хоть я и настаиваю на уменьшении количества комментариев, это вовсе не означает, что комментарии — абсолютное зло, которое никак не должно появляться в проекте. Если вы можете обосновать необходимость комментария в данном месте, если без него не обойтись, если вы можете его составить грамотно и лаконично — то пожалуйста, пишите комментарий, ведь вы делаете исходный код более информативным. Но, увы, в реальности большинство комментариев не несут в себе особой пользы, а лишь захламляют исходники. Если ваши руки потянулись к написанию ещё одного &lt;em&gt;отличного&lt;/em&gt; комментария, то сначала дайте себе немного времени на раздумье — а действительно ли этот комментарий такой &lt;em&gt;отличный&lt;/em&gt;, а нельзя ли без него как-нибудь обойтись.&lt;/p&gt;
&lt;p&gt;Хочется заметить, что в реальных условиях многое зависит от языка программирования, от проекта, от стадии разработки, от соглашений в команде. Возможно, конкретно в вашей ситуации есть необходимость писать много комментариев (это может быть сложный алгоритм, низкоуровневый код, хитрые оптимизации и т.п.). Возможно, вы сейчас пишете локальный код, а с комментариями вам намного удобнее работать над кодом (впрочем, никто не заставляет вас коммитить комментарии в общий репозиторий). Возможно, у вас весь проект на 100 строк, и намного проще поставить несколько комментариев, чем создавать сложную расширяемую архитектуру. В статье я изложил некоторые общие рекомендации для большого проекта на языке высокого уровня, которые могут в будущем избавить вас и ваших коллег от лишней головной боли. Но не нужно относится к предложенным практикам, как к абсолютным правилам: всегда нужно смотреть по ситуации — уместно ли поставить очередной комментарий, нужен ли он тут, или же лучше будет без него. Старайтесь уделять внимание таким моментам — и ваш код будет намного лучше.&lt;/p&gt;
&lt;h2&gt;Кросс-посты&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/182574/&quot;&gt;Хабрахабр&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Недокументированные ключевые слова C# или превращаем объект в тыкву</title>
                <link>http://aakinshin.net/ru/blog/dotnet/undocumented-keywords-in-cs/</link> 	
                <pubDate>Mon, 26 Aug 2013 18:51:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/undocumented-keywords-in-cs/</guid>
                <description>&lt;p&gt;Стандартный компилятор C# поддерживает 4 недокументированных ключевых слова: &lt;code&gt;__makeref&lt;/code&gt;, &lt;code&gt;__reftype&lt;/code&gt;, &lt;code&gt;__refvalue&lt;/code&gt;, &lt;code&gt;__arglist&lt;/code&gt;. Эти слова даже успешно распознаются в Visual Studio (хотя, ReSharper на них ругается). Они не даром исключены из стандарта — их использование может повлечь серьёзные проблемы с безопасностью. Поэтому не нужно их использовать везде подряд, но в отдельных исключительных случаях они могут пригодится. В этом посте я обсужу предназначение недокументированных команд, рассмотрю вопросы их производительности и научусь превращать объект в тыкву.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;Описание ключевых слов&lt;/h3&gt;
&lt;p&gt;Все рассматриваемые слова связаны со структурой &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.aspx&quot;&gt;TypedReference&lt;/a&gt;. Она хранит в себе два поля: указатель на область памяти и тип данных объекта, который расположен по этому указателю. Помимо рассмотренных ниже ключевых слов для операций над этой структурой могут пригодиться методы
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.gettargettype.aspx&quot;&gt;GetTargetType&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.maketypedreference.aspx&quot;&gt;MakeTypedReference&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.settypedreference.aspx&quot;&gt;SetTypedReference&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.targettypetoken.aspx&quot;&gt;TargetTypeToken&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.toobject.aspx&quot;&gt;ToObject&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Теперь перейдём непосредственно к ключевым словам. &lt;code&gt;__makeref&lt;/code&gt; принимает на входе объект и возвращает &lt;code&gt;TypedReference&lt;/code&gt; ссылку на него. &lt;code&gt;__reftype&lt;/code&gt; и &lt;code&gt;__refvalue&lt;/code&gt;
способны достать из &lt;code&gt;TypedReference&lt;/code&gt; значения двух его полей: тип и значение. Посмотрим простой пример, который поясняет использование ключевых слов:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double value = 10;
TypedReference typedReference = __makeref(value); // typedReference = &amp;amp;value;
Console.WriteLine( __refvalue(typedReference, double)); // 10
__refvalue(typedReference, double) = 11; // *typedReference = 11
Console.WriteLine( __refvalue(typedReference, double)); // 11
Type type = __reftype(typedReference); // value.GetType()
Console.WriteLine(type.Name); // Double
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Данный пример развернётся в IL-код, который представлен ниже. Как можно понять, рассмотренные ключевые слова транслируются в IL-команды &lt;code&gt;mkrefany&lt;/code&gt; , &lt;code&gt;refanyval&lt;/code&gt; ,
&lt;code&gt;refanytype&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.maxstack 2
.locals init (
    [0] float64 &#39;value&#39;,
    [1] valuetype [mscorlib]System.TypedReference typedReference,
    [2] class [mscorlib]System.Type &#39;type&#39;)
L_0000: ldc.r8 10
L_0009: stloc.0 
L_000a: ldloca.s &#39;value&#39;
L_000c: mkrefany float64
L_0011: stloc.1 
L_0012: ldloc.1 
L_0013: refanyval float64
L_0018: ldind.r8 
L_0019: call void [mscorlib]System.Console::WriteLine(float64)
L_001e: ldloc.1 
L_001f: refanyval float64
L_0024: ldc.r8 11
L_002d: stind.r8 
L_002e: ldloc.1 
L_002f: refanyval float64
L_0034: ldind.r8 
L_0035: call void [mscorlib]System.Console::WriteLine(float64)
L_003a: ldloc.1 
L_003b: refanytype 
L_003d: call class [mscorlib]System.Type 
          [mscorlib]System.Type::GetTypeFromHandle
          (valuetype [mscorlib]System.RuntimeTypeHandle)
L_0042: stloc.2 
L_0043: ldloc.2 
L_0044: callvirt instance string 
          [mscorlib]System.Reflection.MemberInfo::get_Name()
L_0049: call void [mscorlib]System.Console::WriteLine(string)
L_004e: ret 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__arglist&lt;/code&gt; позволяет создать метод с переменным количеством параметров. Причём это не передача массива объектов через &lt;code&gt;params&lt;/code&gt;, а в чистом виде переменное количество параметров. Получить переданные значения можно через структуру &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.argiterator.aspx&quot;&gt;ArgIterator&lt;/a&gt;. Ниже приведён пример, который иллюстрирует использование команды.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
    Foo(__arglist(1, 2.0, &amp;quot;3&amp;quot;, new int[0]));
}

public void Foo(__arglist)
{
    var iterator = new ArgIterator(__arglist);
    while (iterator.GetRemainingCount() &amp;gt; 0)
    {
        TypedReference typedReference = iterator.GetNextArg();
        Console.WriteLine(&amp;quot;{0} / {1}&amp;quot;, 
            TypedReference.ToObject(typedReference), 
            TypedReference.GetTargetType(typedReference));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И соответствующий IL-код, в котором можно познакомиться с командой &lt;code&gt;arglist&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.method public hidebysig instance void Run() cil managed
{
.maxstack 8
L_0000: ldarg.0 
L_0001: ldc.i4.1 
L_0002: ldc.r8 2
L_000b: ldstr &amp;quot;3&amp;quot;
L_0010: ldc.i4.0 
L_0011: newarr int32
L_0016: call instance vararg void Program::Foo(..., int32, float64, string)
L_001b: ret 
}

.method public hidebysig instance vararg void Foo() cil managed
{
.maxstack 3
.locals init (
    [0] valuetype [mscorlib]System.ArgIterator iterator,
    [1] valuetype [mscorlib]System.TypedReference typedReference)
L_0000: ldloca.s iterator
L_0002: arglist 
L_0004: call instance void 
          [mscorlib]System.ArgIterator::.ctor
          (valuetype [mscorlib]System.RuntimeArgumentHandle)
L_0009: br.s L_0029
L_000b: ldloca.s iterator
L_000d: call instance valuetype 
          [mscorlib]System.TypedReference 
          [mscorlib]System.ArgIterator::GetNextArg()
L_0012: stloc.1 
L_0013: ldstr &amp;quot;{0} / {1}&amp;quot;
L_0018: ldloc.1 
L_0019: call object [mscorlib]System.TypedReference::ToObject
          (valuetype [mscorlib]System.TypedReference)
L_001e: ldloc.1 
L_001f: call class [mscorlib]System.Type 
          [mscorlib]System.TypedReference::GetTargetType
          (valuetype [mscorlib]System.TypedReference)
L_0024: call void [mscorlib]System.Console::WriteLine(string, object, object)
L_0029: ldloca.s iterator
L_002b: call instance int32 [mscorlib]System.ArgIterator::GetRemainingCount()
L_0030: ldc.i4.0 
L_0031: bgt.s L_000b
L_0033: ret 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Поговорим о производительности&lt;/h3&gt;
&lt;p&gt;На StackOverflow есть &lt;a href=&quot;http://stackoverflow.com/questions/4764573/why-is-typedreference-behind-the-scenes-its-so-fast-and-safe-almost-magical&quot;&gt;обсуждение&lt;/a&gt;, в котором утверждается, что якобы работа с &lt;code&gt;TypedReference&lt;/code&gt; осуществляется быстрее, чем упаковка/распаковка. Но бенчмарк у автора очень странный. Плюс, как мне кажется, автор запускал его в Debug mode with debugging — в этом случае действительно могут получится такие результаты. Но ряд людей написал в комментариях, что на самом деле упаковка/распаковка работает намного быстрее. Я решил проверить это, составив правильный бенчмарк с помощью &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;. Выглядит он следующим образом (полная версия кода: &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MakeRefVsBoxingProgram.cs&quot;&gt;MakeRefVsBoxingProgram.cs&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int IterationCount = 10000000;
private int[] array;

public void Run()
{
    array = new int[5];

    var competition = new BenchmarkCompetition();
    competition.AddTask(&amp;quot;MakeRef&amp;quot;, MakeRef);
    competition.AddTask(&amp;quot;Boxing&amp;quot;, Boxing);
    competition.Run();
}

public void MakeRef()
{
    for (int i = 0; i &amp;lt; IterationCount; i++)
        Set1(array, 0, i);
}

public void Boxing()
{
    for (int i = 0; i &amp;lt; IterationCount; i++)
        Set2(array, 0, i);
}

public void Set1(T[] a, int i, int v)
{
    __refvalue(__makeref(a[i]), int) = v;
}

public void Set2(T[] a, int i, int v)
{
    a[i] = (T)(object)v;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Не забывайте, что бенчмарки нужно запускать только в &lt;strong&gt;Release mode without debugging&lt;/strong&gt;. Результаты, которые получились на моём ноутбуке:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MakeRef : 313ms
Boxing  :  34ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;У нас имеются классы &lt;code&gt;MyObject&lt;/code&gt;, который содержит одно поле на 64 бита, и &lt;code&gt;Pumpkin&lt;/code&gt;, который содержит два поля по 32 бита. В методе Run выполняются следующие вещи: мы создаём объект &lt;code&gt;myObject&lt;/code&gt;, инициализируем его поле, получаем на него ссылку, а затем создаём &lt;code&gt;pumpkin&lt;/code&gt;, который ссылается на ту же область памяти. В качестве теста мы пробуем поменять значение 64-х битного поля изначально объекта и смотрим на изменение соответствующих полей в тыкве.&lt;/p&gt;
&lt;p&gt;Особый интерес представляют методы &lt;code&gt;GetAddress&lt;/code&gt; и &lt;code&gt;Convert&amp;lt;T&amp;gt;&lt;/code&gt; . Начнём с первого: он получает указатель &lt;code&gt;IntPtr&lt;/code&gt; на переданный объект. В первой строчке всё просто: мы получаем &lt;code&gt;TypedReference&lt;/code&gt; на переданный объект, а вот во второй строчке происходит немного магии. Первое поле &lt;code&gt;TypedReference&lt;/code&gt; хранит &lt;code&gt;IntPtr&lt;/code&gt; -ссылку на наш объект, но явно мы получить эту ссылку не можем. Поэтому мы получаем указатель на наш &lt;code&gt;TypedReference&lt;/code&gt; (который также является указателем на его первое поле), приводим его к указателю на &lt;code&gt;IntPtr&lt;/code&gt; , а потом разыменовываем. В итоге имеем своего рода неуправляемое получение адреса объекта.&lt;/p&gt;
&lt;p&gt;А теперь переходим к методу &lt;code&gt;Convert&amp;lt;T&amp;gt;&lt;/code&gt;. Этот метод должен нам создать объект типа &lt;code&gt;T&lt;/code&gt;, который ссылается на заданную область памяти. В первой строке мы создаём дефолтный экземпляр типа &lt;code&gt;T&lt;/code&gt; . Единственное его предназначение — это получить соответствующий &lt;code&gt;typedReference&lt;/code&gt;, который создаётся во второй строчке. Второе поле полученной структуры указывает на нужный нам тип. Третьей строчкой мы записываем переданный нам адрес в первое поле структуры с помощью уже знакомой нам конструкции
&lt;code&gt;*(IntPtr*)(&amp;amp;typedReference)&lt;/code&gt; . И в последней четвёртой строчке мы собираем из нашей &lt;code&gt;typedReference&lt;/code&gt; структуры готовый объект целевого типа с помощью &lt;code&gt;__refvalue&lt;/code&gt;
. Вуаля: тыква готова.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. Приведённый пример имеет чисто академическое предназначение, он приведён как демонстрация использования заявленных ключевых слов. В продакшн-коде нужно несколько раз подумать, прежде чем решить, что вам действительно необходимы подобные конструкции.&lt;/strong&gt;&lt;/p&gt;</description>
            </item>
            <item>
                <title>Неожиданное место для сборки мусора в .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/gc-native/</link> 	
                <pubDate>Thu, 08 Aug 2013 08:42:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/gc-native/</guid>
                <description>&lt;p&gt;Платформа .NET обеспечивает нас высокоинтеллектуальным сборщиком мусора, который избавляет от рутины ручного управления памятью. И в 95% случаев можно действительно забыть про память и связанные с ней нюансы. Но вот оставшиеся 5% обладают своей спецификой, связанной с неуправляемыми ресурсами, слишком большими объектами и т.д. И тут лучше бы хорошо разбираться в том, как производится сборка мусора. В противном случае вас могут ждать очень неприятные сюрпризы.&lt;/p&gt;
&lt;p&gt;Как вы думаете, может ли GC собрать объект до того, как выполнится последний из его методов? Оказывается, может. Правда, для этого необходимо запустить приложение в Release mode и отдельно от студии (without debugging). В этом случае JIT-компилятор сделает определённые оптимизации, в результате которых такая ситуация возможна. Разумеется, делает он это только тогда, когда в оставшемся теле метода нет ссылок на сам объект или его поля. Казалось бы, достаточно невинная оптимизация. Но она может привести к проблемам, если мы имеем дело с неуправляемыми ресурсами: сборка объекта может произойти &lt;em&gt;до того&lt;/em&gt;, как закончится операция над неуправляемым объектом, что вполне вероятно повлечёт падение приложения.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Давайте воспроизведём ситуацию. Для начала нам понадобится что-нибудь неуправляемое, скажем библиотека &lt;a href=&quot;https://code.google.com/p/opencvsharp/&quot;&gt;OpenCvSharp&lt;/a&gt;
, которая представляет собой обёртку над &lt;a href=&quot;http://opencv.org/&quot;&gt;OpenCV&lt;/a&gt; — библиотекой компьютерного зрения и обработки изображений. Взята именно эта библиотека, т.к. на ней и была обнаружена неприятная ситуация. Рассмотрим следующий класс:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ImageWithCircle
{
  private const int Size = 10000;
  private readonly IplImage image;

  public ImageWithCircle()
  {            
    image = Cv.CreateImage(new CvSize(Size, Size), BitDepth.U8, 3);
    DrawCircle();
  }

  ~ImageWithCircle()
  {
    Console.WriteLine(&amp;quot;~ImageWithCircle&amp;quot;);
    Cv.ReleaseImage(image);
  }

  public void Save()
  {
    Console.WriteLine(&amp;quot;Save start&amp;quot;);
    image.SaveImage(&amp;quot;image.tif&amp;quot;);
    Console.WriteLine(&amp;quot;Save end&amp;quot;);
  }

  public void DrawCircle()
  {
    image.FloodFill(new CvPoint(Size / 2, Size / 2), CvColor.White);
    image.Circle(new CvPoint(Size / 2, Size / 2), Size / 4, 
                 CvColor.Random(), 10);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Это весьма простой класс, который отвечает за рисование очень большой картинки с кружочком. Имеется метод &lt;code&gt;Save()&lt;/code&gt;, который сохраняет картинку в файл. Логика работы с изображением заключена в классе &lt;code&gt;IplImage&lt;/code&gt; из библиотеки OpenCvSharp. Запустим этот код:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void Main()
{
  new ImageWithCircle().Save();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;На консоли появится ожидаемый вариант: мы зашли в метод &lt;code&gt;Save()&lt;/code&gt;, мы вышли из него, а только потом выполнилась сборка мусора и был вызван соответствующий финализатор.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Save start
Save end
~ImageWithCircle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь вызовем сборку мусора &lt;em&gt;во время сохранения картинки&lt;/em&gt;. Это всего лишь пример, поэтому не будет изобретать что-то умное, а просто включим &lt;code&gt;Timer&lt;/code&gt;, который будет весьма часто запускать &lt;code&gt;GC.Collect()&lt;/code&gt;. Картинка очень большая, и мы навярника запустим сборку мусора хотя бы раз до окончания её сохранения. Итак, исполняемый код теперь выглядит следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static void Main()
{
  var timer = new Timer(100);
  timer.Elapsed += RunGc;
  timer.Start();
  new ImageWithCircle().Save();
}

private static void RunGc(object sender, ElapsedEventArgs e)
{
  Console.WriteLine(&amp;quot;Gc.Collect();&amp;quot;);
  GC.Collect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Наверное, вы ожидаете увидеть что-нибудь вроде:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gc.Collect();
Gc.Collect();
Gc.Collect();
Save start
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Save end
~ImageWithCircle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но если выполнить запуск в Release mode without debugging, то приложение упадёт:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gc.Collect();
Gc.Collect();
Gc.Collect();
Save start
Gc.Collect();
~ImageWithCircle

Unhandled Exception: System.AccessViolationException: Attempted to read or write
 protected memory. This is often an indication that other memory is corrupt.
   at OpenCvSharp.CvInvoke.cvSaveImage(String filename, IntPtr image, Int32[] pa
rams)
   at OpenCvSharp.Cv.SaveImage(String filename, CvArr image, ImageEncodingParam[
] prms)
   at ConsoleApplication.ImageWithCircle.Save() in d:\Tests\ConsoleApplica
tion\ConsoleApplication\ImageWithCircle.cs:line 28
   at ConsoleApplication.Program.Main() in d:\Tests\ConsoleApplication\Co
nsoleApplication\Program.cs:line 18
Gc.Collect();
Gc.Collect();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Проблема в том, что JIT всё-таки выполнил свою коварную оптимизацию: наш объект подвергся сборке мусора прежде, чем картинка полностью успела сохраниться в файл. Увы, OpenCvSharp не смог такого пережить и выбросил исключение.&lt;/p&gt;
&lt;p&gt;Ситуацию исправить очень легко: достаточно удерживать ссылку на текущую картинку до окончания работы метода. Например, можно воспользоваться каким-нибудь статическим объектом, в который картинка будет записывать ссылку на себя в начале метода &lt;code&gt;Save()&lt;/code&gt;. Но я предпочитаю использовать метод &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.gc.keepalive.aspx&quot;&gt;GC.KeepAlive&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Save()
{
  Console.WriteLine(&amp;quot;Save start&amp;quot;);
  image.SaveImage(&amp;quot;image.tif&amp;quot;);
  Console.WriteLine(&amp;quot;Save end&amp;quot;);
  GC.KeepAlive(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Собственно говоря, не так важно, как именно вы исправите ситуацию, главное — понимать нюансы работы сборщика мусора, чтобы предвидеть подобные проблемы, ведь их очень сложно обнаружить: падение приложения в примере возникает только при определённой конфигурации запуска в случае, если сборщику мусора доведётся запуститься во время исполнения какого-то достаточно продолжительного выполнения неуправляемого метода. И если вы случайно натолкнётесь на такое падение приложения, то потом будете ещё долго ломать голову над тем, как же его теперь воспроизвести. Для избежания таких ситуаций необходимо тщательно проектировать взаимодействие с любыми нативными объектами, стараясь предвидеть возможные проблемы до этапа написания кода.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Неочевидности в использовании C#-замыканий</title>
                <link>http://aakinshin.net/ru/blog/dotnet/closures/</link> 	
                <pubDate>Wed, 07 Aug 2013 12:35:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/closures/</guid>
                <description>&lt;p&gt;Язык C# даёт нам возможность пользоваться замыканиями — мощным механизмом, который позволяет анонимным методам и лямбдам захватывать свободные переменные в своём лексическом контексте. И в .NET-мире многие программисты очень любят использовать замыкания, но немногие понимают, как они действительно работают. Начнём с простого примера:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  int e = 1;
  Foo(x =&amp;gt; x + e);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ничего сложного тут не происходит: мы просто &#171;захватили&#187; локальную переменную &lt;code&gt;e&lt;/code&gt; в лямбду, которая передаётся в некоторый метод &lt;code&gt;Foo&lt;/code&gt;. Посмотрим, во что компилятор развернёт такую конструкцию:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  DisplayClass c = new DisplayClass();
  c.e = 1;  
  Foo(c.Action);
}

private sealed class DisplayClass
{
  public int e;

  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Как видно из примера, для нашего замыкания создаётся дополнительный класс, который содержит захватываемую переменную  и целевой метод. Это знание поможет нам осознать поведение замыканий в различных ситуациях.&lt;/p&gt;
&lt;h3&gt;Цикл for&lt;/h3&gt;
&lt;p&gt;Наверное, это самый классический пример, который приводят все:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  for (int i = 0; i &amp;lt; 3; i++)
    actions.Add(() =&amp;gt; Console.WriteLine(i));
  foreach (var action in actions)
    action();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В этом примере сделана типичная ошибка. Начинающие программисты думаю, что этот код выведет &lt;code&gt;&amp;quot;0 1 2&amp;quot;&lt;/code&gt;, но на самом деле он выведет &lt;code&gt;&amp;quot;3 3 3&amp;quot;&lt;/code&gt;. Такое странное поведение легко понять, если взглянуть на развёрнутую версию этого метода:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  DisplayClass c = new DisplayClass();
  for (c.i = 0; c.i &amp;lt; 3; c.i++)
    list.Add(c.Action);
  foreach (Action action in list)
    action();
}

private sealed class DisplayClass
{
  public int i;

  public void Action()
  {
    Console.WriteLine(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В таком случае часто говорят, что переменная замыкается по ссылке, а не по значению. Эту особенность замыканий многие осуждают, как непонятную, хотя она является достаточно логичной для тех, кто хорошо представляет, что скрыто под капотом замыканий. Эту тему очень подробно обсуждает Эрик Липперт в постах &lt;a href=&quot;http://blogs.msdn.com/b/ruericlippert/archive/2009/11/12/9983705.aspx&quot;&gt;О вреде замыканий на переменных цикла&lt;/a&gt; и &lt;a href=&quot;http://blogs.msdn.com/b/ruericlippert/archive/2009/11/16/9984832.aspx&quot;&gt;Замыкания на переменных цикла. Часть 2&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Цикл foreach&lt;/h3&gt;
&lt;p&gt;Посмотрим более интересный пример:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  foreach (var i in Enumerable.Range(0, 3))
    actions.Add(() =&amp;gt; Console.WriteLine(i));
  foreach (var action in actions)
    action();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Что выведет это код? Увы, однозначного ответа на этот вопрос нету. Дело в том, что в ранних версиях C# поведение foreach было подобно поведению for: переменная цикла создавалась один раз и захватывалась во всех лямбдах. А в C# 5.0 это поведение поменяли (&lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx&quot;&gt;тут&lt;/a&gt; Эрик Липперт признаётся, что Microsoft всё-таки сделали breaking change). Теперь этот код выводит &lt;code&gt;&amp;quot;0 1 2&amp;quot;&lt;/code&gt;
. Заметьте, что это особенность именно языка, а не платформы. Если вы работаете из VisualStuido 2012 и меняете TargetFramework на 3.5, то ничего не поменяется, а вот из VisualStudio 2010 вы сможете пронаблюдать старое поведение. На Stackoverflow Джон Скит &lt;a href=&quot;http://stackoverflow.com/questions/16264289/captured-closure-loop-variable-in-c-sharp-5-0&quot;&gt;объясняет&lt;/a&gt; почему было решено сделать различное поведение для &lt;code&gt;for&lt;/code&gt; и &lt;code&gt;foreach&lt;/code&gt;. Взглянем на новый вариант развёрнутой версии кода:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  foreach (int i in Enumerable.Range(0, 3))
  {
    DisplayClass c = new DisplayClass();
    с.i = i;    
    list.Add(c1.Action);
  }
  foreach (Action action in list)
    action();
}

private sealed class DisplayClass
{
  public int i;

  public void Action()
  {
    Console.WriteLine(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Легко можно заметить разницу: в C# 5.0 на каждую итерацию цикла &lt;code&gt;foreach&lt;/code&gt; мы имеем новый экземпляр сгенерированного класса, обеспечивающего логику замыкания. На Хабре можно &lt;a href=&quot;http://habrahabr.ru/post/141270/&quot;&gt;почитать&lt;/a&gt; поподробнее про замыкания в новой версии C#.&lt;/p&gt;
&lt;h3&gt;Замыкание нескольких переменных&lt;/h3&gt;
&lt;p&gt;Рассмотрим ситуацию в которой у нас есть несколько переменных, которые замыкаются в различных переменных:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  int x = 1, y = 2;
  Foo(u =&amp;gt; u + x, u =&amp;gt; u + y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Можно подумать, что в этом случае у нас сгенерируется два дополнительных класса, каждый из которых будет отвечать за единственную переменную. Но на самом деле будет только один сгенерированный класс:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  DisplayClass с = new DisplayClass();
  с.x = 1;
  с.y = 2;
  Foo(с.ActionX, c.ActionY);
}

private sealed class DisplayClass
{
  public int x;
  public int y;

  public int ActionX(int u)
  {
    return u + x;
  }

  public int ActionY(int u)
  {
    return u + y;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Таким образом, лямбды оказываются &#171;связаны&#187;: сборщик мусора доберётся до них только после того, как не останется ссылок ни на одну из них. Представьте ситуацию, в которой первая лямбда используется при инициализации долгоживущего объекта, а вторая — по окончанию работы с ним. И пусть таких объектов будет много. В этом случае инициализирующие лямбды будут болтаться в памяти очень долго, хотя никто их больше никогда не будет вызывать.&lt;/p&gt;
&lt;h3&gt;Scope&lt;/h3&gt;
&lt;p&gt;Есть ещё одна особенность работы замыканий, о которой полезно знать. Рассмотрим пример:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (var element in list)
  {
    var e = element;
    if (Condition(e))
      Foo(x =&amp;gt; x + e);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь вопрос: в каком месте будет создан объект замыкания? Не смотря на то, что лямбда создаётся внутри &lt;code&gt;if&lt;/code&gt;-а, объект будет создаваться в том же &lt;code&gt;scope&lt;/code&gt;
-е, что и захватываемая переменная:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (int element in list)
  {
    DisplayClass c = new DisplayClass();
    c.e = element;
    if (Condition(c.e))
      Foo(c.Action);
  }
}

private sealed class DisplayClass
{
  public int e;

  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Такая особенность может иметь значение в случае, если &lt;code&gt;list&lt;/code&gt; очень большой, а условие &lt;code&gt;Condition(e)&lt;/code&gt; выполняется весьма редко. Ведь будет происходить бесполезное создание экземпляров класса &lt;code&gt;DisplayClass&lt;/code&gt; , что негативно скажется на памяти и производительности. Мы можем исправить эту ситуацию:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (var element in list)
    if (Condition(element))
    {
      var e = element;
      Foo(x =&amp;gt; x + e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Данный метод будет разворачиваться более оптимально, ведь теперь конструктор &lt;code&gt;DisplayClass&lt;/code&gt; будет вызываться только тогда, когда он действительно нужен:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (int element in list)
    if (Condition(element))
    {
      DisplayClass c = new DisplayClass();
      c.e = element;
      Foo(c.Action);
    }  
}

private sealed class DisplayClass
{
  public int e;
 
  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Задачи&lt;/h3&gt;
&lt;p&gt;На приведённую тему есть три задачки в
&lt;a href=&quot;http://problembook.net&quot;&gt;ProblemBook.NET&lt;/a&gt;:
&lt;a href=&quot;http://problembook.net/content/ru/Linq/ClosureAndForeach-P.html&quot;&gt;ClosureAndForeach&lt;/a&gt;,
&lt;a href=&quot;http://problembook.net/content/ru/Linq/ClosureAndFor-P.html&quot;&gt;ClosureAndFor&lt;/a&gt;,
&lt;a href=&quot;http://problembook.net/content/ru/Linq/ClosureAndVariable-P.html&quot;&gt;ClosureAndVariable&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Для дизассемблирования удобно пользоваться утилитой &lt;a href=&quot;http://www.jetbrains.com/decompiler/&quot;&gt;dotPeek&lt;/a&gt; от &lt;a href=&quot;http://www.jetbrains.com/&quot;&gt;JetBrains&lt;/a&gt;
с включённой опцией &lt;code&gt;Show compiler-generated code&lt;/code&gt;. Приведённый в статье код немного причёсан по сравнению с дизассемблированной версией для повышения читаемости.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Проблема с FPU при вызове .NET-логики из Delphi</title>
                <link>http://aakinshin.net/ru/blog/dotnet/delphi-fpu-issue/</link> 	
                <pubDate>Mon, 05 Aug 2013 21:49:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/delphi-fpu-issue/</guid>
                <description>&lt;p&gt;&lt;strong&gt;Ситуация:&lt;/strong&gt; мы пишем основную логику приложения на C#, но есть необходимость использовать её из Delphi. Для этих целей пользуемся COM-обёрткой, которая успешно справляется с поставленной задачей. Целевая функция перед возвращением результата показывает диалоговое WPF-окно, с которым можно сделать что-нибудь полезное. Проверяем на простом примере — всё отлично работает.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Проблема:&lt;/strong&gt; в некоторых Delphi приложений окно выбрасывает исключение. Но исключение странное: при формировании WPF-окна падает, скажем, выставление ширины некоторого элемента. Но это только в некоторых приложениях. А в остальных — тот же самый код на тех же самых данных отлично работает.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;В чём же дело?&lt;/strong&gt;&lt;!--more--&gt; Оставив в стороне увлекательную историю о проведённом исследовании, перейду сразу к решению: виновником был бит в FPU-регистре &lt;a href=&quot;http://www.club155.ru/x86internalreg-fpucw&quot;&gt;CW&lt;/a&gt;. Определённые функции некоторых версий Delphi любят менять его на такое значение, что бедный математический сопроцессор перестаёт переваривать &lt;code&gt;double.NaN&lt;/code&gt;, начиная плеваться на него исключениями. А в WPF, как известно, у доброй половины свойств &lt;code&gt;FrameworkElement&lt;/code&gt;-а значение по умолчанию выставлено именно в &lt;code&gt;NaN&lt;/code&gt;. При малейших манипуляциях над этими свойствами приложение начинает падать.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Что же делать?&lt;/strong&gt;
Имеется два метода решения проблемы. В первом варианте необходимо выставить правильное значение плохого бита в Delphi перед вызовом WPF-окна. Например так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;procedure Foo;
var 
  saved8087CW : Word; 
begin 
  saved8087CW := Default8087CW; 
  Set8087CW($133F); 
  // Вызываем нужный метод
  Set8087CW(saved8087CW); 
end; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот способ не всегда подходит, т.к. возможно .NET-логика будет использоваться в различных Delphi-приложениях, и у нас нет возможности обернуть все вызовы WPF-окна во всех приложениях. С этих позиций разумно установить бит на стороне .NET-а. В этом нам поможет функция &lt;code&gt;_controlfp&lt;/code&gt; из &lt;code&gt;msvcrt.dll&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[DllImport(&amp;quot;msvcrt.dll&amp;quot;, CallingConvention = CallingConvention.Cdecl)]
public static extern int _controlfp(int newControl, int mask);
 
const int _RC_NEAR = 0x00000000;
const int _PC_53 = 0x00010000;
const int _EM_INVALID = 0x00000010;
const int _EM_UNDERFLOW = 0x00000002;
const int _EM_ZERODIVIDE = 0x00000008;
const int _EM_OVERFLOW = 0x00000004;
const int _EM_INEXACT = 0x00000001;
const int _EM_DENORMAL = 0x00080000;
const int _CW_DEFAULT = 
  _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE +
  _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL;
 
public Foo()
{
  _controlfp(_CW_DEFAULT, 0xfffff);
  // Нужная нам логика 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.neslekkim.net/2008/10/fpu-issues-when-interoping-delphi-and.html&quot;&gt;FPU issues when interoping Delphi and .net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.msdn.com/b/dsvc/archive/2009/06/25/floating-point-exceptions-in-managed-code-resulting-in-access-violation-crash.aspx&quot;&gt;Floating point exception in managed code results in Access Violation crash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://support.microsoft.com/kb/326219&quot;&gt;PRB: System.Arithmetic Exception Error When You Change the Floating-Point Control Register in a Managed Application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/191368/how-can-i-set-and-restore-fpu-ctrl-registers&quot;&gt;SO — How can I set and restore FPU CTRL registers?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://digital.ni.com/public.nsf/allkb/E6A73825E57FCD9F862570DD005E594F&quot;&gt;Floating Point Exception When Calling Borland C++Builder or Delphi DLL or Executable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://valera.asf.ru/delphi/help/name.php?name=Set8087CW&quot;&gt;Delphi: Set8087CW&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.club155.ru/x86internalreg-fpucw&quot;&gt;Внутренние регистры: Регистр управления FPU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>FastColoredTextBox — божественный RichTextBox для .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/fastcoloredtextbox/</link> 	
                <pubDate>Tue, 16 Jul 2013 23:45:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/fastcoloredtextbox/</guid>
                <description>&lt;p&gt;Появилась у меня недавно задачка сделать в WPF-приложении красивый редактор форматированного текста с определённой логикой обработки. И решил я использовать для этой задачи стандартный &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/system.windows.controls.richtextbox.aspx&quot;&gt;RichTextBox&lt;/a&gt;. Увы, практика показала, что этот контрол &lt;a href=&quot;https://www.google.ru/search?q=wpf+richtextbox+performance&quot;&gt;ужасно медленный&lt;/a&gt;. Можно было, конечно, написать свою реализацию, но это занятие долгое, а функционал нужно было прикрутить побыстрее. Первая мысль была &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms751761.aspx&quot;&gt;захостить&lt;/a&gt; стандартный &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/system.windows.forms.richtextbox.aspx&quot;&gt;RichTextBox&lt;/a&gt; из WinForms. Он работает достаточно быстро, но его функционала мне не хватило. И тогда я пустился в поиск сторонних контролов. Каким же счастливым я стал, когда наткнулся на FastColoredTextBox! Изучение контрола лучше всего начать со &lt;a href=&quot;http://www.codeproject.com/Articles/161871/Fast-Colored-TextBox-for-syntax-highlighting&quot;&gt;статьи&lt;/a&gt; на CodeProject. Увы, NuGet-пакет автор &lt;a href=&quot;https://github.com/PavelTorgashov/FastColoredTextBox/issues/10&quot;&gt;по каким-то причинам&lt;/a&gt; делать не хочет, но зато есть &lt;a href=&quot;https://github.com/PavelTorgashov/FastColoredTextBox&quot;&gt;исходники&lt;/a&gt; на GitHub. Итак, небольшой обзор.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/fastcoloredtextbox/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Главным образом, автор библиотеки (&lt;a href=&quot;https://github.com/PavelTorgashov&quot;&gt;Павел Торгашов&lt;/a&gt;) ориентировал его на работу с программным кодом, но разработанный контрол прекрасно подходит для любых других задач. В WinForms его можно использовать в чистом виде, а в WPF приложение его легко добавить &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms742875.aspx&quot;&gt;даже прямо через XAML&lt;/a&gt;. Скорость работы впечатляет (отличный performance был основной задачей автора), рендеринг происходит на основе GDI+. В рамках одного контрола поддерживается 16 стилей, но, как &lt;a href=&quot;https://github.com/PavelTorgashov/FastColoredTextBox/issues/18&quot;&gt;говорит автор&lt;/a&gt;, если вам нужно больше, то вы делаете что-то не так. Распространяется под &lt;a href=&quot;http://opensource.org/licenses/lgpl-3.0.html&quot;&gt;LGPLv3&lt;/a&gt;, а значит можно использовать в проприетарном софте. Есть &lt;a href=&quot;http://www.codeproject.com/script/articles/download.aspx?file=/KB/edit/FastColoredTextBox_/FastColoredTextBox_Help.zip&amp;amp;rp=http://www.codeproject.com/Articles/161871/Fast-Colored-TextBox-for-syntax-highlighting&quot;&gt;chm-документация&lt;/a&gt;, но больше толку от оригинальной статьи и demo-проекта Tester из репозитория, который содержит большое количество примеров на все случаи жизни:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/fastcoloredtextbox/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;h3&gt;Выводы&lt;/h3&gt;
&lt;p&gt;За свою жизнь я поработал с очень большим количеством разных контролов и могу авторитетно заявить: FastColoredTextBox реализован очень грамотно. В большинстве случаев, когда мне нужно было какое-нибудь свойство, то я задавал себе простой вопрос: &lt;em&gt;&#171;Если бы я был этим свойством, то как бы я назывался?&#187;&lt;/em&gt;. Первый пришедший в голову ответ вместе с intellisense помогали быстро найти нужную функциональность. Некоторые особенности, которые понравились лично мне:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Контрол работает ну очень быстро&lt;/li&gt;
&lt;li&gt;Отличное API, XML-документация и demo-приложение&lt;/li&gt;
&lt;li&gt;Продвинутая подсветка любого синтаксиса на основе регулярных выражений&lt;/li&gt;
&lt;li&gt;Интерактивное выделение некоторых частей, в зависимости от позиции курсора&lt;/li&gt;
&lt;li&gt;Возможность определять свои стили, в которых можно написать собственную отрисовку каждого символа через обычный Graphics&lt;/li&gt;
&lt;li&gt;Свёртка блоков текста&lt;/li&gt;
&lt;li&gt;Навигация по тексту, закладки&lt;/li&gt;
&lt;li&gt;Autocomplete&lt;/li&gt;
&lt;li&gt;Встроенные в тело документа Hint-ы и всплывающие ToolTip-ы&lt;/li&gt;
&lt;li&gt;Запись макросов&lt;/li&gt;
&lt;li&gt;Поддержка стандартных горячих клавиш (с возможностью назначит свои) и работы с буфером&lt;/li&gt;
&lt;li&gt;Хранение истории, нормальный ChangeTracker с операциями Undo/Redo&lt;/li&gt;
&lt;li&gt;Экспорт в HTML&lt;/li&gt;
&lt;li&gt;.NET Framework 2.0 и поддержка Compact Framework&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Материалы по Git</title>
                <link>http://aakinshin.net/ru/blog/git/links/</link> 	
                <pubDate>Tue, 18 Jun 2013 22:57:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/git/links/</guid>
                <description>&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/links/front.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Основные:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://git-scm.com/book&quot;&gt;Pro Git [EN]&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://git-scm.com/book/ru&quot;&gt;Pro Git [RU]&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://marklodato.github.io/visual-git-guide/index-ru.html&quot;&gt;Git: наглядная справка [RU]&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://marklodato.github.io/visual-git-guide/index-en.html&quot;&gt;Git: наглядная справка [EN]&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/user-manual.html&quot;&gt;Git User’s Manual [EN]&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://www-cs-students.stanford.edu/~blynn/gitmagic/index.html&quot;&gt;Git magic [EN]&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/&quot;&gt;Волшебство Git [RU]&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
Интерактивные обучалки:
&lt;ul&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://githowto.com/ru&quot;&gt;Git How To [RU]&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://githowto.com&quot;&gt;Git How To [EN]&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://try.github.io/&quot;&gt;Try Git [EN]&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://pcottle.github.io/learnGitBranching/&quot;&gt;LearnGitBranching [EN]&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
Видеокурсы:
&lt;ul&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://vimeo.com/14629850&quot;&gt;Getting Git [EN]&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
GitHub
&lt;ul&gt;
    &lt;li&gt;
        &lt;a href=&quot;https://github.com&quot;&gt;GitHub — самый популярный Git-хостинг&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://gitfm.com/&quot;&gt;gitfm — персональные рекомендации пользователям GitHub&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://gitrec.mortardata.com/&quot;&gt;GitRec — ещё один сервис персональных рекомендаций&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
Хорошие посты на Хабре:
&lt;ul&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/157175/&quot;&gt;Машина времени в git&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/179123/&quot;&gt;Чем опасен rebase, или как получилось, что 2*3=5&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/179673/&quot;&gt;Чем опасен rebase-2, или как rebase мешал баг искать&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/hub/Git/posts/&quot;&gt;Ежедневная работа с Git&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/181924/&quot;&gt;FeatureBranch&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/company/microsoft/blog/175261/&quot;&gt;Работа с Git в Visual Studio 2012&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/161009/&quot;&gt;Git Rebase: руководство по использованию&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/147260/&quot;&gt;Почему вы до сих пор не используете git-flow? перевод&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/hub/Git/posts/&quot;&gt;Переезд проекта с SVN на Git&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/143079/&quot;&gt;Что скрывает от нас директория .git&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/141160/&quot;&gt;Постигаем Git&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/123111/&quot;&gt;Пара приемов работы с git&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/post/106912/&quot;&gt;Удачная модель ветвления для Git&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;http://habrahabr.ru/company/badoo/blog/163853/&quot;&gt;Внутреннее устройство Git: хранение данных и merge&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;!--&lt;blockquote&gt;Test test test&lt;/blockquote&gt;
--&gt;</description>
            </item>
            <item>
                <title>Просмотр истории коммитов в Git</title>
                <link>http://aakinshin.net/ru/blog/git/log/</link> 	
                <pubDate>Tue, 18 Jun 2013 20:38:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/git/log/</guid>
                <description>&lt;p&gt;Изучение истории коммитов — важная составляющая работы с репозиторием. Увы, ввиду ветвления с этой историей не всегда просто разобраться. Обычно я для этой цели пользуюсь различными визуальными оболочками, но не всегда есть такая возможность. Временами приходится пользоваться средствами консоли, а именно командой
&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-log.html&quot;&gt;git log&lt;/a&gt;. Основы работы с этой командой можно почитать в чудесной книге
&lt;a href=&quot;http://git-scm.com/book/ru/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2&quot;&gt;ProGit&lt;/a&gt;
.
&lt;code&gt;git log&lt;/code&gt;
имеет множество различных полезных параметров. Рассмотрим несколько примеров их использования.&lt;/p&gt;
&lt;h3&gt;Древовидный вид&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git log --graph --abbrev-commit --decorate --date=relative --format=format:&#39;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)&#39; --all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим полный граф коммитов c сокращёнными хешами, ссылками на коммиты и относительной датой. Используемый формат: синий сокращённый хеш коммита, зелёная дата, белые сообщение и автор, жёлтые ссылки на коммит.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log1.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --graph --abbrev-commit --decorate --format=format:&#39;%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n&#39;&#39;          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)&#39; --all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим полный граф коммитов c сокращёнными хешами, ссылками на коммиты и абсолютной датой. Используемый формат: синий сокращённый хеш коммита, голубая абсолютная дата, зелёная относительная дата, жёлтые ссылки на коммит, перевод строки, белые сообщение и автор.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log2.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --graph --oneline --all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим полный граф коммитов, отводя по одной строке на коммит.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log3.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --graph --date-order --pretty=format:&amp;quot;&amp;lt;%h&amp;gt; %ad [%an] %Cgreen%d%Creset %s&amp;quot; --all --date=short
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим полный граф коммитов c сортировкой по дате, отображаемой в краткой форме. Используемый формат: сокращённый хеш, дата, автор, зелёные ссылки на коммит, сообщение.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log4.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Линейный вид&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вывод списка коммитов с параметрами по умолчанию.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log5.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим список коммитов и показываем diff для каждого.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log6.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --stat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим список коммитов и показываем статистику по каждому.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log7.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --pretty=oneline
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим список коммитов по одному на строчке.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log8.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим список коммитов с использованием следуюещго формата: сокращённый хеш коммита, автор, относительная дата, сообщение.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log9.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Визуальный интерфейс&lt;/h3&gt;
&lt;p&gt;Если есть возможность, то всё таки коммиты приятнее изучать через специализированный интерфейс, а не из консоли. Лично я очень люблю
&lt;a href=&quot;https://code.google.com/p/gitextensions/&quot;&gt;GitExtensions&lt;/a&gt;:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log10.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Также удобно использовать встроенную утилиту &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/gitk.html&quot;&gt;gitk&lt;/a&gt;:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log11.png&quot; /&gt;
&lt;/p&gt;
&lt;h3&gt;Полезные параметры&lt;/h3&gt;
&lt;p&gt;Все параметры команды &lt;code&gt;git log&lt;/code&gt; не нужны, но некоторые самые полезные хорошо бы помнить. Приведу несколько примеров использования ходовых параметров.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--graph&lt;/code&gt; Показывать древовидную структуру графа истории в ASCII-виде&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-5&lt;/code&gt; Посмотреть последних пять коммитов&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--skip=3&lt;/code&gt; Пропустить три коммита&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--pretty=oneline&lt;/code&gt; Отводить по одной строчке на коммит&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--since=&amp;quot;today&amp;quot;&lt;/code&gt; Показать коммиты за сегодня&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--since=2.weeks&lt;/code&gt; Показать коммиты за последние две недели&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt; Показывать diff каждого коммита&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--decorate&lt;/code&gt; Показывать ссылки на этот коммит&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--stat&lt;/code&gt; Показывать подробную статистику по каждому коммиту&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--shortstat&lt;/code&gt; Показывать краткую статистику по каждому коммиту&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name-only&lt;/code&gt; Показывать список изменённых файлов&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name-status&lt;/code&gt; Показывать список изменённых файлов с информацией о них&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--abbrev-commit&lt;/code&gt; Показывать только несколько первых цифр SHA-1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--relative-date&lt;/code&gt; Показывать дату в относительной форме&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C помощью замечательного параметра &lt;code&gt;--pretty=format:&amp;quot;&amp;quot;&lt;/code&gt; можно указать, какие именно данные о коммите нужно выводить, определив внутри кавычек общий паттерн, используя следующие обозначения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%H&lt;/code&gt; Хеш коммита&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%h&lt;/code&gt; Сокращённый хеш коммита&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%d&lt;/code&gt; Имена ссылок на коммит&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%s&lt;/code&gt; Сообщение к коммиту&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%an&lt;/code&gt; Автор&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%ad&lt;/code&gt; Дата автора&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%cn&lt;/code&gt; Коммитер&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%cd&lt;/code&gt; Дата коммитера&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%Cred&lt;/code&gt; Переключить цвет на красный&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%Cgreen&lt;/code&gt; Переключить цвет на зелёный&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%Cblue&lt;/code&gt; Переключить цвет на синий&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%Creset&lt;/code&gt; Сбросить цвет&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Полный список обозначений можно найти в &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-log.html&quot;&gt;мануале&lt;/a&gt; , в разделе &#171;PRETTY FORMATS&#187;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-log.html&quot;&gt;Официальный мануал&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/ru/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2&quot;&gt;ProGit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs&quot;&gt;Советы со Stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/twitter/bootstrap&quot;&gt;Репозиторий Twitter bootstrap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Использование изменяемых структур в свойствах классов</title>
                <link>http://aakinshin.net/ru/blog/dotnet/mutable-structures-as-property/</link> 	
                <pubDate>Thu, 06 Jun 2013 16:31:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/mutable-structures-as-property/</guid>
                <description>&lt;div style=&quot;text-align: right;&quot;&gt;&lt;i&gt;Названия всех классов вымышленные,&lt;br /&gt;все совпадения абсолютно случайны.&lt;/i&gt;&lt;/div&gt;
&lt;p&gt;Занимался я как-то раз улучшением кода проекта. И наткнулся вот на такие строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Image
{
  public Rectangle Bounds;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&#171;Ай-яй-яй! Публичное поле в классе, как же нехорошо-то! Нужно срочно превратить его в свойство!&#187;&lt;/em&gt; — подумал я. И превратил:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Image
{
  public Rectangle Bounds { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Сделал я такое невинное изменение и сразу пошёл дальше рефакторить — ведь ещё такое количество кода нуждалось в улучшении! Ну а в конце решил я запустить на всякий случай Unit-тесты. Какого же было моё удивление, когда половина тестов упала. &lt;em&gt;&#171;Да как же так! Ведь я особо-то ничего и не менял!&#187;&lt;/em&gt; Ну, поехали разбираться.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Прежде всего взглянем на пресловутый &lt;code&gt;Rectangle&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public struct Rectangle
{
  public int X, Y, Width, Height;

  public void Inflate(int value) // &#171;Раздуваем&#187; наш прямоугольник
  {
    X -= value;
    Y -= value;
    Width += 2 * value;
    Height += 2 * value;
  }

  public override string ToString()
  {
    return string.Format(&amp;quot;[{0}, {1}, {2}, {3}]&amp;quot;, X, Y, Width, Height);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну, а теперь сценарий использования:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var image = new Image();
image.Bounds = new Rectangle { X = 0, Y = 0, Width = 10, Height = 10 };
image.Bounds.Inflate(5);
Console.WriteLine(image.Bounds);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&#171;Ах, ну зачем же так писать-то&#187;&lt;/em&gt; — подумал я, ведь внезапно мне всё стало понятно. Давайте разбираться подробнее.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Случай до рефакторинга: Bounds — поле.&lt;/strong&gt; В этом случае метод &lt;code&gt;Inflate&lt;/code&gt; будет работать с прямоугольником &lt;code&gt;Bounds&lt;/code&gt; , непосредственно относящимся к нашей картинке. Он успешно отработает, а метод &lt;code&gt;Console.WriteLine&lt;/code&gt; покажет нам &#171;раздутую&#187; версию границ: &lt;code&gt;&amp;quot;-5 -5 20 20&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Случай после рефакторинга: Bounds — свойство.&lt;/strong&gt; В этом случае настоящие границы хранятся в приватном сгенерированном поле, а при обращении к свойству
&lt;code&gt;Bounds&lt;/code&gt; на самом деле вызывается метод &lt;code&gt;get_Bounds()&lt;/code&gt; , который вернёт нам только копию прямоугольника. И раздувать мы будем уже копию, а не оригинал. Поэтому
&lt;code&gt;Console.WriteLine&lt;/code&gt; вернёт нам исходный прямоугольник: &lt;code&gt;&amp;quot;0 0 10 10&amp;quot;&lt;/code&gt;. Если уж нам так уж хочется сделать побольше оригинальный прямоугольник, то правильным способом будет являться следующий путь: достаём прямоугольник в локальную переменную, выполняем над ней необходимые манипуляции, а результат записываем обратно:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var bounds = image.Bounds;
bounds.Inflate(5);
image.Bounds = bounds;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но если говорить более глобально, то архитектурная ошибка появилась в классе &lt;code&gt;Rectangle&lt;/code&gt;: нужно стараться не допускать в проекте изменяемых структур, их наличие может повлечь вышеописанные проблемы. &lt;em&gt;&#171;Но как же быть с публичными данными структуры, ведь до них я могу добраться явно и поменять их!&#187;&lt;/em&gt; — спросите вы. На этот случай беспокоиться не стоит, компилятор C# — умный, он не будет даже компилировать строки вида&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;image.Bounds.X += 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если вы хотите сделать методы, которые выполняют над структурой какие-то преобразования, то лучше бы этим методам создавать новый экземпляр структуры и возвращать его. Перепишем метод раздутия прямоугольника &#171;правильным способом&#187;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Rectangle Inflate(int value)
{
  return new Rectangle
    {
      X = X - value,
      Y = Y - value,
      Width = Width + 2 * value,
      Height = Height + 2 * value
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вот с таким методом заиметь проблемы по неосмотрительности уже намного сложнее. Мораль: если вы по каким-то причинам решили использовать в своём проекте структуры, то лучше бы вам не писать методов, которые изменяют их состояние.&lt;/p&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/441309/why-are-mutable-structs-evil&quot;&gt;StackOverflow — Why are mutable structs evil?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[http://habrahabr.ru/post/124404/&amp;quot;](Хабр — О вреде изменяемых значимых типов)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sergeyteplyakov.blogspot.ru/2012/12/2.html&quot;&gt;О вреде изменяемых значимых типов. Часть 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Заворачиваем C#-класс в COM</title>
                <link>http://aakinshin.net/ru/blog/dotnet/wrap-cs-in-com/</link> 	
                <pubDate>Mon, 03 Jun 2013 00:14:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/wrap-cs-in-com/</guid>
                <description>&lt;p&gt;Пусть у нас имеется C#-класс, который делает что-нибудь полезное, например:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Calculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Давайте создадим для этого класса &lt;a href=&quot;http://ru.wikipedia.org/wiki/Component_Object_Model&quot;&gt;COM&lt;/a&gt;-интерфейс, чтобы его функциональность можно было использовать в других местах. В конце посмотрим на использование этого класса в среде Delphi.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Для начала нужно пойти в свойства проекта и на вкладке &lt;em&gt;Build&lt;/em&gt; поставить галочку напротив &lt;em&gt;Register for COM interop&lt;/em&gt;:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/wrap-cs-in-com/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Далее создаём интерфейс для нашего класса:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public interface ICalculator
{
    int Sum(int a, int b);
}

public class Calculator : ICalculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Класс и интерфейс нужно пометить рядом атрибутов: следует указать для них уникальные &lt;a href=&quot;http://ru.wikipedia.org/wiki/GUID&quot;&gt;GUID&lt;/a&gt;-ы, указать &lt;code&gt;ComVisible(true)&lt;/code&gt;
, а для класса также добавить атрибут &lt;code&gt;ClassInterface(ClassInterfaceType.None)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Guid(&amp;quot;364C5E66-4412-48E3-8BD8-7B2BF09E8922&amp;quot;)]
[ComVisible(true)]
public interface ICalculator
{
    int Sum(int a, int b);
}

[Guid(&amp;quot;8C034F6A-1D3F-4DB8-BC99-B73873D8C297&amp;quot;)]
[ClassInterface(ClassInterfaceType.None)]
[ComVisible(true)]
public class Calculator : ICalculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Уже почти всё готово! Можно собирать готовый вариант нашей сборки. Благодаря галочке &lt;em&gt;Register for COM interop&lt;/em&gt; COM-компнент сам зарегистрируется в системе, но регистрацию можно провести и руками. Делается это с помощью утилиты &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/tzat5yw6.aspx&quot;&gt;RegAsm&lt;/a&gt;, которую можно найти в &amp;quot;C:\Windows\Microsoft.NET\Framework\v&amp;lt;номер нужной версии&amp;gt;&amp;quot;. С помощью аргумента &lt;code&gt;/tlb&lt;/code&gt; можно попутно создать сопутствующий tlb-файл. Отменить регистрацию сборки
&lt;a href=&quot;http://stackoverflow.com/questions/7841428/how-to-unregister-the-assembly-registered-using-regasm&quot;&gt;поможет&lt;/a&gt; атрибут &lt;code&gt;/u&lt;/code&gt;. Итак, выполним команду (будем считать, что название проекта и соответствующей dll — ComCalculator):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RegAsm.exe Calculator.dll /tlb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отлично, теперь наш компонент зарегистрирован! Давайте откроем Delphi и попробуем его использовать. После создания нового проекта (пусть это будет обычный WinForms-проект) нужно импортировать в него ComCalculator. Выбираем из меню &lt;em&gt;Project&lt;/em&gt; пункт &lt;em&gt;Import Type Library&lt;/em&gt; . В списке находим &lt;em&gt;ComCalculator&lt;/em&gt; и жмём &lt;em&gt;Install&lt;/em&gt;:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/wrap-cs-in-com/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;В файле &lt;code&gt;Unit1.pas&lt;/code&gt; необходимо добавить &lt;code&gt;ComCalculator_TLB&lt;/code&gt; в раздел &lt;code&gt;uses&lt;/code&gt;. После этого у вас &lt;a href=&quot;a%20href=%22http://stackoverflow.com/questions/7196769/what-is-this-error-mscorlib-tlb-pas%22&quot;&gt;a href=&amp;quot;http://stackoverflow.com/questions/7196769/what-is-this-error-mscorlib-tlb-pas&amp;quot;&lt;/a&gt;могут быть проблемы&lt;/a&gt; с компиляцией &lt;code&gt;mscorlib_TBL.pas&lt;/code&gt;. Если это так, то просто удалите ссылку на него из раздела &lt;code&gt;uses&lt;/code&gt; файла &lt;code&gt;ComCalculator_TLB.pas&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Теперь попробуем использовать наш COM-компонент. Будем это делать прямо в конструкторе формы. Тело конструктора будет содержать две незамысловатые строчки: в первой мы создадим экземпляр класса &lt;code&gt;TCalculator&lt;/code&gt; , а во второй вызовем метод &lt;code&gt;Sum&lt;/code&gt; , результат вычислений покажем с помощью процедуры &lt;code&gt;ShowMessage&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-delphi&quot;&gt;procedure TForm1.FormCreate(Sender: TObject);
var
  calculator : TCalculator;
begin
  calculator := TCalculator.Create(Self);
  ShowMessage(IntToStr(calculator.Sum(1, 2)));
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Запустив приложение, вы сможете увидеть появившееся окошечко с цифрой 3 и порадоваться.&lt;/p&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;p&gt;Для более сложных вариантов создания COM-объектов рекомендуются к изучению следующие статьи:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/c3fd4a20.aspx&quot;&gt;Пример COM-класса / msdn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rsdn.ru/forum/info/FAQ.dotnet.complusplus&quot;&gt;Как создавать COM+-компоненты на .NET-е / rsdn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cyberforum.ru/csharp-net/thread153051.html&quot;&gt;Создание COM в C# NET / CyberForum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Занимательное о шрифтах в .NET</title>
                <link>http://aakinshin.net/ru/blog/dotnet/fonts/</link> 	
                <pubDate>Mon, 03 Jun 2013 00:11:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/dotnet/fonts/</guid>
                <description>&lt;p&gt;Сегодня мы поговорим о замечательном классе &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.font(v=vs.90).aspx&quot;&gt;Font&lt;/a&gt;. Иногда при работе с шрифтами возникают некоторые вопросы, которые не настолько очевидны, как хотелось бы. Рассмотрим несколько из них.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Как опознать моноширинный шрифт?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Это не такой простой вопрос. Если немного погуглить, то можно найти следующий совет: описываем у себя в проекте класс &lt;a href=&quot;http://www.pinvoke.net/default.aspx/Structures/LOGFONT.html&quot;&gt;LOGFONT&lt;/a&gt; и используем метод &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9a240xh2.aspx&quot;&gt;ToLogFont&lt;/a&gt; для конвертации шрифта в соответствующий объект. После этого (согласно легенде) в поле &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.shell.interop.uidlglogfont.lfpitchandfamily(v=vs.80).aspx&quot;&gt;lfPitchAndFamily&lt;/a&gt; первый бит должен определять моноширинность шрифта. Так вот, это враньё, в современном мире поле &lt;a href=&quot;http://social.msdn.microsoft.com/Forums/en-US/netfxbcl/thread/1bc0166b-8a68-4067-a44b-e11ff7d55720&quot;&gt;всегда будет равно нулю&lt;/a&gt;. Когда-то где-то этот способ работал, но сейчас не работает. В реальности приходится использовать не очень красивое, но весьма эффективное решение типа такого:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// graphics — заранее созданный экземпляр класса Graphics
public static bool IsMonospace(Font font)
{
    return Math.Abs(graphics.MeasureString(&amp;quot;iii&amp;quot;, font).Width - 
                    graphics.MeasureString(&amp;quot;WWW&amp;quot;, font).Width) &amp;lt; 1e-3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; А как узнать размеры, которые будет занимать строчка при рисовании данным шрифтом?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Нам понадобится &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.graphics.aspx&quot;&gt;Graphics&lt;/a&gt;, с помощью которого мы собираемся рисовать, а именно — его метод
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6xe5hazb.aspx&quot;&gt;MeasureString&lt;/a&gt;. Передаём ему рисуемый текст и используемый шрифт — а он нам в ответ отдаёт его размеры.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; А если мне нужен размер не всей строчки, а только заданных её частей?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Это можно сделать с помощью метода &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.graphics.measurecharacterranges.aspx&quot;&gt;Graphics.MeasureCharacterRanges&lt;/a&gt;. Но сначала (в msdn есть хороший пример) нужно задать целевые интервалы символов с помощью метода &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/system.drawing.stringformat.setmeasurablecharacterranges.aspx&quot;&gt;StringFormat.SetMeasurableCharacterRanges&lt;/a&gt;. Это метод обладает занимательным ограничением — ему нельзя передавать более 32-х интервалов.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Этот метод выдаёт какие-то слишком большие границы. В них попадают не только сами символы, но и немного пространства около них. Что делать?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Действительно, возвращаемые регионы содержат интересующие нас символы так, как они идут в исходном шрифте — вместе с небольшой пустотой около них. Красивого способа получить точные границы нет. Придётся явно создавать картинку с целевыми символами, попиксельно её просмотреть (только не используйте метод
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.getpixel.aspx&quot;&gt;Bitmap.GetPixel&lt;/a&gt;, он очень долгий, есть &lt;a href=&quot;http://stackoverflow.com/questions/1563038/fast-work-with-bitmaps-in-c-sharp&quot;&gt;более быстрые способы&lt;/a&gt;) и найти крайние нарисованные символы нашей строки.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Я создал шрифт, используя его строковое название, никаких исключений не вылетело. А этот шрифт точно есть в системе?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Не обязательно. Конструктор класса Font попытается подобрать самый подходящий (по его мнению) шрифт для данного названия. Лучше проверить, что создался правильный шрифт:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var font = new Font(fontName, 12);
vat isExist = font.Name == fontName;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А ещё не помешает проверить, поддерживает ли используемое вами семейство шрифтов ваш &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.fontstyle.aspx&quot;&gt;FontStyle&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var fontFamily = new FontFamily(fontName);
isExist &amp;amp;= fontFamily.IsStyleAvailable(fontStyle);
&lt;/code&gt;&lt;/pre&gt;</description>
            </item>
            <item>
                <title>Вызов R-скрипта с аргументами из консоли</title>
                <link>http://aakinshin.net/ru/blog/r/terminal-arguments/</link> 	
                <pubDate>Mon, 03 Jun 2013 00:10:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/terminal-arguments/</guid>
                <description>&lt;p&gt;Для выполнения R-скрипта из консоли нам понадобится помощь утилит &lt;code&gt;Rscript.exe&lt;/code&gt; и &lt;code&gt;Rterm.exe&lt;/code&gt;. Разница между ними состоит в том, что &lt;code&gt;Rscript.exe&lt;/code&gt;
в результате выполнения выдаст нам только результат работы R-скрипта, а &lt;code&gt;Rterm.exe&lt;/code&gt; выдаст полный лог R-сессии (включая стартовое приглашение к работе и все исполняемые команды). Если быть до конца честными, то &lt;code&gt;Rscript.exe&lt;/code&gt; по сути вызывает &lt;code&gt;Rterm.exe&lt;/code&gt; с специальными аргументами (об этом немного ниже). Рассмотрим пример запуска скрипта с аргументами командной строки:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Rterm.exe --no-restore --no-save --args 100 image &amp;lt;script.R &amp;gt;output.txt
Rscript.exe script.R 100 image &amp;gt;output.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Разберём эти команды чуть подробней.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Для начала напишем скрипт под названием &lt;code&gt;script.R&lt;/code&gt; для рисования случайных точек, который будет принимать два аргумента: количество точек и имя файла, в который мы будем сохранять итоговую картинку. Код скрипта будет следующим:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;args &amp;lt;- commandArgs(trailingOnly = T) # Получаем аргументы из командной строки
print(args)                           # Выводим их
n &amp;lt;- as.integer(args[1])              # Первый аргумент — количество точек
name &amp;lt;- args[2]                       # Второй аргумент — имя картинки
x &amp;lt;- rnorm(n)                         # Генерируем точки
png(paste0(name, &amp;quot;.png&amp;quot;))             # Создаём png-картинку
plot(1:n, x)                          # Рисуем картинку
dev.off()                             # Заканчиваем рисовать
summary(x)                            # И немного статистики напоследок
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Особый интерес для нас представляет только первая строчка (остальной код приведён для иллюстрации). Для получения аргументов используется функция &lt;code&gt;commandArgs&lt;/code&gt;
, принимающая единственный параметр — &lt;code&gt;trailingOnly&lt;/code&gt;. Если &lt;code&gt;trailingOnly&lt;/code&gt; выставлен в &lt;code&gt;FALSE&lt;/code&gt; , то функция вернёт список вообще всех аргументов, которые были переданы исполняемому файлу &lt;code&gt;Rterm.exe&lt;/code&gt; . В случае значения &lt;code&gt;TRUE&lt;/code&gt; будут возвращены только аргументы, указанные после аргумента &lt;code&gt;--args&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;Вернёмся к двум строчкам запуска скрипта из консоли. Аргументы &lt;code&gt;--no-restore --no-save&lt;/code&gt; в первой строчке означают, что перед выполнением скрипта нам не нужно восстанавливать никакое рабочее окружение, а после его выполнения — не нужно сохранять. &lt;code&gt;&amp;amp;gt;output&lt;/code&gt; в самом конце каждой строчке означает, что вывод с консоли будет перенаправлен в файл &lt;code&gt;output.txt&lt;/code&gt;. В конце работы скрипта в каждом случае будет создан файл &lt;code&gt;image.png&lt;/code&gt; с распределением наших случайных точек. Разница будет заключаться в выводе &lt;code&gt;output.txt&lt;/code&gt;. В первом случае мы получим примерно следующее:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;R version 3.0.0 (2013-04-03) -- &amp;quot;Masked Marvel&amp;quot;
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R -- это свободное ПО, и оно поставляется безо всяких гарантий.
Вы вольны распространять его при соблюдении некоторых условий.
Введите &#39;license()&#39; для получения более подробной информации.

R -- это проект, в котором сотрудничает множество разработчиков.
Введите &#39;contributors()&#39; для получения дополнительной информации и
&#39;citation()&#39; для ознакомления с правилами упоминания R и его пакетов
в публикациях.

Введите &#39;demo()&#39; для запуска демонстрационных программ, &#39;help()&#39; -- для
получения справки, &#39;help.start()&#39; -- для доступа к справке через браузер.
Введите &#39;q()&#39;, чтобы выйти из R.

&amp;gt; args &amp;lt;- commandArgs(trailingOnly = T)
&amp;gt; print(args)
[1] &amp;quot;100&amp;quot;   &amp;quot;image&amp;quot;
&amp;gt; n &amp;lt;- as.integer(args[1])
&amp;gt; name &amp;lt;- args[2]
&amp;gt; 
&amp;gt; x &amp;lt;- rnorm(n)
&amp;gt; png(paste0(name, &amp;quot;.png&amp;quot;))
&amp;gt; plot(1:n, x)
&amp;gt; dev.off()
null device 
          1 
&amp;gt; summary(x)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
-2.3830 -0.5616  0.0813 -0.0322  0.5742  2.1000 
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А во втором случае:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;[1] &amp;quot;100&amp;quot;   &amp;quot;image&amp;quot;
null device 
          1 
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
-2.58000 -0.61260 -0.03309  0.05922  0.87230  1.72800 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь вернёмся к параметру
&lt;code&gt;trailingOnly&lt;/code&gt;
. Напишем ещё один скрипт (под названием
&lt;code&gt;printArgs.R&lt;/code&gt;
) для иллюстрации его работы:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;print(commandArgs(trailingOnly = F))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И вызовем его уже знакомыми нам инструментами (на этот раз вывод будет осуществляться на консоль):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Rterm.exe --no-restore --no-save --args 100 image &amp;lt;printArgs.R
Rscript.exe printArgs.R 100 image
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Первая команда даст нам:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;c:\\Program Files\\R\\R-3.0.0\\bin\\x64\\Rterm.exe&amp;quot;
[2] &amp;quot;--no-restore&amp;quot;                                      
[3] &amp;quot;--no-save&amp;quot;                                         
[4] &amp;quot;--args&amp;quot;                                            
[5] &amp;quot;100&amp;quot;                                               
[6] &amp;quot;image&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как можно видеть, помимо наших основных аргументов &lt;code&gt;100&lt;/code&gt; и &lt;code&gt;image&lt;/code&gt; в список также попали исполняемый файл &lt;code&gt;Rterm&lt;/code&gt; и передаваемые в него аргументы. Ниже представлен вывод второй команды:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;c:\\Program Files\\R\\R-3.0.0\\bin\\x64\\Rterm.exe&amp;quot;
[2] &amp;quot;--slave&amp;quot;                                           
[3] &amp;quot;--no-restore&amp;quot;                                      
[4] &amp;quot;--file=printArgs.R&amp;quot;                                
[5] &amp;quot;--args&amp;quot;                                            
[6] &amp;quot;100&amp;quot;                                               
[7] &amp;quot;image&amp;quot;                                             
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отсюда становится понятно, что &lt;code&gt;Rscript&lt;/code&gt; только и делает-то, что запускает &lt;code&gt;Rterm&lt;/code&gt; с параметрами &lt;code&gt;--slave&lt;/code&gt; (отключает приглашение и вывод текста выполняемых команд),
&lt;code&gt;--no-restore&lt;/code&gt; не нужно восстанавливать рабочее окружение), &lt;code&gt;--file&lt;/code&gt; (указывает выполняемый файл) и &lt;code&gt;--args&lt;/code&gt; (означает, что далее следуют настоящие аргументы для основного скрипта; если бы мы выставили &lt;code&gt;trailingOnly = T&lt;/code&gt;, то получили бы только их).&lt;/p&gt;
&lt;p&gt;Ниже представлена полная справка по использованию &lt;code&gt;Rterm&lt;/code&gt; и &lt;code&gt;Rscript&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;Rterm.exe --help
Usage: Rterm [options] [&amp;lt; infile] [&amp;gt; outfile] [EnvVars]

Start R, a system for statistical computation and graphics, with the
specified options

EnvVars: Environmental variables can be set by NAME=value strings

Options:
  -h, --help            Print usage message and exit
  --version             Print version info and exit
  --encoding=enc        Specify encoding to be used for stdin
  --encoding enc        ditto
  --save                Do save workspace at the end of the session
  --no-save             Don&#39;t save it
  --no-environ          Don&#39;t read the site and user environment files
  --no-site-file        Don&#39;t read the site-wide Rprofile
  --no-init-file        Don&#39;t read the .Rprofile or ~/.Rprofile files
  --restore             Do restore previously saved objects at startup
  --no-restore-data     Don&#39;t restore previously saved objects
  --no-restore-history  Don&#39;t restore the R history file
  --no-restore          Don&#39;t restore anything
  --vanilla             Combine --no-save, --no-restore, --no-site-file,
                          --no-init-file and --no-environ
  --max-mem-size=N      Set limit for memory to be used by R
  --max-ppsize=N        Set max size of protect stack to N
  -q, --quiet           Don&#39;t print startup message
  --silent              Same as --quiet
  --slave               Make R run as quietly as possible
  --verbose             Print more information about progress
  --internet2           Use Internet Explorer for proxies etc.
  --args                Skip the rest of the command line
  --ess                 Don&#39;t use getline for command-line editing
                          and assert interactive use
  -f file               Take input from &#39;file&#39;
  --file=file           ditto
  -e expression         Use &#39;expression&#39; as input

One or more -e options can be used, but not together with -f or --file

An argument ending in .RData (in any case) is taken as the path
to the workspace to be restored (and implies --restore)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;Rscript.exe -- help
Usage: /path/to/Rscript [--options] [-e expr] file [args]

--options accepted are
  --help              Print usage and exit
  --version           Print version and exit
  --verbose           Print information on progress
  --default-packages=list
                      Where &#39;list&#39; is a comma-separated set
                        of package names, or &#39;NULL&#39;
or options to R, in addition to --slave --no-restore, such as
  --save              Do save workspace at the end of the session
  --no-environ        Don&#39;t read the site and user environment files
  --no-site-file      Don&#39;t read the site-wide Rprofile
  --no-init-file      Don&#39;t read the user R profile
  --restore           Do restore previously saved objects at startup
  --vanilla           Combine --no-save, --no-restore, --no-site-file
                        --no-init-file and --no-environ

&#39;file&#39; may contain spaces but not shell metacharacters
&lt;/code&gt;&lt;/pre&gt;</description>
            </item>
            <item>
                <title>Шаблон диссертации в LaTeX</title>
                <link>http://aakinshin.net/ru/blog/education/phd-template/</link> 	
                <pubDate>Mon, 03 Jun 2013 00:02:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/education/phd-template/</guid>
                <description>&lt;p&gt;Написать диссертацию — дело нелёгкое. А оформить её ещё сложнее. Благо, есть LaTeX, который может нам в этом помочь. Но для начала было бы здорово обзавестись шаблоном, на основе которого можно было бы сразу приступить к написанию научной работы. Я такого шаблона не нашёл, поэтому решил сделать его сам, возможно кому-то пригодится: &lt;a href=&quot;https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template&quot;&gt;https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template&lt;/a&gt;. В шаблоне используется моя любимая кодировка UTF-8. Список литературы генерируется BibTeX-ом, а в отдельной папке аккуратно сложены всевозможные библиографические UTF-8-стили. Используются красивые PSCyr-шрифты, все наиболее часто используемые пакеты подключены. Помимо шаблона диссертации, проект также включает шаблоны автореферата, презентации и черновика для промежуточных наработок.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Операторы +=, -= в R</title>
                <link>http://aakinshin.net/ru/blog/r/compound-assignment/</link> 	
                <pubDate>Sun, 02 Jun 2013 23:59:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/compound-assignment/</guid>
                <description>&lt;p&gt;Продолжаем писать полезные операторы для языка R. В большинстве современных языков есть операторы +=, -= и т.п., они делают синтаксис более лаконичным. А давайте и в R определим подобные операторы, чтобы вместо&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;x &amp;lt;- x + 3
y &amp;lt;- y - 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;мы могли бы писать:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;x %+=% 3
y %-=% 2
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Да ведь это очень просто. Новые операторы можно определить буквально в пару строк:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;%+=%&#39; &amp;lt;- function(x, y) {
  mapply(assign, as.character(substitute(x)), x + y, MoreArgs = list(envir = parent.frame()))
  invisible()
}
&#39;%-=%&#39; &amp;lt;- function(x, y) {
  mapply(assign, as.character(substitute(x)), x - y, MoreArgs = list(envir = parent.frame()))
  invisible()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь можно писать такой вот код:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a &amp;lt;- 3
a %+=% 2 # a &amp;lt;- a + 2
a # 5
a %-=% 1 # a &amp;lt;- a - 1
a # 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Разумеется, ничего не мешает определить по аналогии %*=%, %/=% и тому подобные замечательные операторы.&lt;/p&gt;</description>
            </item>
            <item>
                <title>Множественное присваивание в R</title>
                <link>http://aakinshin.net/ru/blog/r/multiple-assignment/</link> 	
                <pubDate>Sun, 02 Jun 2013 23:58:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/multiple-assignment/</guid>
                <description>&lt;p&gt;R — мощный и лаконичный язык. С помощью коротких инструкций можно сделать очень многое. Но давайте сделаем R ещё лаконичнее.&lt;/p&gt;
&lt;p&gt;Чего мне всегда не хватало в R — так это множественного присваивания. Из-за отсутствия этой возможности приходится иногда писать не совсем красивый код для получения результата функции, который должен распределиться по нескольким переменным:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;x &amp;lt;- solve(matrix(c(2, 0, 0, 3), ncol=2), c(1, 1))
x1 &amp;lt;- x[1]
x2 &amp;lt;- x[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А вот было бы здорово если бы такие вещи можно было записывать в одну строчку, например так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;с(x1, x2) %=% solve(matrix(c(2, 0, 0, 3), ncol=2), c(1, 1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Нет ничего проще!&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Определим следующий бинарный оператор множественного присваивания:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&#39;%=%&#39; &amp;lt;- function(x, y) {
  x &amp;lt;- as.character(substitute(x)[-1])
  if (length(y) &amp;lt; length(x))
    y &amp;lt;- rep(y, ceiling(length(x) / length(y)))
  if (length(y) &amp;gt; length(x))
    y &amp;lt;- y[1:length(x)]
  mapply(assign, x, y, MoreArgs = list(envir = parent.frame()))
  invisible()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В лучших традициях R этот оператор устойчив к различным типам аргументов и к различной их длине. Все следующие инструкции будут прекрасно выполняться:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;c(u1, u2) %=% c(1, 2)
c(u3, u4) %=% c(3, 4, 5)
c(u5, u6) %=% list(&amp;quot;a&amp;quot;, 6)
c(u7, u8, u9) %=% list(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)
list(u10, u11, u12) %=% list(7, &amp;quot;second&amp;quot;, c(8, 9))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А чтобы не объявлять этот замечательный оператор каждый раз заново, вы можете один раз прописать его в &lt;a href=&quot;http://r-language.ru/articles/rprofile&quot;&gt;rprofile&lt;/a&gt;-файле и пользоваться им повсеместно в своих вычислениях!&lt;/p&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7519790/assign-multiple-new-variables-in-a-single-line-in-r&quot;&gt;Stackoverflow&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Progress bar в R</title>
                <link>http://aakinshin.net/ru/blog/r/progress-bar/</link> 	
                <pubDate>Sun, 02 Jun 2013 23:19:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/progress-bar/</guid>
                <description>&lt;p&gt;Давайте поговорим о долгих расчётах, ведь они не так редко встречаются в мире вычислений. Когда вы запускаете скрипт, который будет заведомо долго работать, то приятно смотреть на состояние прогресса. Эта информация поможет прикинуть время до конца вычислений (&lt;em&gt;&#171;осталось ещё 30%, я успею выпить чашку кофе&#187;&lt;/em&gt;
) или просигнализировать о бесконечном цикле (&lt;i&gt;&lt;em&gt;1438% выполнено, что-то пошло не так...&lt;/em&gt;&lt;/i&gt;
). Давайте научим наш скрипт сообщать пользователю о проценте выполненных работ.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Пусть у нас есть очень полезная функция, которая делает что-то очень важное некоторое время:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;foo &amp;lt;- function() {
  Sys.sleep(0.1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И эта функция запускается несколько раз:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (i in 1:10) {
  foo()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Казалось бы, самое простое решение — выводить на экран количество выполненных операцией:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (i in 1:10) {
  foo()
  print(i)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но такой фокус не всегда будет работать. Дело в том, что R любит буфферезировать вывод на консоль, т.е. не обязательно мы увидим вывод команды сразу после её выполнения. К счастью, &lt;a href=&quot;http://cran.r-project.org/bin/windows/rw-FAQ.html#The-output-to-the-console-seems-to-be-delayed&quot;&gt;есть способ&lt;/a&gt;, победить эту проблему — нам поможет строчка для обновления консоли: &lt;em&gt;flush.console()&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;for (i in 1:10) {
  foo()
  print(i)
  flush.console()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Решение работает, но оно не такое уж и красивое. Давайте сделаем настоящий progress bar. Для начала простенький, текстовый. Сделать это весьма просто:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;pb &amp;lt;- txtProgressBar(min = 0, max = 10, style = 3) # Создаём progress bar
for(i in 1:10){
   foo()
   setTxtProgressBar(pb, i) # Обновляем progress bar
}
close(pb) # Закрываем progress bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но можно пойти ещё дальше по пути к созданию прекраснейшего progress bar-а. А поможет нам в этом пакет tcltk:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;pb &amp;lt;- tkProgressBar(title = &amp;quot;progress bar&amp;quot;, min = 0,
                    max = 10, width = 300) # Создаём progress bar
 
for(i in 1:10){
   foo()
   setTkProgressBar(pb, i, label=paste(
                    round(i/10 * 100, 0), &amp;quot;% done&amp;quot;)) # Обновляем progress bar
}
close(pb) # Закрываем progress bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А для пользователей Windows можно предложить ещё один способ:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;pb &amp;lt;- winProgressBar(title = &amp;quot;progress bar&amp;quot;, min = 0,
                     max = 10, width = 300)  # Создаём progress bar
for(i in 1:10){
   foo()
   setWinProgressBar(pb, i, title=paste( 
                     round(i/10 * 100, 0), &amp;quot;% done&amp;quot;))  # Обновляем progress bar
}
close(pb)  # Закрываем progress bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/progress-bar/screen.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Ну вот и всё, теперь вы умеете создавать разнообразные progress bar-ы и делать процесс выполнения R-скрипта более информативным.&lt;/p&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ryouready.wordpress.com/2009/03/16/r-monitor-function-progress-with-a-progress-bar/&quot;&gt;R: Monitoring the function progress with a progress bar&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Rprofile — кастомизируем рабочее окружение</title>
                <link>http://aakinshin.net/ru/blog/r/rprofile/</link> 	
                <pubDate>Sun, 02 Jun 2013 23:17:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/rprofile/</guid>
                <description>&lt;p&gt;Давайте поговорим о задании окружения в R. Для этой цели имеется два волшебных файла:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Rprofile.site&lt;/code&gt; — глобальный файл настроек для всех сессий. Путь в Windows: &lt;code&gt;c:\Program Files\R\R-x.y.z\etc\Rprofile.site&lt;/code&gt;, путь в Linux: &lt;code&gt;/etc/R/Rprofile.site&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Rprofile&lt;/code&gt; — локальный файл настроек для текущей сессии. Лежит в домашней директории пользователя.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти файлы строятся единообразно, в них можно задать глобальные настройки окружения и объявить две полезных функции:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.First &amp;lt;- function() { ... }&lt;/code&gt; — функция, которая запускается в начале R-сессии&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Last &amp;lt;- function() { ... }&lt;/code&gt; — функция, которая запускается в конце R-сессии&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На Stackoverflow &lt;a href=&quot;http://stackoverflow.com/questions/1189759/expert-r-users-whats-in-your-rprofile&quot;&gt;можно посмотреть&lt;/a&gt; какие .Rprofile-файлы используют люди. Взглянем, что же можно полезного сделать в таком файле на небольших примерах. &lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;Подключение часто используемых пакетов&lt;/h3&gt;
&lt;p&gt;Есть ли у вас любимые пакеты, которые вы используете в каждой R-сессии? Вас утомляет каждый раз их импортировать? Так давай те же сделаем это единожды:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(ggplot2)
library(rgl)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Создание псевдонимов для часто используемых функций&lt;/h3&gt;
&lt;p&gt;А есть ли у вас любимые функции, которые вы вызываете очень часто? Их названия слишком длинные? Так давайте же создадим для них псевдонимы:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;s &amp;lt;- base::summary; # используем s(obj) вместо summary(obj)
h &amp;lt;- utils::head;   # используем h(obj) вместо head(obj)
n &amp;lt;- base::names;   # используем n(obj) вместо names(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Задание предпочитаемого репозитория&lt;/h3&gt;
&lt;p&gt;У стандартного репозитория &lt;a href=&quot;http://cran.r-project.org/&quot;&gt;CRAN&lt;/a&gt; есть много &lt;a href=&quot;http://cran.r-project.org/mirrors.html&quot;&gt;зеркал&lt;/a&gt;. Вы можете задать любимый репозиторий несколькими строчками кода:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt; local({r &amp;lt;- getOption(&amp;quot;repos&amp;quot;)
       r[&amp;quot;CRAN&amp;quot;] &amp;lt;- &amp;quot;http://cran.gis-lab.info/&amp;quot;
       options(repos=r)})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Задание основного языка&lt;/h3&gt;
&lt;p&gt;А давайте сделаем так, чтобы по умолчанию язык был английский:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;Sys.setenv(lang = &amp;quot;en&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Установка различных опций&lt;/h3&gt;
&lt;p&gt;Вы можете установить любые опции на свой вкус:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;options(papersize=&amp;quot;a4&amp;quot;)
options(editor=&amp;quot;notepad&amp;quot;)
options(pager=&amp;quot;internal&amp;quot;)
options(help_type=&amp;quot;html&amp;quot;)
options(&amp;quot;width&amp;quot;=160)
options(&amp;quot;digits.secs&amp;quot;=3)
options(prompt=&amp;quot;R&amp;gt; &amp;quot;, digits=4, show.signif.stars=FALSE)
&lt;/code&gt;&lt;/pre&gt;</description>
            </item>
            <item>
                <title>Конкатенация строк в R</title>
                <link>http://aakinshin.net/ru/blog/r/string-concatenation/</link> 	
                <pubDate>Sun, 02 Jun 2013 23:15:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/string-concatenation/</guid>
                <description>&lt;p&gt;Давайте поговорим о конкатенации строк. Новички в R пытаются пробовать стандартную конструкцию&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&amp;quot;a&amp;quot; + &amp;quot;b&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но их постигает неудача — R так не работает. Оператор плюс — это &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Arithmetic.html&quot;&gt;арифметическая операция&lt;/a&gt;, её нельзя применять к строкам. В R полагается использовать функцию &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/paste.html&quot;&gt;paste&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;paste (..., sep = &amp;quot; &amp;quot;, collapse = NULL)
paste0(..., collapse = NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Функция paste соединяет строки, разделяя их некоторым сепаратором sep (который по умолчанию равен пробелу), а paste0 — это её аналог с пустым оператором. Поясним примером:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;paste(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;) # &amp;quot;a b c&amp;quot;
paste0(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;) # &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Такой способ является стандартным, но многим он не по душе. Хочется иметь какой-нибудь бинарный оператор. Но ведь не обязательно это должен быть плюс (например, в PHP для конкатенации строк &lt;a href=&quot;http://php.net/manual/ru/language.operators.string.php&quot;&gt;используется точка&lt;/a&gt;). Но давайте будем придерживаться R-стилистики и создадим свой оператор &amp;quot;%+%&amp;quot;, который будет складывать строки. Сделать это очень просто:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&amp;quot;%+%&amp;quot; &amp;lt;- function(...){
  paste0(...)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь мы можем складывать строки, используя наш новый бинарный оператор:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&amp;quot;a&amp;quot; %+% &amp;quot;b&amp;quot; %+% &amp;quot;c&amp;quot; # &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Кроме того, этот оператор будет прекрасно работать и с векторами в лучших традициях R:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&amp;quot;a&amp;quot; %+% &amp;quot;b&amp;quot; %+% 1:3 # &amp;quot;ab1&amp;quot; &amp;quot;ab2&amp;quot; &amp;quot;ab3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ctszkin.com/2013/02/12/a-handy-concatenatio-operator/&quot;&gt;A handy concatenation operator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Рисуем комиксы в стиле xkcd</title>
                <link>http://aakinshin.net/ru/blog/r/xkcd/</link> 	
                <pubDate>Sun, 02 Jun 2013 23:11:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/xkcd/</guid>
                <description>&lt;p&gt;Многие слышали о таком замечательном комиксе, как &lt;a href=&quot;http://www.xkcd.com/&quot;&gt;xkcd&lt;/a&gt;. Это веб-комикс от &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BD%D1%80%D0%BE,_%D0%A0%D1%8D%D0%BD%D0%B4%D0%B5%D0%BB&quot;&gt;Рэндела Манро&lt;/a&gt; о романтике, сарказме, математике и языке. Для некоторых комиксов есть
&lt;a href=&quot;http://www.xkcd.ru/&quot;&gt;переводы на русский&lt;/a&gt;. Для поиска и просмотра ваших любимых комиксов в R есть отдельный пакет:
&lt;a href=&quot;http://cran.r-project.org/web/packages/RXKCD/index.html&quot;&gt;RXKCD&lt;/a&gt;. Давайте установим этот пакет и подключим его:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;install.packages(&amp;quot;RXKCD&amp;quot;)
library(&amp;quot;RXKCD&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Давайте поищем какой-нибудь комикс, а затем нарисуем его. Функция &lt;i&gt;searchXKCD&lt;/i&gt;
выдаст нам список всех комиксов, в описании которых встречается заданная фраза. А &lt;i&gt;getXKCD&lt;/i&gt;
выдаст нам полную информацию о комиксе по заданному номеру (включая рисование картинки).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;searchXKCD(&amp;quot;someone is wrong&amp;quot;)
getXKCD(386)
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;А теперь помимо стандартных комиксов научимся рисовать свои! &lt;!--more--&gt; Но только вот нарисовать целиком комикс будет не так просто, но вот график в стиле xkcd — проще простого. На Stackoverflow однажды был &lt;a href=&quot;http://stackoverflow.com/questions/12675147/how-can-we-make-xkcd-style-graphs-in-r&quot;&gt;вопрос&lt;/a&gt; о том, как это сделать. Прежде всего, нам понадобится основной шрифт комиксов xkcd — &lt;a href=&quot;http://r-language.ru/wp-admin/post.php?post=104&amp;amp;action=edit&amp;amp;message=10&quot;&gt;Humor-Sans&lt;/a&gt;. Чтобы работать с разными клёвыми шрифтами, нужно прописать следующие строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(extrafont)
loadfonts()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но в некоторых случаях конкретно с Humor-Sans у вас могут быть проблемы (подробнее можно почитать &lt;a href=&quot;http://www.r-bloggers.com/change-fonts-in-ggplot2-and-create-xkcd-style-graphs/&quot;&gt;тут&lt;/a&gt;). Если, например, &lt;a href=&quot;http://stackoverflow.com/questions/13989644/xkcd-style-graph-error-with-registered-fonts&quot;&gt;вы работаете на ОС Windows&lt;/a&gt;, то вам необходимо вручную &lt;a href=&quot;http://antiyawn.com/uploads/Humor-Sans.ttf&quot;&gt;скачать&lt;/a&gt; этот шрифт, а затем подключить его:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;font_import(paths = c(&amp;quot;path/to/humor-sans&amp;quot;))
loadfonts(device = &amp;quot;win&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь мы готовы нарисовать график. Для начала посмотрим способ через &lt;a href=&quot;http://ggplot2.org/&quot;&gt;ggplot2&lt;/a&gt;. Подготовим данные для рисования:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;data &amp;lt;- NULL
data$x &amp;lt;- seq(1, 10, 0.1)
data$y1 &amp;lt;- sin(data$x)
data$y2 &amp;lt;- cos(data$x)
data$xaxis &amp;lt;- -1.5
data &amp;lt;- as.data.frame(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь подключим ggplot2, подготовим тему для рисования xkcd-комиксов, нарисуем график и сохраним его в картинку:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(&amp;quot;ggplot2&amp;quot;)
 
# XKCD theme
theme_xkcd &amp;lt;- theme(
  panel.background = element_rect(fill=&amp;quot;white&amp;quot;), 
  axis.ticks = element_line(colour=NA),
  panel.grid = element_line(colour=&amp;quot;white&amp;quot;),
  axis.text.y = element_text(colour=NA), 
  axis.text.x = element_text(colour=&amp;quot;black&amp;quot;),
  text = element_text(size=16, family=&amp;quot;Humor Sans&amp;quot;)
)
 
# Plot the chart
p &amp;lt;- ggplot(data=data, aes(x=x, y=y1))+
  geom_line(aes(y=y2), position=&amp;quot;jitter&amp;quot;)+
  geom_line(colour=&amp;quot;white&amp;quot;, size=3, position=&amp;quot;jitter&amp;quot;)+
  geom_line(colour=&amp;quot;red&amp;quot;, size=1, position=&amp;quot;jitter&amp;quot;)+
  geom_text(family=&amp;quot;Humor Sans&amp;quot;, x=6, y=-1.2, label=&amp;quot;A SIN AND COS CURVE&amp;quot;)+
  geom_line(aes(y=xaxis), position = position_jitter(h = 0.005), colour=&amp;quot;black&amp;quot;)+
  scale_x_continuous(breaks=c(2, 5, 6, 9), 
                     labels = c(&amp;quot;YARD&amp;quot;, &amp;quot;STEPS&amp;quot;, &amp;quot;DOOR&amp;quot;, &amp;quot;INSIDE&amp;quot;))+labs(x=&amp;quot;&amp;quot;, y=&amp;quot;&amp;quot;)+
  theme_xkcd
 
# Save to png
ggsave(&amp;quot;xkcd_ggplot.jpg&amp;quot;, plot=p, width=8, height=5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Мы рассмотрели способ рисования графика через jitter-функциональность пакета ggplot2. А &lt;a href=&quot;http://stackoverflow.com/a/12680841/184842&quot;&gt;в другом ответе&lt;/a&gt; предлагается способ эмуляции рисования &amp;quot;от руки&amp;quot; вручную. Создаётся функция рисования линии:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;xkcd_line &amp;lt;- function(x, y, color) {
  len &amp;lt;- length(x);
  rg &amp;lt;- par(&amp;quot;usr&amp;quot;);
  yjitter &amp;lt;- (rg[4] - rg[3]) / 1000;
  xjitter &amp;lt;- (rg[2] - rg[1]) / 1000;
  x_mod &amp;lt;- x + rnorm(len) * xjitter;
  y_mod &amp;lt;- y + rnorm(len) * yjitter;
  lines(x_mod, y_mod, col=&#39;white&#39;, lwd=10);
  lines(x_mod, y_mod, col=color, lwd=5);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И функция рисования осей:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;xkcd_axis &amp;lt;- function() {
  rg &amp;lt;- par(&amp;quot;usr&amp;quot;);
  yaxis &amp;lt;- 1:100 / 100 * (rg[4] - rg[3]) + rg[3];
  xaxis &amp;lt;- 1:100 / 100 * (rg[2] - rg[1]) + rg[1];
  xkcd_line(1:100 * 0 + rg[1] + (rg[2]-rg[1])/100, yaxis,&#39;black&#39;)
  xkcd_line(xaxis, 1:100 * 0 + rg[3] + (rg[4]-rg[3])/100, &#39;black&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь давайте нарисуем простенький график:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;data &amp;lt;- data.frame(x=1:100)
data$one &amp;lt;- exp(-((data$x - 50)/10)^2)
data$two &amp;lt;- sin(data$x/10)
plot.new()
plot.window(
    c(min(data$x),max(data$x)),
    c(min(c(data$one,data$two)),max(c(data$one,data$two))))
xkcd_axis()
xkcd_line(data$x, data$one, &#39;red&#39;)
xkcd_line(data$x, data$two, &#39;blue&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В результате получим следующее изображение:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen3.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Есть и другие варианты рисования картинок в стилистике xkcd. &lt;a href=&quot;http://blog.phytools.org/2012/10/actual-xkcd-tree.html&quot;&gt;Например&lt;/a&gt;, можно рисовать древовидные структуры следующего вида:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen4.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;А поможет нам в этом пакет &lt;a href=&quot;http://cran.r-project.org/web/packages/phytools/index.html&quot;&gt;phytools&lt;/a&gt;. Пользоваться им достаточно просто. К примеру, вот такой код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;require(phytools)
require(&amp;quot;extrafont&amp;quot;)
tree&amp;lt;-read.tree(text=&amp;quot;((mammals,(birds,reptiles)),amphibians);&amp;quot;)
tree&amp;lt;-compute.brlen(tree)
xkcdTree(tree,file=&amp;quot;herpetology.pdf&amp;quot;,lwd=2,color=&amp;quot;black&amp;quot;, 
         dim=c(4,4),jitter=0.001,waver=c(0.03,0.03))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;даст нам такую вот замечательную картинку:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen5.png&quot; /&gt;
&lt;/p&gt;</description>
            </item>
            <item>
                <title>Cairo — делаем графики гладкими</title>
                <link>http://aakinshin.net/ru/blog/r/cairo/</link> 	
                <pubDate>Sun, 02 Jun 2013 22:58:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/cairo/</guid>
                <description>&lt;p&gt;R обладает богатейшим функционалом по формированию различных графиков. К сожалению, иногда графики получается не настолько красивыми, как бы нам хотелось. Давайте нарисуем график синуса:&lt;/p&gt;
&lt;p&gt;{% highlight r %}
x &amp;lt;- seq(0, 10, by = 0.1)
y &amp;lt;- sin(x)
plot(x, y, type=&amp;quot;l&amp;quot;)
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Если вы хорошо вглядитесь в это изображение, то увидите, что функция получилась не совсем гладкой. Дело в том, что стандартное графическое устройство не поддерживает &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%A1%D0%B3%D0%BB%D0%B0%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5&quot;&gt;anti-aliasing&lt;/a&gt;. Но не стоит грустить! Нам поможет &lt;em&gt;Cairo&lt;/em&gt;!  &lt;a href=&quot;http://ru.wikipedia.org/wiki/Cairo&quot;&gt;Cairo&lt;/a&gt; — это программная библиотека, предназначенная для рендеринга векторной графики с не зависящим от оборудования API. А для языка R есть &lt;a href=&quot;http://cran.r-project.org/web/packages/Cairo/index.html&quot;&gt;одноимённый пакет&lt;/a&gt;. Вы можете почитать &lt;a href=&quot;http://cran.r-project.org/web/packages/Cairo/Cairo.pdf&quot;&gt;документацию&lt;/a&gt; к этому пакету, но пока что мы посмотрим работу на примере. Для начала установим пакет и подключим его:&lt;/p&gt;
&lt;p&gt;{% highlight r %}
install.packages(&amp;quot;Cairo&amp;quot;)
library(&amp;quot;Cairo&amp;quot;)
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Допустим, я работаю под операционной системой Windows и хочу просто посмотреть на гладкий график функции. Нет ничего проще:&lt;/p&gt;
&lt;p&gt;{% highlight r %}
CairoWin()
plot(x, y, type=&amp;quot;l&amp;quot;)
{% endhighlight %}&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/cairo/sin.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;А теперь давайте ещё раз нарисуем наш график, но результат получим в виде png-файла:&lt;/p&gt;
&lt;p&gt;{% highlight r %}
CairoPNG(&amp;quot;sin.png&amp;quot;)
plot(x, y, type=&amp;quot;l&amp;quot;)
dev.off() # Завершаем формирование файла
{% endhighlight %}&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/cairo/sin-antialiasing.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;В Cairo-функциях можно указывать множество дополнительных параметров, таких как ширина и высота изображения, тип файла, его качество, цвет фона и многое другое. Конечно, для рабочего процесса Cairo не так уж и нужен, но при формировании отчётов о проделанной работе он поможет сделать ваши графики более привлекательными.&lt;/p&gt;</description>
            </item>
            <item>
                <title>R-ссылки</title>
                <link>http://aakinshin.net/ru/blog/r/links/</link> 	
                <pubDate>Sun, 02 Jun 2013 22:57:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/links/</guid>
                <description>&lt;h3&gt;Английские полезные R-ресурсы&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.r-project.org/&quot;&gt;R-project&lt;/a&gt; — официальный сайт&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cran.r-project.org/&quot;&gt;CRAN&lt;/a&gt; — официальный репозиторий пакетов&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.bioconductor.org/&quot;&gt;Bioconductor&lt;/a&gt; — ещё один репозиторий пакетов&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gallery.r-enthusiasts.com/&quot;&gt;R graph gallery&lt;/a&gt; — графическая галерея R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.inside-r.org/&quot;&gt;Inside-R&lt;/a&gt; — замечательно R-сообщество&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lib.stat.cmu.edu/R/CRAN/doc/manuals/fullrefman.pdf&quot;&gt;Full manual&lt;/a&gt; — полные оригинальные спецификации&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cookbook-r.com/&quot;&gt;R Cookbook&lt;/a&gt; — разные полезные R-сниппеты для решения типовых задач&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.statmethods.net/index.html&quot;&gt;Quick-R&lt;/a&gt; — краткий обзор языка&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://tryr.codeschool.com/&quot;&gt;Try R&lt;/a&gt; — online-обучалка основам языка&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rwiki.sciviews.org/doku.php&quot;&gt;R Wiki&lt;/a&gt; — небольшая вики про язык R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rseek.org/&quot;&gt;R Seek&lt;/a&gt; — поиск информации про R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://journal.r-project.org/&quot;&gt;R Journal&lt;/a&gt; — журнал про R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html&quot;&gt;Google&#39;s R Style Guide&lt;/a&gt; — стандарты оформления R-кода от Google&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mayin.org/ajayshah/KB/R/index.html&quot;&gt;R by example&lt;/a&gt; — подборка примеров использования R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html&quot;&gt;R FAQ&lt;/a&gt; — официальный FAQ&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hadley/devtools/wiki/Functional-programming&quot;&gt;Functional programming&lt;/a&gt; — учимся функциональному программированию на R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://crantastic.org/&quot;&gt;crantastic&lt;/a&gt; — ещё одно R-сообщество&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.omegahat.org/&quot;&gt;omegahat&lt;/a&gt; — ещё один R-репозиторий&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programmingr.com&quot;&gt;ProgrammingR.com&lt;/a&gt; — и ещё один полезный сайт&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://fractalswithr.blogspot.ru/&quot;&gt;fractalswithr&lt;/a&gt; — фракталы на R&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h3&gt;Английские блоги&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.r-bloggers.com&quot;&gt;R-bloggers.com&lt;/a&gt; — агрегатор блогов про R.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.revolutionanalytics.com/&quot;&gt;Revolutions&lt;/a&gt; — Learn more about using open source R for big data analysis, predictive modeling, data science and more from the staff of Revolution Analytics&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learnr.wordpress.com/&quot;&gt;Learning R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zvfak.blogspot.ru/&quot;&gt;Recipes, scripts and genomics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ryouready.wordpress.com/&quot;&gt;&amp;quot;R&amp;quot; you ready?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.decisionsciencenews.com/&quot;&gt;decisionsciencenews.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Русские полезные R-ресурсы&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.r-bloggers.com/lang/-/russian&quot;&gt;R-bloggers.com/lang/-/russian&lt;/a&gt; — агрегатор русских блогов про R.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://r-statistics.livejournal.com/&quot;&gt;Язык и среда R. Статистическое программное обеспечение&lt;/a&gt; — русскоязычное сообщество в ЖЖ про R.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://r-analytics.blogspot.ru/&quot;&gt;R: Анализ и визуализация данных&lt;/a&gt; — блог Сергея Мастицкого о языке программирования и системе статистических вычислений R, с вкраплениями более общих размышлений о прикладной статистике и моделировании.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://voliadis.ru/taxonomy/term/18&quot;&gt;Научный блог Волиадиса&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://quantviews.blogspot.ru/&quot;&gt;quantviews&lt;/a&gt; — про анализ и обработку экономических данных и все, что с этим может быть связано&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Полезные вопросы на &lt;a href=&quot;http://stackoverflow.com/questions/tagged/r&quot;&gt;Stackoverflow&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3505701/r-grouping-functions-sapply-vs-lapply-vs-apply-vs-tapply-vs-by-vs-aggrega&quot;&gt;R Grouping functions: sapply vs. lapply vs. apply. vs. tapply vs. by vs. aggregate vs&lt;/a&gt; — apply и его друзья&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/12675147/how-can-we-make-xkcd-style-graphs-in-r?goback=.gmp_77616.gde_77616_member_177069747&quot;&gt;How can we make xkcd style graphs in R?&lt;/a&gt; — рисуем графики от руки в стиле веб-комиска&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/192369/books-for-learning-the-r-language&quot;&gt;Books for learning the R language&lt;/a&gt; — хорошие книжки про R&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Хорошие посты на &lt;a href=&quot;http://habrahabr.ru/hub/r/&quot;&gt;Хабре&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/160373/&quot;&gt;Введение в R-project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/168817/&quot;&gt;Мой опыт введения в R или &#171;I Love R&#187;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/165337/&quot;&gt;Визуализация статистики использования компьютера с R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/163277/&quot;&gt;Параллелим R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/168399/&quot;&gt;Пример ускорения расчётов в R путём многопоточности&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/162583/&quot;&gt;Язык R в помощь хабра-статисту&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/140093/&quot;&gt;Анализируем Twitter при помощи R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/165305/R&quot;&gt;Динамическая визуализация геокодированных данных&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Интересные русские посты&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://quantviews.blogspot.ru/2013/02/choropleth-maps-rworldmap-r.html&quot;&gt;Построение страновых хороплет-карт (choropleth maps) с помощью пакета rworldmap в статистическом пакете R&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Интересные английские посты&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vis.supstat.com/2013/04/mathematical-annotation-in-r/&quot;&gt;LaTeX-подобные подписи к графикам&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://vis.supstat.com/2013/04/plotting-symbols-and-color-palettes/&quot;&gt;Шпаргалка по значкам для графиков и цветовым палитрам&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
            </item>
            <item>
                <title>Функции в R</title>
                <link>http://aakinshin.net/ru/blog/r/functions/</link> 	
                <pubDate>Sun, 02 Jun 2013 22:41:00 GMT</pubDate>
                <author>Андрей Акиньшин</author>
                <guid>http://aakinshin.net/ru/blog/r/functions/</guid>
                <description>&lt;style type=&quot;text/css&quot;&gt;.id{font-style:italic;} p{text-indent:0px;}&lt;/style&gt;
В R очень много разных полезных функций. И многие большие вещи можно сделать весьма быстро, написав очень мало кода. На официальном сайте есть замечательная шпаргалка на английском языке:
&lt;a href=&quot;http://cran.r-project.org/doc/contrib/Short-refcard.pdf&quot;&gt;R reference card&lt;/a&gt;
. В сети есть несколько вольных урезанных переводов, но они не очень удобные. Ниже вашему вниманию представляется русифицированная модифицированная версия обзора основных функций R. Команды снабжены ссылками на
&lt;a href=&quot;http://stat.ethz.ch/R-manual/&quot;&gt;online-мануал&lt;/a&gt;
.
&lt;!--more--&gt;
&lt;h1&gt;Помощь&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/help.html&quot;&gt;help(topic)&lt;/a&gt;
,
&lt;span class=&quot;id&quot;&gt;?topic&lt;/span&gt;
&amp;mdash; справка про
&lt;span class=&quot;id&quot;&gt;topic&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/help.search.html&quot;&gt;help.search(&quot;pattern&quot;)&lt;/a&gt;
,
&lt;span class=&quot;id&quot;&gt;??pattern&lt;/span&gt;
&amp;mdash; глобальный поиск
&lt;span class=&quot;id&quot;&gt;pattern&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/help.html&quot;&gt;help(package = )&lt;/a&gt;
&amp;mdash; справка о заданном пакете
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/help.start.html&quot;&gt;help.start()&lt;/a&gt;
&amp;mdash; запустить помощь в браузере
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-devel/library/utils/html/apropos.html&quot;&gt;apropos(what)&lt;/a&gt;
&amp;mdash; имена объектов, которые соответствуют
&lt;span class=&quot;id&quot;&gt;what&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-devel/library/base/html/args.html&quot;&gt;args(name)&lt;/a&gt;
&amp;mdash; аргументы команды
&lt;span class=&quot;id&quot;&gt;name&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-devel/library/utils/html/example.html&quot;&gt;example(topic)&lt;/a&gt;
&amp;mdash; примеры использования
&lt;span class=&quot;id&quot;&gt;topic&lt;/span&gt;
&lt;br /&gt;
&lt;h1&gt;Текущее окружение&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-devel/library/base/html/ls.html&quot;&gt;ls()&lt;/a&gt;
&amp;mdash; список всех объектов
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/rm.html&quot;&gt;rm(x)&lt;/a&gt;
&amp;mdash; удалить объект
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/list.files.html&quot;&gt;dir()&lt;/a&gt;
&amp;mdash; показать все файлы в текущей директории
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/getwd.html&quot;&gt;getwd()&lt;/a&gt;
&amp;mdash; получить текущую директорию
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/getwd.html&quot;&gt;setwd(dir)&lt;/a&gt;
&amp;mdash; поменять текущую директорию на
&lt;span class=&quot;id&quot;&gt;dir&lt;/span&gt;
&lt;br /&gt;
&lt;h1&gt;Общая работа с объектами&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/str.html&quot;&gt;str(object)&lt;/a&gt;
&amp;mdash; внутренняя структура объекта
&lt;span class=&quot;id&quot;&gt;object&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html&quot;&gt;summary(object)&lt;/a&gt;
&amp;mdash; общая информация об объекте
&lt;span class=&quot;id&quot;&gt;object&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/dput.html&quot;&gt;dput(x)&lt;/a&gt;
&amp;mdash; получить представление объекта в R-синтаксисе
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/head.html&quot;&gt;head(x)&lt;/a&gt;
&amp;mdash; посмотреть начальные строки объекта
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/head.html&quot;&gt;tail(x)&lt;/a&gt;
&amp;mdash; посмотреть последние строки объекта
&lt;br /&gt;
&lt;h1&gt;Ввод и вывод&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/library.html&quot;&gt;library(package)&lt;/a&gt;
&amp;mdash; подключить пакет
&lt;span class=&quot;id&quot;&gt;package&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/save.html&quot;&gt;save(file, ...)&lt;/a&gt;
&amp;mdash; сохраняет указанные объекты в двочином XDR-формате, который не зависит от платформы
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/load.html&quot;&gt;load()&lt;/a&gt;
&amp;mdash; загружает данные, сохранённые ранее с помощью команды
&lt;span class=&quot;id&quot;&gt;save()&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/read.table.html&quot;&gt;read.table&lt;/a&gt;
&amp;mdash; считывает таблицу данных и создаёт по ним
&lt;span class=&quot;id&quot;&gt;data.frame&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/write.table.html&quot;&gt;write.table&lt;/a&gt;
&amp;mdash; печатает объект, конвертируя его в
&lt;span class=&quot;id&quot;&gt;data.frame&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/read.table.html&quot;&gt;read.csv&lt;/a&gt;
&amp;mdash; считывает
&lt;span class=&quot;id&quot;&gt;csv&lt;/span&gt;
-файл
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/read.table.html&quot;&gt;read.delim&lt;/a&gt;
&amp;mdash; считывание данных, разделённых знаками табуляции
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/save.html&quot;&gt;save.image&lt;/a&gt;
&amp;mdash; сохраняет все объекты в файл
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cat.html&quot;&gt;cat(..., file= , sep= )&lt;/a&gt;
&amp;mdash; сохраняет аргументы, конкатенируя их через
&lt;span class=&quot;id&quot;&gt;sep&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sink.html&quot;&gt;sink(file)&lt;/a&gt;
&amp;mdash; выводит результаты выполнения других команд в файл в режиме реального времени до момента вызова этой же команды без аргументов
&lt;br /&gt;
&lt;h1&gt;Создание объектов&lt;/h1&gt;
&lt;span class=&quot;id&quot;&gt;from:to&lt;/span&gt;
&amp;mdash; генерирует последовательность чисел от
&lt;span class=&quot;id&quot;&gt;from&lt;/span&gt;
до
&lt;span class=&quot;id&quot;&gt;to&lt;/span&gt;
с шагом
&lt;span class=&quot;id&quot;&gt;1&lt;/span&gt;
, например
&lt;span class=&quot;id&quot;&gt;1:3&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/c.html&quot;&gt;с(...)&lt;/a&gt;
&amp;mdash; объединяет аргументы в вектор, например
&lt;span class=&quot;id&quot;&gt;c(1, 2, 3)&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/seq.html&quot;&gt;seq(from, to, by = )&lt;/a&gt;
&amp;mdash; генерирует последовательность числел от
&lt;span class=&quot;id&quot;&gt;from&lt;/span&gt;
до
&lt;span class=&quot;id&quot;&gt;to&lt;/span&gt;
с шагом
&lt;span class=&quot;id&quot;&gt;by&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/seq.html&quot;&gt;seq(from, to, len = )&lt;/a&gt;
&amp;mdash; генерирует последовательность числел от
&lt;span class=&quot;id&quot;&gt;from&lt;/span&gt;
до
&lt;span class=&quot;id&quot;&gt;to&lt;/span&gt;
длины
&lt;span class=&quot;id&quot;&gt;len&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/rep.html&quot;&gt;rep(x, times)&lt;/a&gt;
&amp;mdash; повторяет
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
ровно
&lt;span class=&quot;id&quot;&gt;times&lt;/span&gt;
раз
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/list.html&quot;&gt;list(...)&lt;/a&gt;
&amp;mdash; создаёт список объектов
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/data.frame.html&quot;&gt;data.frame(...)&lt;/a&gt;
&amp;mdash; создаёт фрейм данных
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/array.html&quot;&gt;array(data, dims)&lt;/a&gt;
&amp;mdash; создаёт из
&lt;span class=&quot;id&quot;&gt;data&lt;/span&gt;
многомерные массив размерностей
&lt;span class=&quot;id&quot;&gt;dim&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/matrix.html&quot;&gt;matrix(data, nrow = , ncol = , byrow = )&lt;/a&gt;
&amp;mdash; создаёт из
&lt;span class=&quot;id&quot;&gt;data&lt;/span&gt;
матрицу
&lt;span class=&quot;id&quot;&gt;nrow&lt;/span&gt;
на
&lt;span class=&quot;id&quot;&gt;ncol&lt;/span&gt;
, порядок заполнения определяется
&lt;span class=&quot;id&quot;&gt;byrow&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/factor.html&quot;&gt;factor(x, levels = )&lt;/a&gt;
&amp;mdash; создаёт из
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
фактор с уровнями
&lt;span class=&quot;id&quot;&gt;levels&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/gl.html&quot;&gt;gl(n, k, length = n*k, labels = 1:n)&lt;/a&gt;
&amp;mdash; создаёт фактор из
&lt;span class=&quot;id&quot;&gt;n&lt;/span&gt;
уровней, каждый из которых повторяется
&lt;span class=&quot;id&quot;&gt;k&lt;/span&gt;
раз длины
&lt;span class=&quot;id&quot;&gt;length&lt;/span&gt;
с именами
&lt;span class=&quot;id&quot;&gt;labels&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cbind.html&quot;&gt;rbind(...)&lt;/a&gt;
&amp;mdash; объединяет аргументы по строкам
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cbind.html&quot;&gt;cbind(...)&lt;/a&gt;
&amp;mdash; объединяет аргументы по столбцам
&lt;br /&gt;
&lt;h1&gt;Индексирование&lt;/h1&gt;
&lt;h4&gt;Векторы&lt;/h4&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td width=&quot;40%&quot;&gt;
			&lt;span class=&quot;id&quot;&gt;x[n]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;n&lt;/span&gt;
			-ый элемент
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[-n]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			все элементы, кроме
			&lt;span class=&quot;id&quot;&gt;n&lt;/span&gt;
			-го
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[1:n]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			первые
			&lt;span class=&quot;id&quot;&gt;n&lt;/span&gt;
			элементов
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[-(1:n)]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			все элементы, кроме первых
			&lt;span class=&quot;id&quot;&gt;n&lt;/span&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[c(1,4,2)]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;элементы с заданными индексами&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[&quot;name&quot;]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;элемент с заданным именем&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[x &gt; 3]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;все элементы, большие 3&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[x &gt; 3 &amp;amp; x &amp;lt; 5]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;все элементы между 3 и 5&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[x %in% c(&quot;a&quot;,&quot;and&quot;,&quot;the&quot;)]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;все элементы из заданного множества&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;h4&gt;Списки&lt;/h4&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td width=&quot;40%&quot;&gt;
			&lt;span class=&quot;id&quot;&gt;x[n]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			список, состоящий из элемента
			&lt;span class=&quot;id&quot;&gt;n&lt;/span&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[[n]]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;n&lt;/span&gt;
			-ый элемент списка
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[[&quot;name&quot;]]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			элемент списка с именем
			&lt;span class=&quot;id&quot;&gt;name&lt;/span&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x$name&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			элемент списка с именем
			&lt;span class=&quot;id&quot;&gt;name&lt;/span&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;h4&gt;Матрицы&lt;/h4&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td width=&quot;40%&quot;&gt;
			&lt;span class=&quot;id&quot;&gt;x[i, j]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			элемент на пересечении
			&lt;span class=&quot;id&quot;&gt;i&lt;/span&gt;
			-ой строки и
			&lt;span class=&quot;id&quot;&gt;j&lt;/span&gt;
			-го столбца
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[i,]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;i&lt;/span&gt;
			-ая строка
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[,j]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;j&lt;/span&gt;
			-ый столбец
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[,c(1,3)]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;заданное подмножество столбцов&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x[&quot;name&quot;, ]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			строка с именем
			&lt;span class=&quot;id&quot;&gt;name&lt;/span&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;h4&gt;Фреймы&lt;/h4&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td width=&quot;40%&quot;&gt;
			&lt;span class=&quot;id&quot;&gt;x[[&quot;name&quot;]]&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			столбец с именем
			&lt;span class=&quot;id&quot;&gt;name&lt;/span&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;span class=&quot;id&quot;&gt;x$name&lt;/span&gt;
		&lt;/td&gt;
		&lt;td&gt;
			столбец с именем
			&lt;span class=&quot;id&quot;&gt;name&lt;/span&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;h1&gt;Работа с переменными&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/array.html&quot;&gt;as.array(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/as.data.frame.html&quot;&gt;as.data.frame(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/numeric.html&quot;&gt;as.numeric(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/logical.html&quot;&gt;as.logical(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/complex.html&quot;&gt;as.complex(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/character.html&quot;&gt;as.character(x)&lt;/a&gt;
&amp;mdash; преобразование переменной к заданному типу
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/NA.html&quot;&gt;is.na(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/NULL.html&quot;&gt;is.null(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/array.html&quot;&gt;is.array(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/array.html&quot;&gt;is.data.frame(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/numeric.html&quot;&gt;is.numeric(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/complex.html&quot;&gt;is.complex(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/character.html&quot;&gt;is.character(x)&lt;/a&gt;
&amp;mdash; проверка на то, что данный объект обладает указанным типом
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/length.html&quot;&gt;length(x)&lt;/a&gt;
&amp;mdash; число элементов в
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/dim.html&quot;&gt;dim(x)&lt;/a&gt;
&amp;mdash; размерности объекта
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/dimnames.html&quot;&gt;dimnames(x)&lt;/a&gt;
&amp;mdash; имена размерностей объекта
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/nrow.html&quot;&gt;nrow(x)&lt;/a&gt;
&amp;mdash; число строк
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/nrow.html&quot;&gt;ncol(x)&lt;/a&gt;
&amp;mdash; число столбцов
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/class.html&quot;&gt;class(x)&lt;/a&gt;
&amp;mdash; класс объекта
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/class.html&quot;&gt;unclass(x)&lt;/a&gt;
&amp;mdash; удаляет атрибут класса у объекта
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/attr.html&quot;&gt;attr(x,which)&lt;/a&gt;
&amp;mdash; атрибут
&lt;span class=&quot;id&quot;&gt;which&lt;/span&gt;
объекта
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/attributes.html&quot;&gt;attributes(obj)&lt;/a&gt;
&amp;mdash; список атрибутов объекта
&lt;span class=&quot;id&quot;&gt;obj&lt;/span&gt;
&lt;br /&gt;
&lt;h1&gt;Манипуляция данными&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/which.min.html&quot;&gt;which.max(x)&lt;/a&gt;
&amp;mdash; индекс элемента с максимальным значением
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/which.min.html&quot;&gt;which.min(x)&lt;/a&gt;
&amp;mdash; индекс элемента с минимальным значением
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/rev.html&quot;&gt;rev(x)&lt;/a&gt;
&amp;mdash; реверсирует порядок элементов
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sort.html&quot;&gt;sort(x)&lt;/a&gt;
&amp;mdash; сортирует элементы объекта по возрастанию
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cut.html&quot;&gt;cut(x,breaks)&lt;/a&gt;
&amp;mdash; делит вектор на равные интервалы
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/match.html&quot;&gt;match(x, y)&lt;/a&gt;
&amp;mdash; ищет элементы
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
, которые есть в
&lt;span class=&quot;id&quot;&gt;y&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/which.html&quot;&gt;which(x == a)&lt;/a&gt;
&amp;mdash; возвращает порядковые элементы
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
, которые равны
&lt;span class=&quot;id&quot;&gt;a&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/na.fail.html&quot;&gt;na.omit(x)&lt;/a&gt;
&amp;mdash; исключает отсутствующие значения объекта
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/na.fail.html&quot;&gt;na.fail(x)&lt;/a&gt;
&amp;mdash; бросает исключение, если объект содержит отсутствующие значения
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/unique.html&quot;&gt;unique(x)&lt;/a&gt;
&amp;mdash; исключает из объекта повторяющиеся элементы
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/unique.html&quot;&gt;table(x)&lt;/a&gt;
&amp;mdash; создаёт таблицу с количеством повторений каждого уникального элемента
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/subset.html&quot;&gt;subset(x, ...)&lt;/a&gt;
&amp;mdash; возвращает подмножество элемента, которое соответствует заданному условию
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sample.html&quot;&gt;sample(x, size)&lt;/a&gt;
&amp;mdash; возвращает случайный набор размера
&lt;span class=&quot;id&quot;&gt;size&lt;/span&gt;
из элементов
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;h1&gt;Математика&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Trig.html&quot;&gt;
	sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(y, x)
&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Log.html&quot;&gt;log(x), log(x, base), log10(x), exp(x)&lt;/a&gt;
&amp;mdash; элементарные математические функции
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html&quot;&gt;min(x), max(x)&lt;/a&gt;
&amp;mdash; минимальный и максимальный элементы объекта
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/range.html&quot;&gt;range(x)&lt;/a&gt;
&amp;mdash; вектор из минимального и максимального элемента объекта
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html&quot;&gt;pmin(x, y), pmax(x, y)&lt;/a&gt;
&amp;mdash; возвращают вектор с минимальными (максимальными) для каждой пары x[i], y[i]
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sum.html&quot;&gt;sum(x)&lt;/a&gt;
&amp;mdash; сумма элементов объекта
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/prod.html&quot;&gt;prod(x)&lt;/a&gt;
&amp;mdash; произведение элементов объекта
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/diff.html&quot;&gt;diff(x)&lt;/a&gt;
&amp;mdash; возвращает вектор из разниц между соседними элементами
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/mean.html&quot;&gt;mean(x)&lt;/a&gt;
&amp;mdash; среднее арифметическое элементов объекта
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/median.html&quot;&gt;median(x)&lt;/a&gt;
&amp;mdash; медиана (средний элемент) объекта
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/weighted.mean.html&quot;&gt;weighted.mean(x, w)&lt;/a&gt;
&amp;mdash; средневзвешенное объекта x (
&lt;span class=&quot;id&quot;&gt;w&lt;/span&gt;
определяет веса)
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Round.html&quot;&gt;round(x, n)&lt;/a&gt;
&amp;mdash; округляет x до n знаков после запятой
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cumsum.html&quot;&gt;cumsum(x), cumprod(x), cummin(x), cummax(x)&lt;/a&gt;
&amp;mdash; кумулятивные суммы, произведения, минимумы и максимумы вектора x (i-ый элемент содержит статистику по элементам x[1:i])
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sets.html&quot;&gt;
	union(x, y), intersect(x, y), setdiff(x,y), setequal(x,y), is.element(el,set)
&lt;/a&gt;
&amp;mdash; операции над множествами: объединение, пересечение, разность, сравнение, принадлежность
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/complex.html&quot;&gt;Re(x), Im(x), Mod(x), Arg(x), Conj(x)&lt;/a&gt;
&amp;mdash; операции над комплексными числами: целая часть, мнимая часть, модуль, аргумент, сопряжённое число
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/fft.html&quot;&gt;fft(x), mvfft(x)&lt;/a&gt;
&amp;mdash; быстрое преобразование Фурье
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/which.html&quot;&gt;choose(n, k)&lt;/a&gt;
&amp;mdash; количество сочетаний
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/rank.html&quot;&gt;rank(x)&lt;/a&gt;
&amp;mdash; ранжирует элементы объекта
&lt;br /&gt;
&lt;h1&gt;Матрицы&lt;/h1&gt;
&lt;span class=&quot;id&quot;&gt;%*%&lt;/span&gt;
&amp;mdash; матричное умножение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/t.html&quot;&gt;t(x)&lt;/a&gt;
&amp;mdash; транспонированная матрица
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/diag.html&quot;&gt;diag(x)&lt;/a&gt;
&amp;mdash; диагональ матрицы
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/solve.html&quot;&gt;solve(a, b)&lt;/a&gt;
&amp;mdash; решает систему уравнений
&lt;span class=&quot;id&quot;&gt;a %*% x = b&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/solve.html&quot;&gt;solve(a)&lt;/a&gt;
&amp;mdash; обратная матрица
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/colSums.html&quot;&gt;colSums, rowSums, colMeans, rowMeans&lt;/a&gt;
&amp;mdash; суммы и средние по столбцам и по строкам
&lt;br /&gt;
&lt;h1&gt;Обработка данных&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/apply.html&quot;&gt;apply(X,INDEX,FUN=)&lt;/a&gt;
&amp;mdash; возвращает вектор, массив или список значений, полученных путем применения функции FUN к определенным элементам массива или матрицы x; подлежащие обработке элементы х указываются при помощи аргумента MARGIN;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/lapply.html&quot;&gt;lapply(X,FUN)&lt;/a&gt;
&amp;mdash; возвращает список той же длины, что и х; при этом значения в новом списке будут результатом применения функции FUN к элементам исходного объекта х
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/tapply.html&quot;&gt;tapply(X,INDEX,FUN=)&lt;/a&gt;
&amp;mdash;  применяет функцию FUN к каждой совокупности значений х, созданной в соответствии с уровнями определенного фактора; перечень факторов указывается при помощи аргумента INDEX
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/by.html&quot;&gt;by(data,INDEX,FUN)&lt;/a&gt;
&amp;mdash; аналог tapply(), применяемый к таблицам данных
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/merge.html&quot;&gt;merge(a,b)&lt;/a&gt;
&amp;mdash; объединяет две таблицы данных (а и b) по общим столбцами или строкам
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/aggregate.html&quot;&gt;aggregate(x,by,FUN)&lt;/a&gt;
&amp;mdash; разбивает таблицу данных х на отдельные наборы данных, применяет к этим наборам определенную функцию FUN и возвращает результат в удобном для чтения формате
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/stack.html&quot;&gt;stack(x, ...)&lt;/a&gt;
&amp;mdash; преобразует данные, представленные в объекте х в виде отдельных столбцов, в таблицу данных
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/stack.html&quot;&gt;unstack(x, ...)&lt;/a&gt;
&amp;mdash;  выполняет операцию, обратную действию функции stack()
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/reshape.html&quot;&gt;reshape(x, ...)&lt;/a&gt;
&amp;mdash; преобразует таблицу данных из &quot;широкого формата&quot; (повторные измерения какой-либо величины записаны в отдельных столбцах таблицы) в таблицу &quot;узкого формата&quot; (повторные измерения идут одно под одним в пределах одного столбца)
&lt;br /&gt;
&lt;h1&gt;Строки&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/print.html&quot;&gt;print(x)&lt;/a&gt;
&amp;mdash; выводит на экран
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sprintf.html&quot;&gt;sprintf(fmt, ...)&lt;/a&gt;
&amp;mdash; форматирование текста в
&lt;span class=&quot;id&quot;&gt;C-style&lt;/span&gt;
(можно использовать
&lt;span class=&quot;id&quot;&gt;%s, %.5f&lt;/span&gt;
и т.п.)
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/format.html&quot;&gt;format(x)&lt;/a&gt;
&amp;mdash; форматирует объект
&lt;span class=&quot;id&quot;&gt;x&lt;/span&gt;
так, чтобы он выглядел красиво при выводе на экран
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/paste.html&quot;&gt;paste(...)&lt;/a&gt;
&amp;mdash; конвертирует векторы в текстовые переменные и объединяет их в одно текстовое выражение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/substr.html&quot;&gt;substr(x,start,stop)&lt;/a&gt;
&amp;mdash; получение подстроки
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/strsplit.html&quot;&gt;strsplit(x,split)&lt;/a&gt;
&amp;mdash; разбивает строку х на подстроки в соответствии с split
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/grep.html&quot;&gt;grep(pattern,x)&lt;/a&gt;
&amp;mdash; поиск по регулярному выражению
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/grep.html&quot;&gt;gsub(pattern,replacement,x)&lt;/a&gt;
&amp;mdash; замена по регулярному выражению
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/chartr.html&quot;&gt;tolower(x)&lt;/a&gt;
&amp;mdash; привести строку к нижнему регистру
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/chartr.html&quot;&gt;toupper(x)&lt;/a&gt;
&amp;mdash; привести строку к верхнему регистру
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/match.html&quot;&gt;match(x,table)&lt;/a&gt;
,
&lt;span class=&quot;id&quot;&gt;x %in% table&lt;/span&gt;
&amp;mdash; выполняет поиск элементов в векторе table, которые совпадают со значениями из вектора х
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/pmatch.html&quot;&gt;pmatch(x,table)&lt;/a&gt;
&amp;mdash; выполняет поиск элементов в векторе table, которые частично совпадают с элементами вектора х
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/nchar.html&quot;&gt;nchar(x)&lt;/a&gt;
&amp;mdash; возвращает количество знаков в строке х
&lt;br /&gt;
&lt;h1&gt;Дата и время&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/as.Date.html&quot;&gt;as.Date(s)&lt;/a&gt;
&amp;mdash; конвертирует вектор s в объект класса Date
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/as.POSIXlt.html&quot;&gt;as.POSIXct(s)&lt;/a&gt;
&amp;mdash; конвертирует вектор s в объект класса POSIXct
&lt;br /&gt;
&lt;h1&gt;Рисование графиков&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/plot.html&quot;&gt;plot(x)&lt;/a&gt;
&amp;mdash; график x
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/plot.html&quot;&gt;plot(x, y)&lt;/a&gt;
&amp;mdash; график зависимости y от x
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/hist.html&quot;&gt;hist(x)&lt;/a&gt;
&amp;mdash; гистограмма
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/barplot.html&quot;&gt;barplot(x)&lt;/a&gt;
&amp;mdash; столбчатая диаграмма
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/dotchart.html&quot;&gt;dotchart(x)&lt;/a&gt;
&amp;mdash; диаграмма Кливленда
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/pie.html&quot;&gt;pie(x)&lt;/a&gt;
&amp;mdash; круговая диаграмма
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/boxplot.html&quot;&gt;boxplot(x)&lt;/a&gt;
&amp;mdash; график типа &quot;коробочки с усами&quot;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/sunflowerplot.html&quot;&gt;sunflowerplot(x, y)&lt;/a&gt;
&amp;mdash; то же, что и plot(), однако точки с одинаковыми координатами изображаются в виде &quot;ромашек&quot;, количество лепестков у которых пропорционально количеству таких точек
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/coplot.html&quot;&gt;coplot(x˜y | z)&lt;/a&gt;
&amp;mdash; график зависимости y от x для каждого интервала значений z
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/interaction.plot.html&quot;&gt;interaction.plot(f1, f2, y)&lt;/a&gt;
&amp;mdash; если f1 и f2 &amp;mdash; факторы, эта фукнция создаст график со средними значениями y в соответствии со значениями f1 (по оси х) и f2 (по оси у, разные кривые)
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/matplot.html&quot;&gt;matplot(x, y)&lt;/a&gt;
&amp;mdash; график зависимости столбцов y от столбцов x
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/fourfoldplot.html&quot;&gt;fourfoldplot(x)&lt;/a&gt;
&amp;mdash; изображает (в виде частей окружности) связь между двумя бинарными переменными в разных совокупностях
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/assocplot.html&quot;&gt;assocplot(x)&lt;/a&gt;
&amp;mdash; график Кохена-Френдли
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/mosaicplot.html&quot;&gt;mosaicplot(x)&lt;/a&gt;
&amp;mdash; мозаичный график остатков лог-линейной регрессии
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/pairs.html&quot;&gt;pairs(x)&lt;/a&gt;
&amp;mdash;  если х - матрица или таблица данных, эта функция изобразит диаграммы рассеяния для всех возможных пар переменных из х
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/plot.ts.html&quot;&gt;plot.ts(x)&lt;/a&gt;
,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/ts.plot.html&quot;&gt;ts.plot(x)&lt;/a&gt;
&amp;mdash; изображает временной ряд
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/qqnorm.html&quot;&gt;qqnorm(x)&lt;/a&gt;
&amp;mdash; квантили
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/qqnorm.html&quot;&gt;qqplot(x, y)&lt;/a&gt;
&amp;mdash; график зависимости квантилей y от квантилей х
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/contour.html&quot;&gt;contour(x, y, z)&lt;/a&gt;
&amp;mdash; выполняет интерполяцию данных и создает контурный график
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/filled.contour.html&quot;&gt;filled.contour(x, y, z)&lt;/a&gt;
&amp;mdash;  то же, что contour(), но заполняет области между контурами определёнными цветами
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/image.html&quot;&gt;image(x, y, z)&lt;/a&gt;
&amp;mdash; изображает исходные данные в виде квадратов, цвет которых определяется значениями х и у
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/persp.html&quot;&gt;persp(x, y, z)&lt;/a&gt;
&amp;mdash; то же, что и image(), но в виде трехмерного графика
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/stars.html&quot;&gt;stars(x)&lt;/a&gt;
&amp;mdash; если x - матрица или таблица данных, изображает график в виде &quot;звезд&quot; так, что каждая строка представлена &quot;звездой&quot;, а столбцы задают длину сегментов этих &quot;звезд&quot;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/symbols.html&quot;&gt;symbols(x, y, ...)&lt;/a&gt;
&amp;mdash;  изображает различные символы в соответствии с координатами
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/termplot.html&quot;&gt;termplot(mod.obj)&lt;/a&gt;
&amp;mdash; зображает частные эффекты переменных из регрессионной модели
&lt;br /&gt;
&lt;h1&gt;Рисование графиков на низком уровне&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/points.html&quot;&gt;points(x, y)&lt;/a&gt;
&amp;mdash; рисование точек
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/lines.html&quot;&gt;lines(x, y)&lt;/a&gt;
&amp;mdash; рисование линии
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/text.html&quot;&gt;text(x, y, labels, ...)&lt;/a&gt;
&amp;mdash; добавление текстовой надписи
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/mtext.html&quot;&gt;mtext(text, side=3, line=0, ...)&lt;/a&gt;
&amp;mdash; добавление текстовой надписи
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/segments.html&quot;&gt;segments(x0, y0, x1, y1)&lt;/a&gt;
&amp;mdash; рисование отрезка
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/arrows.html&quot;&gt;arrows(x0, y0, x1, y1, angle= 30, code=2)&lt;/a&gt;
&amp;mdash; рисование стрелочки
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/abline.html&quot;&gt;abline(a,b)&lt;/a&gt;
&amp;mdash; рисование наклонной прямой
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/abline.html&quot;&gt;abline(h=y)&lt;/a&gt;
&amp;mdash; рисование вертикальной прямой
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/abline.html&quot;&gt;abline(v=x)&lt;/a&gt;
&amp;mdash; рисование горизонтальной прямой
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/abline.html&quot;&gt;abline(lm.obj)&lt;/a&gt;
&amp;mdash; рисование регрессионной прямой
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/rect.html&quot;&gt;rect(x1, y1, x2, y2)&lt;/a&gt;
&amp;mdash; рисование прямоугольника
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/polygon.html&quot;&gt;polygon(x, y)&lt;/a&gt;
&amp;mdash; рисование многоугольника
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/legend.html&quot;&gt;legend(x, y, legend)&lt;/a&gt;
&amp;mdash; добавление легенды
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/title.html&quot;&gt;title()&lt;/a&gt;
&amp;mdash; добавление заголовка
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/axis.html&quot;&gt;axis(side, vect)&lt;/a&gt;
&amp;mdash; добавление осей
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/rug.html&quot;&gt;rug(x)&lt;/a&gt;
&amp;mdash; рисование засечек на оси X
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/locator.html&quot;&gt;locator(n, type = &quot;n&quot;, ...)&lt;/a&gt;
&amp;mdash; возвращает координаты на графике, в которые кликнул пользователь
&lt;br /&gt;
&lt;h1&gt;Lattice-графика&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;xyplot(y˜x)&lt;/a&gt;
&amp;mdash; график зависимости у от х
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;barchart(y˜x)&lt;/a&gt;
&amp;mdash; столбчатая диаграмма
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;dotplot(y˜x)&lt;/a&gt;
&amp;mdash; диаграмма Кливленда
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/histogram.html&quot;&gt;densityplot(˜x)&lt;/a&gt;
&amp;mdash; график плотности распределения значений х
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/histogram.html&quot;&gt;histogram(˜x)&lt;/a&gt;
&amp;mdash; гистограмма значений х
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;bwplot(y˜x)&lt;/a&gt;
&amp;mdash; график типа &quot;коробочки с усами&quot;
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/qqmath.html&quot;&gt;qqmath(˜x)&lt;/a&gt;
&amp;mdash; аналог функции qqnorm()
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;stripplot(y˜x)&lt;/a&gt;
&amp;mdash; аналог функции stripplot(x)
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/qq.html&quot;&gt;qq(y˜x)&lt;/a&gt;
&amp;mdash; изображает квантили распределений х и у для визуального сравнения этих распределений; переменная х должна быть числовой, переменная у - числовой, текстовой, или фактором с двумя уровнями
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/splom.html&quot;&gt;splom(˜x)&lt;/a&gt;
&amp;mdash; матрица диаграмм рассеяния (аналог функции pairs())
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/levelplot.html&quot;&gt;levelplot(z˜x*y|g1*g2)&lt;/a&gt;
&amp;mdash;  цветной график значений z, координаты которых заданы переменными х и у (очевидно, что x, y и z должны иметь одинаковую длину); g1, g2... (если присутствуют) &amp;mdash;  факторы или числовые переменные, чьи значения автоматически разбиваются на равномерные отрезки
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/cloud.html&quot;&gt;wireframe(z˜x*y|g1*g2)&lt;/a&gt;
&amp;mdash; функция для построения трехмерных диаграмм рассеяния и плоскостей; z, x и у - числовые векторы; g1, g2... (если присутствуют) - факторы или числовые переменные, чьи значения автоматически разбиваются на равномерные отрезки
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/cloud.html&quot;&gt;cloud(z˜x*y|g1*g2)&lt;/a&gt;
&amp;mdash; трёхмерная диаграмма рассеяния
&lt;br /&gt;
&lt;h1&gt;Оптимизация и подбор параметров&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/optim.html&quot;&gt;optim(par, fn, method = )&lt;/a&gt;
&amp;mdash; оптимизация общего назначения
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/nlm.html&quot;&gt;nlm(f,p)&lt;/a&gt;
&amp;mdash; минимизация функции f алгоритмом Ньютона
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html&quot;&gt;lm(formula)&lt;/a&gt;
&amp;mdash; подгонка линейной модели
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/glm.html&quot;&gt;glm(formula,family=)&lt;/a&gt;
&amp;mdash; подгонка обобщённой линейной модели
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/nls.html&quot;&gt;nls(formula)&lt;/a&gt;
&amp;mdash; нелинейный метод наименьших квадратов
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/approxfun.html&quot;&gt;approx(x,y=)&lt;/a&gt;
&amp;mdash; линейная интерполяция
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/splinefun.html&quot;&gt;spline(x,y=)&lt;/a&gt;
&amp;mdash; интерполяция кубическими сплайнами
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/loess.html&quot;&gt;loess(formula)&lt;/a&gt;
&amp;mdash; подгонка полиномиальной поверхности
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/predict.html&quot;&gt;predict(fit,...)&lt;/a&gt;
&amp;mdash; построение прогнозов
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/coef.html&quot;&gt;coef(fit)&lt;/a&gt;
&amp;mdash; расчётные коэффициенты
&lt;br /&gt;
&lt;h1&gt;Статистика&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/sd.html&quot;&gt;sd(x)&lt;/a&gt;
&amp;mdash; стандартное отклонение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html&quot;&gt;var(x)&lt;/a&gt;
&amp;mdash; дисперсия
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html&quot;&gt;cor(x)&lt;/a&gt;
&amp;mdash; корреляционная матрица
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html&quot;&gt;var(x, y)&lt;/a&gt;
&amp;mdash; ковариация между x и y
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html&quot;&gt;cor(x, y)&lt;/a&gt;
&amp;mdash; линейная корреляция между x и y
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/aov.html&quot;&gt;aov(formula)&lt;/a&gt;
&amp;mdash; дисперсионный анализ
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/anova.html&quot;&gt;anova(fit,...)&lt;/a&gt;
&amp;mdash; дисперсионный анализ для подогнанных моделей fit
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/density.html&quot;&gt;density(x)&lt;/a&gt;
&amp;mdash; ядерные плотности вероятностей
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/binom.test.html&quot;&gt;binom.test()&lt;/a&gt;
&amp;mdash; точный тест простой гипотезы о вероятности успеха в испытаниях Бернулли
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/pairwise.t.test.html&quot;&gt;pairwise.t.test()&lt;/a&gt;
&amp;mdash; попарные сравнения нескольки независимых или зависимых выборок
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/prop.test.html&quot;&gt;prop.test()&lt;/a&gt;
&amp;mdash;  проверка гипотезы о том, что частоты какого-либо признака равны во всех анализируемых группах
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/t.test.html&quot;&gt;t.test()&lt;/a&gt;
&amp;mdash; тест Стьюдента
&lt;br /&gt;
&lt;h1&gt;Распределения&lt;/h1&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Normal.html&quot;&gt;rnorm(n, mean=0, sd=1)&lt;/a&gt;
&amp;mdash; нормальное распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Exponential.html&quot;&gt;rexp(n, rate=1)&lt;/a&gt;
&amp;mdash; экспоненциальное распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/GammaDist.html&quot;&gt;rgamma(n, shape, scale=1)&lt;/a&gt;
&amp;mdash; гамма-распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Poisson.html&quot;&gt;rpois(n, lambda)&lt;/a&gt;
&amp;mdash; распределение Пуассона
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Weibull.html&quot;&gt;rweibull(n, shape, scale=1)&lt;/a&gt;
&amp;mdash; распределение Вейбулла
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Cauchy.html&quot;&gt;rcauchy(n, location=0, scale=1)&lt;/a&gt;
&amp;mdash; распределение Коши
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Beta.html&quot;&gt;rbeta(n, shape1, shape2)&lt;/a&gt;
&amp;mdash; бета-распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/TDist.html&quot;&gt;rt(n, df)&lt;/a&gt;
&amp;mdash; распределение Стьюдента
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Fdist.html&quot;&gt;rf(n, df1, df2)&lt;/a&gt;
&amp;mdash; распределение Фишера
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Chisquare.html&quot;&gt;rchisq(n, df)&lt;/a&gt;
&amp;mdash; распределение Пирсона
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Binomial.html&quot;&gt;rbinom(n, size, prob)&lt;/a&gt;
&amp;mdash; биномиальное распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Geometric.html&quot;&gt;rgeom(n, prob)&lt;/a&gt;
&amp;mdash; геометрическое распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Hypergeometric.html&quot;&gt;rhyper(nn, m, n, k)&lt;/a&gt;
&amp;mdash; гипергеометрическое распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Logistic.html&quot;&gt;rlogis(n, location=0, scale=1)&lt;/a&gt;
&amp;mdash; логистическое распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Lognormal.html&quot;&gt;rlnorm(n, meanlog=0, sdlog=1)&lt;/a&gt;
&amp;mdash; логнормальное распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/NegBinomial.html&quot;&gt;rnbinom(n, size, prob)&lt;/a&gt;
&amp;mdash; отрицательное биномиальное распределение
&lt;br /&gt;
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Uniform.html&quot;&gt;runif(n, min=0, max=1)&lt;/a&gt;
&amp;mdash; равномерное распределение
&lt;br /&gt;
&lt;h1&gt;Программирование&lt;/h1&gt;
Работа с функциями:
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;function(arglist) { expr }&lt;/span&gt;
&amp;mdash; создание пользовательской функции
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;return(value)&lt;/span&gt;
&amp;mdash; возвращение значения
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;do.call(funname, args)&lt;/span&gt;
&amp;mdash; вызывает функцию по имени
&lt;br /&gt;
Условные операторы: &amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;if(cond) expr&lt;/span&gt;
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;if(cond) cons.expr else alt.expr&lt;/span&gt;
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;ifelse(test, yes, no)&lt;/span&gt;
&lt;br /&gt;
Циклы: &amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;for(var in seq) expr&lt;/span&gt;
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;while(cond) expr&lt;/span&gt;
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;repeat expr&lt;/span&gt;
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;break&lt;/span&gt;
&amp;mdash; остановка цикла
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;span class=&quot;id&quot;&gt;next&lt;/span&gt;
&amp;mdash; переход к следующей итерации
&lt;br /&gt;</description>
            </item>

  </channel> 
</rss>