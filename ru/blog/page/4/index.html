<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta name="description" content="Блог Андрея Акиньшина">
    <meta name="author" content="Andrey Akinshin">
    <link href="/img/favicon.ico" rel="icon" type="image/x-icon"/>
    <meta name="keywords" content=''>

    <title>Блог Андрея Акиньшина</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">

    <!-- Custom styles -->
    <link href="/css/about.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/blog.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/highlight.css" rel="stylesheet" type="text/css" media="all">

    <!-- Feeds -->
    <link href="/ru/rss.xml" type="application/rss+xml" rel="alternate" title="Blog RSS Feed" />
    <link href="/ru/atom.xml" type="application/atom+xml" rel="alternate" title="Blog ATOM Feed" />

    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-41419012-5', 'auto');
      ga('send', 'pageview');
    </script>
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter28700916 = new Ya.Metrika({id:28700916,
                        clickmap:true,
                        trackLinks:true,
                        accurateTrackBounce:true});
            } catch(e) { }
        });
        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";
        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
    </script>
    <!-- /Yandex.Metrika counter -->
    <!-- Disqus -->
    <script id="dsq-count-scr" src="//aakinshinnet-ru.disqus.com/count.js" async></script>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
  </head>

  <body>
     <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link" id="nav-link-blog" href="/ru/blog/">Блог</a>
          <a class="nav-link" id="nav-link-blog-content" href="/ru/blog/content/">Содержание</a>
          <a class="nav-link" id="nav-link-about" href="/ru/about/">Об авторе </a>
          <a class="nav-link" href='/blog/''>English version</a>
        </nav>
      </div>
    </div>

    <div class="container">
      <p style="font-size:150%"><a href="/blog/">Последние посты доступны только в английской версии блога</a></p>
<hr />
<div class="blog-main">
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/arrays-internal-structure/'>Внутреннее устройство массивов в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 11 октября 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/blog/tag/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/blog/tag/arrays"><span class="badge badge-pill badge-info">Arrays</span></a>
        </span><br /><br />
        <p>Иногда бывает полезно понимать, как выглядит внутреннее представление объектов, с которыми мы работаем. В этой статье я хотел бы поговорить о массивах: как именно они хранятся в памяти, какие IL-команды используются для работы с ними, как выглядит ассемблерный код при обращении к их элементам. Я рассмотрю три вида массивов: single (<code>T[]</code>), rectangular (<code>T[,]</code>), jagged (<code>T[][]</code>). Также будет затронута тема массивов с ненулевой нижней границей (<code>T[*]</code>) и нюансов работы с ними.</p>
        <a href='/ru/blog/post/arrays-internal-structure/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/arrays-internal-structure/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/cheatsheet-rounding/'>Учимся округлять в C#</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 18 сентября 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/blog/tag/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/blog/tag/rounding"><span class="badge badge-pill badge-info">Rounding</span></a>
                <a href="/ru/blog/tag/cheatsheet"><span class="badge badge-pill badge-info">CheatSheet</span></a>
        </span><br /><br />
        <p>А знаете ли вы, что <code>Math.Round(1.5) == Math.Round(2.5) == 2</code>? Можете ли сходу сказать, сколько будет <code>-7%3</code> и <code>7%-3</code>? Помните ли, чем отличаются
<code>Math.Round</code>, <code>Math.Floor</code>, <code>Math.Ceiling</code>, <code>Math.Truncate</code>? А как происходит округление при использовании <code>string.Format</code>? Давайте немного погрузимся в мир округлений и разберёмся с нюансами, которые не для всех могут быть очевидными.</p>
        <a href='/ru/blog/post/cheatsheet-rounding/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/cheatsheet-rounding/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/typehandle/'>Вся правда о TypeHandle в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 14 сентября 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/blog/tag/clr"><span class="badge badge-pill badge-info">CLR</span></a>
                <a href="/ru/blog/tag/cli"><span class="badge badge-pill badge-info">CLI</span></a>
                <a href="/ru/blog/tag/typehandle"><span class="badge badge-pill badge-info">TypeHandle</span></a>
                <a href="/ru/blog/tag/methodtable"><span class="badge badge-pill badge-info">MethodTable</span></a>
                <a href="/ru/blog/tag/typedesc"><span class="badge badge-pill badge-info">TypeDesc</span></a>
        </span><br /><br />
        <p>В разных умных книжках и статьях про .NET я часто наталкивался на упоминания про TypeHandle. Чаще всего пишут, что у каждого .NET-объекта в заголовке находится некоторый TypeHandle, который представляет собой ссылку на тип. Ещё пишут, что TypeHandle — это всегда указатель на таблицу методов типа. А в некоторых местах мне доводилось встречать информацию о том, что TypeHandle указывает на некий TypeDesc. В общем, я устал от неразберихи: давайте вместе разберёмся что к чему. А для этого нам придётся немного подизассемблировать, поизучать дампы памяти и залезть в исходники CLI.</p>
        <a href='/ru/blog/post/typehandle/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/typehandle/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/arrays-access-performance/'>Сравнение производительности массивов в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 31 августа 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/blog/tag/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/blog/tag/benchmarking"><span class="badge badge-pill badge-info">Benchmarking</span></a>
                <a href="/ru/blog/tag/asm"><span class="badge badge-pill badge-info">ASM</span></a>
                <a href="/ru/blog/tag/jit"><span class="badge badge-pill badge-info">JIT</span></a>
                <a href="/ru/blog/tag/arrays"><span class="badge badge-pill badge-info">Arrays</span></a>
        </span><br /><br />
        <h2 id="section">Часть 1</h2>
<p>Платформа .NET поддерживает два способа задания многомерных массивов: прямоугольные (rectangular) и изломанные (jagged). Второй способ по сути представляет собой массив массивов. Это обстоятельство создаёт у многих программистов иллюзию того, что jagged-массивы должны работать медленнее, т.к. обращение к их элементам реализуется через многократные переходы по ссылкам в управляемой куче. Но на самом деле jagged-массивы могут работают быстрее (если речь идёт непосредственно о работе с массивами, а не о их инициализации), ведь они представляют собой комбинацию одномерных (single) массивов, работа с которыми в CLR весьма оптимизирована (за счёт IL-команд <code>newarr</code>, <code>ldelem</code>, <code>ldelema</code>, <code>ldlen</code>, <code>stelem</code>). Другим подходом к представлению многомерных данных является использование одномерного массива с ручным преобразованием координат (в массиве размерности N<em>M для обращения к элементу [i,j] будем писать [i</em>M+j]). Если производительности не хватает, то можно использовать неуправляемый код, но этот случай мы сейчас рассматривать не будем, остановимся на трёх вышеозначенных способах. Для замеров времени используется
<a href="https://github.com/AndreyAkinshin/BenchmarkDotNet">BenchmarkDotNet</a>. Рассмотрим C# код, который замеряет время работы каждого варианта (полный вариант кода:
<a href="https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs">MultidimensionalArrayProgram.cs</a>, тестировать следует в <strong>Release mode without debugging</strong>). Данные результаты получены в сборке под x64 для процессора Intel Core i7-3632QM CPU 2.20GHz и параметров N=M=100, IterationCount=100000. Исследование вопроса о влиянии используемой архитектуры и параметров запуска на результат бенчмарка можно найти во второй части статьи.
        <a href='/ru/blog/post/arrays-access-performance/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/arrays-access-performance/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/static-array-iteration/'>Об итерировании статичных массивов в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 29 августа 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/blog/tag/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/blog/tag/benchmarking"><span class="badge badge-pill badge-info">Benchmarking</span></a>
                <a href="/ru/blog/tag/static"><span class="badge badge-pill badge-info">Static</span></a>
                <a href="/ru/blog/tag/il"><span class="badge badge-pill badge-info">IL</span></a>
                <a href="/ru/blog/tag/arrays"><span class="badge badge-pill badge-info">Arrays</span></a>
        </span><br /><br />
        <h2 id="section">Часть 1</h2>
<p>Управляемый подход платформы .NET делает жизнь разработчиков достаточно простой, беря на себя многие рутинные операции. Большую часть времени программист может вообще не вспоминать о технической реализации платформы, сосредоточившись исключительно на логике своего приложения. Но иногда попадаются задачи, критичные по производительности. Существует множество различных подходов к оптимизации кода в таких ситуациях вплоть до переписывания наиболее важных частей кода через неуправляемый код. Однако, зачастую для увеличения скорости приложения достаточно понимать, сколько времени тратится на ту или иную операцию. Знание подобных вещей позволит оптимизировать некоторые методы с помощью достаточно простых модификаций исходного кода.</p>
<p>В этой статье мне хотелось бы поговорить о скорости доступа к массивам, ссылки на которые хранятся в статичных переменных. Дело в том, что в скорость итерирования по ним в зависимости от условий запуска может быть ниже, чем для массива, ссылка на который хранится в обычном поле экземпляра класса или локальной переменной. Рассмотрим пример.
        <a href='/ru/blog/post/static-array-iteration/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/static-array-iteration/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/comments/'>Комментировать или не комментировать?</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 28 августа 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/perfectcode"><span class="badge badge-pill badge-info">PerfectCode</span></a>
        </span><br /><br />
        <p><em>По-настоящему хороший комментарий — тот, без которого вам удалось обойтись. © Дядюшка Боб</em></p>
<p class="center">
  <img src="/img/posts/dev/refactoring/front.png" height="250px" />
</p>
<p>В последнее время меня стали очень утомлять оживлённые дебаты о том, нужно ли комментировать код. Как правило, по одну сторону баррикад — самоуверенные джуниоры, имеющие непререкаемую позицию вида <em>«А как же его не комментировать, ведь без комментариев непонятно будет!»</em>. По другую — умудрённые опытом сеньоры. Они понимают, что если возможно обойтись без комментариев, то <em>«Лучше бы, чёрт возьми, так и сделать!»</em>. Наверное, у многих жажда комментировать идёт со студенческой скамьи, когда товарищи преподаватели заставляли комментировать каждую строчку,
<em>«чтобы студент лучше разобрался»</em>. В реальном проекте не должно быть кучи комментариев, которые только и делают, что засоряют код. Впрочем, я не агитирую вообще не писать комментарии, но если вам удалось написать такой код, который не требует пояснений, то расценивайте это как свою маленькую победу. Сразу хотелось бы сослаться на несколько очень умных книжек, на основе которых формировалась моя позиция. Я люблю и уважаю авторов этих работ, полностью разделяя их мнение.</p>
<ul>
<li><a href="http://www.ozon.ru/context/detail/id/5508646/">С. Макконнелл, «Совершенный код. Мастер-класс»</a></li>
<li><a href="http://www.ozon.ru/context/detail/id/20216991/">Р. Мартин, «Чистый код. Создание, анализ и рефакторинг»</a></li>
<li><a href="http://www.ozon.ru/context/detail/id/8466390/">Д. Босуэлл, Т. Фаучер, «Читаемый код, или Программирование как искусство»</a></li>
</ul>
</p>
        <a href='/ru/blog/post/comments/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/comments/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/perfect-code-and-real-projects/'>Совершенный код и реальные проекты</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 28 августа 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/perfectcode"><span class="badge badge-pill badge-info">PerfectCode</span></a>
        </span><br /><br />
        <p>У меня есть проблема — я перфекционист. Я люблю совершенный код. Ведь это не только правильный подход к написанию программ, но и настоящее искусство. От чтения хорошего листинга я получаю не меньше удовольствия, чем от чтения хорошей книги. Проектировать архитектуру большого проекта ничуть не легче, чем проектировать архитектуру большого здания, а в случае хорошей работы — результат не менее прекрасен. Порой меня завораживает то, как изящно переплелись паттерны проектирования в создании совершенной программной системы. Меня восхищает внимание к деталям, когда абсолютно каждый метод настолько прост и понятен, что претендует на место классического примера совершенного кода.</p>
<p class="center">
  <img src="/img/posts/dev/perfect-code-and-real-projects/front.png" height="200px" />
</p>
<p>Но, увы, всё это великолепие разбивается о суровую действительность и реальные проекты. Если мы говорим о продакшн-проекте, то пользователей не волнует, насколько красив ваш код и насколько хороша архитектура, их волнует, чтобы проект хорошо работал. Но я всё равно считаю, что в любом случае нужно стремиться писать правильно, просто при этом фанатизма быть не должно. После чтения различных холиваров на тему правильных подходов к написанию кода мне в глаза бросилась одна тенденция: каждый пытается применить означенные подходы не в целом к программированию, а только к своему опыту разработки, к своим проектам. Многие не осознают, что хорошие практики — это не абсолютные правила, которые должны строго соблюдаться в 100% сценариев, это лишь советы о том, как следовало бы поступать в большинстве ситуаций. На каждую хорошую практику всегда можно придумать несколько дюжин примеров, в которых она работать не будет. Но это вовсе не означает, что хорошая практика не такая уж и хорошая, просто её применили не к месту.</p>
        <a href='/ru/blog/post/perfect-code-and-real-projects/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/perfect-code-and-real-projects/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/undocumented-keywords-in-cs/'>Недокументированные ключевые слова C# или превращаем объект в тыкву</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 26 августа 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/blog/tag/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/blog/tag/il"><span class="badge badge-pill badge-info">IL</span></a>
                <a href="/ru/blog/tag/benchmarking"><span class="badge badge-pill badge-info">Benchmarking</span></a>
        </span><br /><br />
        <p>Стандартный компилятор C# поддерживает 4 недокументированных ключевых слова: <code>__makeref</code>, <code>__reftype</code>, <code>__refvalue</code>, <code>__arglist</code>. Эти слова даже успешно распознаются в Visual Studio (хотя, ReSharper на них ругается). Они не даром исключены из стандарта — их использование может повлечь серьёзные проблемы с безопасностью. Поэтому не нужно их использовать везде подряд, но в отдельных исключительных случаях они могут пригодиться. В этом посте я обсужу предназначение недокументированных команд, рассмотрю вопросы их производительности и научусь превращать объект в тыкву.</p>
        <a href='/ru/blog/post/undocumented-keywords-in-cs/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/undocumented-keywords-in-cs/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/gc-native/'>Неожиданное место для сборки мусора в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 08 августа 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/blog/tag/gc"><span class="badge badge-pill badge-info">GC</span></a>
                <a href="/ru/blog/tag/opencv"><span class="badge badge-pill badge-info">OpenCV</span></a>
        </span><br /><br />
        <p>Платформа .NET обеспечивает нас высокоинтеллектуальным сборщиком мусора, который избавляет от рутины ручного управления памятью. И в 95% случаев можно действительно забыть про память и связанные с ней нюансы. Но вот оставшиеся 5% обладают своей спецификой, связанной с неуправляемыми ресурсами, слишком большими объектами и т.д. И тут лучше бы хорошо разбираться в том, как производится сборка мусора. В противном случае вас могут ждать очень неприятные сюрпризы.</p>
<p>Как вы думаете, может ли GC собрать объект до того, как выполнится последний из его методов? Оказывается, может. Правда, для этого необходимо запустить приложение в Release mode и отдельно от студии (without debugging). В этом случае JIT-компилятор сделает определённые оптимизации, в результате которых такая ситуация возможна. Разумеется, делает он это только тогда, когда в оставшемся теле метода нет ссылок на сам объект или его поля. Казалось бы, достаточно невинная оптимизация. Но она может привести к проблемам, если мы имеем дело с неуправляемыми ресурсами: сборка объекта может произойти <em>до того</em>, как закончится операция над неуправляемым объектом, что вполне вероятно повлечёт падение приложения.</p>
        <a href='/ru/blog/post/gc-native/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/gc-native/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
<div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/blog/post/closures/'>Неочевидности в использовании C#-замыканий</a></h2>
        <span class="blog-post-meta">
          <b>Дата:</b> 07 августа 2013.
          <b>Теги:</b>
                <a href="/ru/blog/tag/lambda"><span class="badge badge-pill badge-info">Lambda</span></a>
                <a href="/ru/blog/tag/closures"><span class="badge badge-pill badge-info">Closures</span></a>
                <a href="/ru/blog/tag/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/blog/tag/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
        </span><br /><br />
        <p>Язык C# даёт нам возможность пользоваться замыканиями — мощным механизмом, который позволяет анонимным методам и лямбдам захватывать свободные переменные в своём лексическом контексте. И в .NET-мире многие программисты очень любят использовать замыкания, но немногие понимают, как они действительно работают. Начнём с простого примера:</p>
<pre><code>public void Run()
{
  int e = 1;
  Foo(x =&gt; x + e);
}
</code></pre>
<p>Ничего сложного тут не происходит: мы просто «захватили» локальную переменную <code>e</code> в лямбду, которая передаётся в некоторый метод <code>Foo</code>. Посмотрим, во что компилятор развернёт такую конструкцию:</p>
<pre><code>public void Run()
{
  DisplayClass c = new DisplayClass();
  c.e = 1;  
  Foo(c.Action);
}
private sealed class DisplayClass
{
  public int e;
  public int Action(int x)
  {
    return x + e;
  }
}
</code></pre>
</p>
        <a href='/ru/blog/post/closures/'>Читать дальше</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/ru/blog/post/closures/#disqus_thread">Комментарии</a><br /><br />
        <hr />
    </div>
</div>
<nav>
  <ul class="pagination">
      <li class="page-item">
        <a class="page-link" href='/ru/blog/page/3/' aria-label="Назад">
          <span aria-hidden="true">&laquo;</span>
          <span class="sr-only">Назад</span>
        </a>
      </li>
                <li class="page-item"><a class="page-link" href="/ru/blog/">1</a></li>
        <li class="page-item"><a class="page-link" href="/ru/blog/page/2/">2</a></li>
        <li class="page-item"><a class="page-link" href="/ru/blog/page/3/">3</a></li>
        <li class="page-item active">
          <a class="page-link" href="/ru/blog/page/4/">4 <span class="sr-only">(current)</span></a>
        </li>
        <li class="page-item"><a class="page-link" href="/ru/blog/page/5/">5</a></li>
        <li class="page-item"><a class="page-link" href="/ru/blog/page/6/">6</a></li>
          <li class="page-item">
        <a class="page-link" href='/ru/blog/page/5/' aria-label="Вперёд">
          <span aria-hidden="true">&raquo;</span>
          <span class="sr-only">Вперёд</span>
        </a>
      </li>
      </ul>
</nav>
<hr />
<p>Подписаться: <a href="/ru/rss.xml">RSS</a> <a href="/ru/atom.xml">Atom</a></p>
    </div>

    <footer class="blog-footer">
      <div class="container">
        <p>&copy; 2014–2017 Андрей Акиньшин</p>
      </div>
    </footer>

    <!-- jQuery first (header), then Tether, then Bootstrap JS. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
    <!-- Other scripts -->
    <script src="/js/highlight.pack.js"></script>
    <script src="/js/anchor.min.js"></script>
    <script src="/js/custom.js"></script>
  </body>
</html>
