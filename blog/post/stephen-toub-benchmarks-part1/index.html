<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta name="description" content="Measuring Performance Improvements in .NET Core with BenchmarkDotNet (Part 1)">
    <meta name="author" content="Andrey Akinshin">
    <link href="/img/favicon.ico" rel="icon" type="image/x-icon"/>
    <meta name="keywords" content='.NET,C#,BenchmarkDotNet,benchmarks,CoreCLR'>

    <title>Measuring Performance Improvements in .NET Core with BenchmarkDotNet (Part 1)</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">

    <!-- Custom styles -->
    <link href="/css/about.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/blog.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/highlight.css" rel="stylesheet" type="text/css" media="all">

    <!-- Feeds -->
    <link href="/en/rss.xml" type="application/rss+xml" rel="alternate" title="Blog RSS Feed" />
    <link href="/en/atom.xml" type="application/atom+xml" rel="alternate" title="Blog ATOM Feed" />

    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-41419012-5', 'auto');
      ga('send', 'pageview');
    </script>
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter28700916 = new Ya.Metrika({id:28700916,
                        clickmap:true,
                        trackLinks:true,
                        accurateTrackBounce:true});
            } catch(e) { }
        });
        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";
        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
    </script>
    <!-- /Yandex.Metrika counter -->
    <!-- Disqus -->
    <script id="dsq-count-scr" src="//aakinshinnet-en.disqus.com/count.js" async></script>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
  </head>

  <body>
     <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link" id="nav-link-blog" href="/blog/">Blog</a>
          <a class="nav-link" id="nav-link-blog-content" href="/blog/content/">Content</a>
          <a class="nav-link" id="nav-link-about" href="/about/">About author</a>
          <a class="nav-link" href='/ru/blog/post/stephen-toub-benchmarks-part1/'>Russian version</a>
        </nav>
      </div>
    </div>

    <div class="container">
      <div class="blog-main">
<div class="blog-post">

<h2 class="blog-post-title" id="post-title">Measuring Performance Improvements in .NET Core with BenchmarkDotNet (Part 1)</h2>
<span class="blog-post-meta">
  <b>Date:</b> June 09, 2017.
  <b>Tags:</b>
        <a href="/blog/tag/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
        <a href="/blog/tag/csharp"><span class="badge badge-pill badge-info">C#</span></a>
        <a href="/blog/tag/benchmarkdotnet"><span class="badge badge-pill badge-info">BenchmarkDotNet</span></a>
        <a href="/blog/tag/benchmarks"><span class="badge badge-pill badge-info">benchmarks</span></a>
        <a href="/blog/tag/coreclr"><span class="badge badge-pill badge-info">CoreCLR</span></a>
</span><br /><br />

<div class="blog-post-toc">
<p>A few days ago <a href="https://github.com/stephentoub">Stephen Toub</a> published a great post
at the <a href="https://blogs.msdn.microsoft.com/dotnet/">Microsoft .NET Blog</a>:
<a href="https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/">Performance Improvements in .NET Core</a>.
He showed some significant performance changes in .NET Core 2.0 Preview 1 (compared with .NET Framework 4.7).
The .NET Core uses RyuJIT for generating assembly code.
When I first tried RyuJIT (e.g.,
<a href="https://blogs.msdn.microsoft.com/dotnet/2014/02/27/ryujit-ctp2-getting-ready-for-prime-time/">CTP2</a>,
<a href="https://blogs.msdn.microsoft.com/clrcodegeneration/2014/10/30/ryujit-ctp5-getting-closer-to-shipping-and-with-better-simd-support/">CTP5</a>, 2014),
I wasn't excited about this: the preview versions had some bugs, and it worked slowly on my applications.
However, the idea of a rethought and open-source JIT-compiler was a huge step forward and investment in the future.
RyuJIT had been developed very actively in recent years: not only by Microsoft but with the help of the community.
I'm still not happy about the generated assembly code in some methods, but I have to admit that the RyuJIT (as a part of .NET Core) works pretty well today:
it shows a good performance level not only on artificial benchmarks but also on real user code.
Also, there are a lot of changes
not only in <a href="https://github.com/dotnet/coreclr">dotnet/coreclr</a> (the .NET Core runtime),
but also in <a href="https://github.com/dotnet/corefx">dotnet/corefx</a> (the .NET Core foundational libraries).
It's very nice to watch how the community helps to optimize well-used classes which have not changed for years.</p>
<p>Now let's talk about benchmarks.
For the demonstration, Stephen wrote a set of handwritten benchmarks.
A few people (in
<a href="https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/#comments">comments</a> and on <a href="https://news.ycombinator.com/item?id=14507936">HackerNews</a>)
asked about <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a> regarding these samples (as a better tool for performance measurements).
So, I decided to try all these benchmarks on BenchmarkDotNet.</p>
<p>In this post, we will discuss
how can BenchmarkDotNet help in such performance investigations,
which benchmarking approaches (and when) are better to use,
and how can we improve these measurements.</p>
<!--more-->
<div id="toc"></div>
<h3 id="how-can-benchmarkdotnet-help">How can BenchmarkDotNet help?</h3>
<blockquote>
<p>If you have spent less than a week studying a benchmark result, it is probably wrong.</p>
<p>— System Performance. Enterprise and the Cloud.</p>
</blockquote>
<p>The first question of the post: are Stephen's benchmarks valid?
Well... Yes and no.</p>
<p>Yes,
we can see code which measures performance,
it prints some performance numbers,
the results are correct,
it helps to make the right conclusions.
Probably, when you see difference like <code>7.7sec</code> vs <code>0.013sec</code>,
you don't need a specialized benchmarking library: it's obvious that the second benchmark is faster.
So, it's ok to use such approach for getting quick raw results.</p>
<p>However, in my world, a benchmark is more than just a program which somehow measures performance and prints some numbers.
I think that a benchmark is a performance investigation or a performance research (of course, you may have a different opinion).
For such investigation, I recommend using a powerful .NET library for benchmarking: <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a>.
Disclaimer: I'm the maintainer of this library, and my opinion may be biased.
I started it several years ago as a pet project, but now it's very popular tool:
BenchmarkDotNet has a lot of happy users,
it has 2000+ stars on GitHub,
and it's supported by the .NET Foundation.
A lot of popular projects use it, also it's used in some of the
coreclr <a href="https://github.com/dotnet/coreclr/issues?utf8=%E2%9C%93&amp;q=BenchmarkDotNet">discussions</a> and
corefx <a href="https://github.com/dotnet/corefx/issues?utf8=%E2%9C%93&amp;q=BenchmarkDotNet">discussions</a>.</p>
<p>If you are already a BenchmarkDotNet user, you can skip this section and go to the benchmarks.
If you didn't use BenchmarkDotNet before, I try to explain why it can be a good choice for performance measurements.
Basically, BenchmarkDotNet solves the following two problems:</p>
<ul>
<li><strong>Getting results you can trust.</strong>
When I look at a microbenchmark with <code>30%</code> performance difference, I always ask myself: can I trust it?
Sometimes, we really have <code>30%</code> difference.
Sometimes, it's just a statistical error due to a huge standard deviation.
How can we be sure?
Probably we have to warmup the benchmark.
Probably we have to do more iterations.
Probably JIT applies some crazy optimizations here and destroys our artificial benchmarks.
There are a lot of problems in the world of microbenchmarks,
you can not be sure that everything is fine without hours of additional checks even for a simple case.</li>
<li><strong>Comfortable research.</strong>
As I said before, benchmarking is a kind of performance research.
You can't make any conclusions only by a single set of measurements: you always have to think about the performance space (source code + input data + environment).
Recently, I wrote a few post with performance exercises (<a href="/blog/post/perfex-min/">Minimum</a> and <a href="/blog/post/perfex-div/">Division</a>)
which demonstrate how hard it can be even in super simple cases.
Usually, benchmarking is not a one-time activity.
A good performance engineer always asks himself: what if we rewrote code in this way, what if we take a bigger sample, what if we run it on another OS, what if...
When you start to work with a benchmark and check different hypotheses, you also start to invent your own benchmarking infrastructure.
Sometimes you have to spend hours or days debugging this infrastructure instead of the actual performance investigation.</li>
</ul>
<p>Let's talk about how can BenchmarkDotNet help you.</p>
<h4 id="precision">Precision</h4>
<p>When someone run a benchmark 10 times, I always ask: why 10? Why not 5? Or 15? Or 100000?
Maybe you didn't execute the benchmark enough times for getting a good precision level.
Or maybe you did too many iterations, and you have to wait a lot longer without tangible precision improvements.
BenchmarkDotNet has set of heuristics for automatic choosing the best amount of benchmark repetition (of course you can specify it manually if you want).
Basically, BenchmarkDotNet tries to get the required confidence level (+some magic for corner cases).
Probably, it not a perfect solution for <em>all benchmarks in the world</em>, but it works pretty well for the vast majority of cases:
you will get decent results and you will not wait too long (from some moment, additional iterations practically do not improve the benchmark accuracy).</p>
<p>Also, with BenchmarkDotNet you can <em>usually</em> skip <em>almost</em> all of the benchmarking routine.
How many times should I repeat this method which takes a few nanoseconds?
Should I care about the benchmarking infrastructure overhead?
Can Roslyn/RyuJIT/CPU apply some tricky optimization and spoil the results?
Is it possible that one benchmark method will be inlined and other will be not inlined?
Should we care about hardware timers?
I also have a few post about internals of <a href="/blog/post/stopwatch/">Stopwatch</a> and <a href="/blog/post/datetime/">DateTime</a> which show
some important problems with timers.</p>
<p>You can't imagine how many problems are there.
Some of them are related to &quot;features&quot; of modern CPUs.
Some of the Intel CPU optimizations are even not covered in official documentation (but they still can spoil your results).
I spent a huge amount of time on reverse engineering trying to create workarounds for these &quot;features&quot; (one day I'll write a post about it).
BenchmarkDotNet has a set of tricks, hacks, and workarounds which protect you from dozens of potential troubles.
Of course, you can be lucky and avoid all these problems without the corresponded knowledge.
But again: how can you be sure?</p>
<h4 id="environments">Environments</h4>
<p>In the original post, Stephen compare <code>.NET Core 2.0 Preview 1</code> and <code>.NET Framework 4.7</code> (with <code>RyuJIT-x64</code>).
I believe that he ran each benchmark twice: on each runtime.
BenchmarkDotNet has special objects — <a href="http://benchmarkdotnet.org/Configs/Jobs.htm">Jobs</a> which help you to compare several environments at once.
Basically, you can define a config for your benchmark:</p>
<pre><code class="language-cs">public class MyConfig : ManualConfig
{
  public MyConfig()
  {
    Add(Job.Default.With(Runtime.Clr).With(Jit.RyuJit).With(Platform.X64));
    Add(Job.Default.With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp20));
  }
}
</code></pre>
<p><code>RyuJIT-x64</code> is not the only JIT in the full .NET Framework.
Some people still use <code>LegacyJIT-x64</code> (because not all of the enterprise companies are ready for switching to a new JIT-compiler without a detailed performance research).
If you develop <code>x86</code> application, you use <code>LegacyJIT-x86</code>.
In BenchmarkDotNet, you can just add a few additional jobs:</p>
<pre><code class="language-cs">Add(Job.Default.With(Runtime.Clr).With(Jit.LegacyJit).With(Platform.X64));
Add(Job.Default.With(Runtime.Clr).With(Jit.LegacyJit).With(Platform.X86));
</code></pre>
<p>Also it would be nice to check the <a href="http://www.mono-project.com/">mono</a> performance:</p>
<pre><code class="language-cs">Add(Job.Default.With(Runtime.Mono));
</code></pre>
<p>Wait!
I have two different mono on my Windows machine: <code>x86</code> and <code>x64</code>.
I want to check both versions!
How can I do it?
Easy peasy:</p>
<pre><code class="language-cs">Add(Job.Default.With(new MonoRuntime(&quot;Mono_x64&quot;, @&quot;C:\Program Files\Mono\bin\mono.exe&quot;)));
Add(Job.Default.With(new MonoRuntime(&quot;Mono_x86&quot;, @&quot;C:\Program Files (x86)\Mono\bin\mono.exe&quot;)));
</code></pre>
<p>Also I want to compare <code>.NET Core 2.0 Preview 1</code> with <code>.NET Core 1.1</code>:</p>
<pre><code class="language-cs">Add(Job.Default.With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp11));
Add(Job.Default.With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp20));
</code></pre>
<p>There are a huge amount of different environments.
You can't make any conclusion about C# performance based only on a single runtime
(remember that C# is just a language, it's an abstraction; it hasn't such property as &quot;performance&quot;; &quot;performance&quot; is a property of a runtime.)
If you want to get the results which you can apply, you have to check different configurations.
BenchmarkDotNet also helps you to check a lot of additional things like
GC settings (Server/Workstation, On/Off concurrent GC, and so on) and
benchmark mode parameters (e.g. you can automatically throw away all the outliers or include them in the final results).</p>
<p>The main important fact here: you can define a config once and use it everywhere.
You can get the summary table with all results by a single click:
you shouldn't manually run the program in all environment after each change.</p>
<h4 id="automation-and-analysis">Automation and analysis</h4>
<p>BenchmarkDotNet has a lot of additional tools for performance engineers.</p>
<p>For example, if you want to enumerate a parameter (e.g. size of an array), you can use <code>Params</code>:</p>
<pre><code class="language-cs">int[] a;

[Params(1, 100, 100_000, 10_000_000)]
public int N;

[GlobalSetup]
public void Setup()
{
  a = new int[N];
}
</code></pre>
<p>Of course, you can do it manually.
But you can
spent a lot of time on this,
make a mistake,
try to debug a mistake,
collect all the result in a table,
prettify the console output,
spent more time,
and so on.
All the basic stuff for such kind of tasks is already implemented.</p>
<p>Also BenchmarkDotNet
automatically warn you if something goes wrong with results,
it calculates statistics for you,
draw beautiful distribution plots,
export the results to markdown/xml/json/your_favorite_format,
check memory usage and an amount of allocations,
and so on.</p>
<h4 id="what-are-we-going-to-do">What are we going to do?</h4>
<p>Once again: if you don't use BenchmarkDotNet, it <em>doesn't mean</em> that your results are incorrect.
Also, if you use BenchmarkDotNet, it <em>doesn't mean</em> that you have correct results.
It's not a magic wand which will automatically fix all your benchmarks.
It's just a handy tool which helps you: it allows focusing on a problem instead of benchmarking stuff.</p>
<p>So, today I'm going to reimplement benchmarks of Stephen Toub with the help of BenchmarkDotNet and share my results.
I hope you know that you shouldn't trust a guy from the internet who present any performance measurements.
There is a quote which I really like:</p>
<blockquote>
<p>There are lies, damn lies and then there are performance measures.</p>
<p>— Anon et al., “A Measure of Transaction Processing Power”</p>
</blockquote>
<p>So, I prepared a GitHub repo (<a href="https://github.com/AndreyAkinshin/StephenToubBenchmarks">AndreyAkinshin/StephenToubBenchmarks</a>)
for you which contains almost all the samples.
You can download it and try it on your own machine.
You can modify the source code in any way and check the new results
(it's a good exercise if you want to improve your performance skills).
Write you own benchmarks.
Check out the performance of your production code on different runtimes.
Share and discuss results:
it will help you and others to better understand what's going on under the hood of the .NET runtime.
Also, this is a common situation these days
when some guy read such discussion and will go to improve coreclr or corefx on GitHub.
Remember that performance is a very tricky subject
and you will not get good knowledge based on a few blog posts without own experiments.</p>
<h4 id="preparation">Preparation</h4>
<p>Let's check how it works ont only on the <code>.NET Core 2.0 Preview 1</code> and <code>.NET Framework 4.7</code>, but also on <code>Mono 5.0.1</code>.
Also, we would like to look at the distribution, so we add <code>RPlotExporter</code>:</p>
<pre><code class="language-cs">public class MainConfig : ManualConfig
{
  public MainConfig()
  {
    Add(Job.Default.With(Runtime.Clr).With(Jit.RyuJit).With(Platform.X64).WithId(&quot;NET4.7_RyuJIT-x64&quot;));
    Add(Job.Default.With(Runtime.Mono).WithId(&quot;Mono5.0.1-x64&quot;));
    Add(Job.Default.With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp20).WithId(&quot;Core2.0-x64&quot;));
    Add(RPlotExporter.Default);
  }
}
</code></pre>
<p>BenchmarkDotNet will print such lines before each summary:</p>
<pre><code class="language-ini">BenchmarkDotNet=v0.10.8, OS=Windows 10 Redstone 1 (10.0.14393)
Processor=Intel Core i7-6700HQ CPU 2.60GHz (Skylake), ProcessorCount=8
Frequency=2531250 Hz, Resolution=395.0617 ns, Timer=TSC
dotnet cli version=2.0.0-preview1-005977
  [Host]            : .NET Core 4.6.25302.01, 64bit RyuJIT
  Core2.0-x64       : .NET Core 4.6.25302.01, 64bit RyuJIT
  Mono5.0.1-x64     : Mono 5.0.1 (Visual Studio), 64bit
  NET4.7_RyuJIT-x64 : Clr 4.0.30319.42000, 64bit RyuJIT-v4.7.2053.0
</code></pre>
<p>Here is the summary table legend:</p>
<pre><code>  Mean   : Arithmetic mean of all measurements
  Error  : Half of 99.9% confidence interval
  StdDev : Standard deviation of all measurements

  Gen 0     : GC Generation 0 collects per 1k Operations
  Gen 1     : GC Generation 1 collects per 1k Operations
  Gen 2     : GC Generation 2 collects per 1k Operations
  Allocated : Allocated memory per single operation (managed only, inclusive, 1KB = 1024B)

  1 ns   : 1 Nanosecond  (0.000000001 sec)
  1 us   : 1 Microsecond (0.000001 sec)
</code></pre>
<p>Ok, now we are ready.</p>
<h3 id="collections">Collections</h3>
<p>In this post (probably the first one from a series), we will talk only about collections.
We will look at all the benchmark from the original post,
reimplement it with the help of BenchmarkDotNet,
think about possible improvements,
and analyze the results.</p>
<h4 id="queue">Queue</h4>
<p>There is the source code of the first benchmark:</p>
<pre><code class="language-cs">while (true)
{
  var q = new Queue&lt;int&gt;();
  var sw = Stopwatch.StartNew();
  for (int i = 0; i &lt; 100_000_000; i++)
  {
    q.Enqueue(i);
    q.Dequeue();
  }
  Console.WriteLine(sw.Elapsed);
}
</code></pre>
<p>In BenchmarkDotNet, you shouldn't do a lot of repetitions of a quick piece of code:
the library will do it for you
(by the way, why we do exactly <code>100_000_000</code> repetitions here?).
Here is our benchmark:</p>
<pre><code>[Config(typeof(MainConfig))]
[BenchmarkCategory(&quot;Collections&quot;)]
public class QueueBenchmark1
{
  private Queue&lt;int&gt; q = new Queue&lt;int&gt;();

  [Benchmark]
  public void Run()
  {
    q.Enqueue(0);
    q.Dequeue();
  }
}
</code></pre>
<p>There is my results (BenchmarkDotNet generated a pretty markdown table for me which I copy-pasted to my blog):</p>
<table>
<thead>
<tr>
<th>Job</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core2.0-x64</td>
<td style="text-align: right;">6.228 ns</td>
<td style="text-align: right;">0.0120 ns</td>
<td style="text-align: right;">0.0079 ns</td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td style="text-align: right;">10.514 ns</td>
<td style="text-align: right;">0.0288 ns</td>
<td style="text-align: right;">0.0240 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td style="text-align: right;">11.150 ns</td>
<td style="text-align: right;">0.0592 ns</td>
<td style="text-align: right;">0.0525 ns</td>
</tr>
</tbody>
</table>
<p>Usually, it's also a good idea to look at the distribution.
BenchmarkDotNet provides plots like this:</p>
<div class="mx-auto"><img class="mx-auto d-block" width="600" src="/img/posts/stephen-toub-benchmarks-part1/QueueBenchmark1-Run-density.png" /></div>
<p>Now everything is fine, but don't forget to check out the distribution
when you are investigation a new performance space.</p>
<p>The original results:</p>
<pre><code>// .NET Framework 4.7
00:00:00.9392595
00:00:00.9390453
00:00:00.9455784
00:00:00.9508294
00:00:01.0107745
// .NET Core 2.0 Preview 1
00:00:00.5514887
00:00:00.5662477
00:00:00.5627481
00:00:00.5685286
00:00:00.5262378
</code></pre>
<p>It's nice to see <code>~1.8x</code> speedup on the .NET Core (both original and BenchmarkDotNet results).
But here we are talking about too artificial benchmarks: we measure a single <code>Enqueue</code>/<code>Dequeue</code> pair with a zero-size queue.
The <code>Enqueue</code> doesn't have a fixed performance because it can trigger resizing of the internal array.
Let's write another benchmark with <code>N</code> elements:</p>
<pre><code class="language-cs">[Config(typeof(MainConfig))]
[BenchmarkCategory(&quot;Collections&quot;)]
public class QueueBenchmark2
{
  private Queue&lt;int&gt; q = new Queue&lt;int&gt;();

  [Params(10, 100, 1_000, 10_000)]
  public int N;

  [Benchmark]
  public void Run()
  {
    for (int i = 0; i &lt; N; i++)
      q.Enqueue(i);
    for (int i = 0; i &lt; N; i++)
      q.Dequeue();
  }
}
</code></pre>
<p>Results:</p>
<table>
<thead>
<tr>
<th>Job</th>
<th>N</th>
<th>Mean</th>
<th>Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>10</strong></td>
<td><strong>72.68 ns</strong></td>
<td><strong>0.1578 ns</strong></td>
<td style="text-align: right;"><strong>0.1318 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>10</td>
<td>180.29 ns</td>
<td>0.5868 ns</td>
<td style="text-align: right;">0.5489 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>10</td>
<td>152.73 ns</td>
<td>0.4126 ns</td>
<td style="text-align: right;">0.3658 ns</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>100</strong></td>
<td><strong>738.99 ns</strong></td>
<td><strong>1.5047 ns</strong></td>
<td style="text-align: right;"><strong>1.4075 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>100</td>
<td>2,200.55 ns</td>
<td>43.0554 ns</td>
<td style="text-align: right;">67.0321 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>100</td>
<td>2,023.59 ns</td>
<td>5.1311 ns</td>
<td style="text-align: right;">4.5486 ns</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>1000</strong></td>
<td><strong>6,978.27 ns</strong></td>
<td><strong>21.7015 ns</strong></td>
<td style="text-align: right;"><strong>19.2378 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>1000</td>
<td>22,917.90 ns</td>
<td>65.6376 ns</td>
<td style="text-align: right;">51.2455 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>1000</td>
<td>20,632.16 ns</td>
<td>49.7627 ns</td>
<td style="text-align: right;">41.5541 ns</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>10000</strong></td>
<td><strong>70,749.93 ns</strong></td>
<td><strong>97.2220 ns</strong></td>
<td style="text-align: right;"><strong>75.9045 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>10000</td>
<td>228,853.60 ns</td>
<td>728.0385 ns</td>
<td style="text-align: right;">681.0076 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>10000</td>
<td>206,463.21 ns</td>
<td>351.8959 ns</td>
<td style="text-align: right;">293.8490 ns</td>
</tr>
</tbody>
</table>
<p>Let's look at the bar chart for this benchmark:</p>
<div class="mx-auto"><img class="mx-auto d-block" width="600" src="/img/posts/stephen-toub-benchmarks-part1/QueueBenchmark2-barplot.png" /></div>
<p>With <code>N=10_000</code>, we have <code>~2.95x</code> speedup which is pretty great.
You should understand that it's still is not a perfect benchmark for <code>Queue</code>.
If we want to have a complete performance investigation,
we should check corner cases (e.g., moments before and after the array resizing),
we should check cases with different initial capacity,
we should check how it works in a real situation (e.g., solve a classic computer science problem with a queue),
we should check many-many cases.
We skip this &quot;complete investigation&quot; (but you can do it yourself) because it's not our aim for today and we have a lot of other interesting examples.
I will be happy if someone else continues this research, writes a set of benchmarks and presents the results.
It will be a good exercise for you and a good example of a nice performance investigation for the community.
Feel free to pick up any other example from this post or create you own.</p>
<h4 id="sortedset">SortedSet</h4>
<p>The next benchmark is about <code>SortedSet</code>.
We skip the constructor demo (comparing <code>~7.7sec</code> and <code>~0.013s</code> is not interesting)
and continue with the <code>Min</code> performance.</p>
<p>Here is the original code:</p>
<pre><code class="language-cs">while (true)
{
  var s = new SortedSet&lt;int&gt;();
  for (int n = 0; n &lt; 100_000; n++)
  {
    s.Add(n);
  }

  var sw = Stopwatch.StartNew();
  for (int i = 0; i &lt; 10_000_000; i++)
  {
    s_result = s.Min;
  }
  Console.WriteLine(sw.Elapsed);
}
</code></pre>
<p>Original results:</p>
<pre><code>// .NET Framework 4.7
00:00:01.1427246
00:00:01.1295220
00:00:01.1350696
00:00:01.1502784
00:00:01.1677880
// .NET Core 2.0 Preview 1
00:00:00.0861391
00:00:00.0861183
00:00:00.0866616
00:00:00.0848434
00:00:00.0860198
</code></pre>
<p>Why we put exactly <code>100_000</code> in the <code>SortedSet</code>?
Let's try different values!</p>
<pre><code class="language-cs">[Config(typeof(MainConfig))]
[BenchmarkCategory(&quot;Collections&quot;)]
public class SortedSetBenchmark1
{
  private SortedSet&lt;int&gt; s = new SortedSet&lt;int&gt;();

  [Params(1, 100, 100_000, 10_000_000)]
  public int N;

  [GlobalSetup]
  public void Setup()
  {
    for (int i = 0; i &lt; N; i++)
      s.Add(i);
  }

  [Benchmark]
  public int Run() =&gt; s.Min;
}
</code></pre>
<table>
<thead>
<tr>
<th>Job</th>
<th>N</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>1</strong></td>
<td style="text-align: right;"><strong>2.010 ns</strong></td>
<td style="text-align: right;"><strong>0.0061 ns</strong></td>
<td style="text-align: right;"><strong>0.0057 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>1</td>
<td style="text-align: right;">81.355 ns</td>
<td style="text-align: right;">1.6598 ns</td>
<td style="text-align: right;">2.6802 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>1</td>
<td style="text-align: right;">38.103 ns</td>
<td style="text-align: right;">0.7885 ns</td>
<td style="text-align: right;">1.4015 ns</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>100</strong></td>
<td style="text-align: right;"><strong>4.040 ns</strong></td>
<td style="text-align: right;"><strong>0.0166 ns</strong></td>
<td style="text-align: right;"><strong>0.0139 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>100</td>
<td style="text-align: right;">147.587 ns</td>
<td style="text-align: right;">2.9271 ns</td>
<td style="text-align: right;">4.8093 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>100</td>
<td style="text-align: right;">72.091 ns</td>
<td style="text-align: right;">0.2088 ns</td>
<td style="text-align: right;">0.2404 ns</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>100000</strong></td>
<td style="text-align: right;"><strong>12.193 ns</strong></td>
<td style="text-align: right;"><strong>0.0471 ns</strong></td>
<td style="text-align: right;"><strong>0.0440 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>100000</td>
<td style="text-align: right;">257.729 ns</td>
<td style="text-align: right;">0.6381 ns</td>
<td style="text-align: right;">0.5657 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>100000</td>
<td style="text-align: right;">145.400 ns</td>
<td style="text-align: right;">0.5647 ns</td>
<td style="text-align: right;">0.5282 ns</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>10000000</strong></td>
<td style="text-align: right;"><strong>55.452 ns</strong></td>
<td style="text-align: right;"><strong>0.1196 ns</strong></td>
<td style="text-align: right;"><strong>0.1119 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>10000000</td>
<td style="text-align: right;">476.941 ns</td>
<td style="text-align: right;">1.2562 ns</td>
<td style="text-align: right;">1.1136 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>10000000</td>
<td style="text-align: right;">202.415 ns</td>
<td style="text-align: right;">0.5968 ns</td>
<td style="text-align: right;">0.5290 ns</td>
</tr>
</tbody>
</table>
<p>Here are some interesting facts:</p>
<ul>
<li>In the original post, for <code>N=100_000</code> we have <code>~14.5x</code> speedup on <code>.NET Core</code>.</li>
<li>In our experiment, we have <code>~12x</code> speedup. <code>.NET Core</code> is still super-fast, but we have a difference between speedup results.</li>
<li>For <code>N=10_000_000</code> we have <code>~3.7x</code> speedup.
Be careful with the parameters of your benchmark: they can significantly affect your results.</li>
<li><code>Mono</code> works <code>~2.35</code> times slower than <code>.NET Framework 4.7</code> + <code>RyuJIT-x64</code> for <code>N=10_000_000</code>.</li>
</ul>
<h4 id="list">List</h4>
<p>Now it's time for the <code>List</code>.
The original benchmark:</p>
<pre><code class="language-cs">while (true)
{
  var l = new List&lt;int&gt;();
  var sw = Stopwatch.StartNew();
  for (int i = 0; i &lt; 100_000_000; i++)
  {
    l.Add(i);
    l.RemoveAt(0);
  }
  Console.WriteLine(sw.Elapsed);
}
</code></pre>
<p>The original results:</p>
<pre><code>// .NET Framework 4.7
00:00:00.4434135
00:00:00.4394329
00:00:00.4496867
00:00:00.4496383
00:00:00.4515505
// .NET Core 2.0 Preview 1
00:00:00.3213094
00:00:00.3211772
00:00:00.3179631
00:00:00.3198449
00:00:00.3164009
</code></pre>
<p>Let's write a simple benchmark for <code>Add</code>/<code>RemoveAt</code>:</p>
<pre><code class="language-cs">[Config(typeof(MainConfig))]
[BenchmarkCategory(&quot;Collections&quot;)]
public class ListBenchmark1
{
  private List&lt;int&gt; l = new List&lt;int&gt;();

  [Benchmark]
  public void Run()
  {
    l.Add(0);
    l.RemoveAt(0);
  }
}
</code></pre>
<table>
<thead>
<tr>
<th>Job</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Median</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core2.0-x64</td>
<td style="text-align: right;">3.375 ns</td>
<td style="text-align: right;">0.0053 ns</td>
<td style="text-align: right;">0.0057 ns</td>
<td style="text-align: right;">3.374 ns</td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td style="text-align: right;">7.942 ns</td>
<td style="text-align: right;">0.1972 ns</td>
<td style="text-align: right;">0.3556 ns</td>
<td style="text-align: right;">8.229 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td style="text-align: right;">5.914 ns</td>
<td style="text-align: right;">0.0126 ns</td>
<td style="text-align: right;">0.0098 ns</td>
<td style="text-align: right;">5.913 ns</td>
</tr>
</tbody>
</table>
<p>We can see here <code>~1.8x</code> speedup on .NET Core, in the original post it was <code>~1.4x</code>.
Another interesting fact: did you noticed that BenchmarkDotNet added the <code>Median</code> column in this table (it was skipped in previous benchmarks)?
By default, BenchmarkDotNet tries not to bore you with statistics (however, you can request any statistics manually).
If BenchmarkDotNet discovers something strange in the results, it adds additional columns with interesting values.
By default, the <code>Median</code> column is skipped because <em>usually</em> the <code>Median</code> and <code>Mean</code> values are too close.
Here we have a difference for Mono:</p>
<table>
<thead>
<tr>
<th>Job</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Median</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mono5.0.1-x64</td>
<td style="text-align: right;">7.942 ns</td>
<td style="text-align: right;">8.229 ns</td>
</tr>
</tbody>
</table>
<p>Let's look at the timeline plot for mono:</p>
<div class="mx-auto"><img class="mx-auto d-block" width="600" src="/img/posts/stephen-toub-benchmarks-part1/ListBenchmark1-Run-Mono5.0.1-x64-timelineSmooth.png" /></div>
<p>The usual amount of iterations for a benchmark is 15.
In most cases, it allows getting <em>acceptable</em> results.
I tried to increase it before, but people don't want to wait too long for results;
they start to manually set a small amount of iterations,
and our default &quot;automatic choosing the amount of iterations&quot; logic becomes useless.
So, the default value is 15 (at least), but BenchmarkDotNet can increase it if something is going wrong.
On Mono, we can see that the amount of iterations is around 40. (Hooray, it works!)
Also, we can observe two modes: around <code>~7.6ns</code> and <code>~8.2ns</code>.
So, let's check the distribution!</p>
<div class="mx-auto"><img class="mx-auto d-block" width="600" src="/img/posts/stephen-toub-benchmarks-part1/ListBenchmark1-Run-Mono5.0.1-x64-density.png" /></div>
<p>Yep, it's a bimodal distribution.
If BenchmarkDotNet is so smart, why it didn't warn us about such distribution?
Well, it's an open issue: <a href="https://github.com/dotnet/BenchmarkDotNet/issues/429">BenchmarkDotNet#429: Detect multimodal distributions</a>.
I tried to implement this,
but performance distribution are too tricky,
it's not easy to write such logic without huge percent of false-positive results.
I will try it again in the future, but if somebody knows a good solution, pull requests are welcome!</p>
<p>Why does the distribution look like this?
I don't know.
And it's not a topic of this post:
the full performance investigation takes too much time:
we have to play with initial configurations,
check out the source code,
try different versions of mono,
different machines,
and so on.
In this post, I want to talk only about benchmarking.
The important point here is that such phenomena can be easily skipped during handwritten measurements.</p>
<p>Now le'ts check how it works on huge lists:</p>
<pre><code class="language-cs">[Config(typeof(MainConfig))]
[BenchmarkCategory(&quot;Collections&quot;)]
public class ListBenchmark2
{
  private List&lt;int&gt; l = new List&lt;int&gt;();

  [Params(10, 100, 1000)]
  public int N;

  [Benchmark]
  public void Run()
  {
    for (int i = 0; i &lt; N; i++)
      l.Add(i);
    for (int i = 0; i &lt; N; i++)
      l.RemoveAt(N - 1 - i);
  }
}
</code></pre>
<table>
<thead>
<tr>
<th>Job</th>
<th>N</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Median</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>10</strong></td>
<td style="text-align: right;"><strong>42.87 ns</strong></td>
<td style="text-align: right;"><strong>0.1396 ns</strong></td>
<td style="text-align: right;"><strong>0.1166 ns</strong></td>
<td style="text-align: right;"><strong>42.83 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>10</td>
<td style="text-align: right;">115.27 ns</td>
<td style="text-align: right;">0.7361 ns</td>
<td style="text-align: right;">0.9040 ns</td>
<td style="text-align: right;">115.55 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>10</td>
<td style="text-align: right;">59.53 ns</td>
<td style="text-align: right;">0.3000 ns</td>
<td style="text-align: right;">0.2506 ns</td>
<td style="text-align: right;">59.45 ns</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>100</strong></td>
<td style="text-align: right;"><strong>430.05 ns</strong></td>
<td style="text-align: right;"><strong>0.7114 ns</strong></td>
<td style="text-align: right;"><strong>0.6307 ns</strong></td>
<td style="text-align: right;"><strong>429.95 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>100</td>
<td style="text-align: right;">871.77 ns</td>
<td style="text-align: right;">17.3243 ns</td>
<td style="text-align: right;">32.9613 ns</td>
<td style="text-align: right;">897.37 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>100</td>
<td style="text-align: right;">664.19 ns</td>
<td style="text-align: right;">1.3559 ns</td>
<td style="text-align: right;">0.9804 ns</td>
<td style="text-align: right;">663.97 ns</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>1000</strong></td>
<td style="text-align: right;"><strong>4,059.05 ns</strong></td>
<td style="text-align: right;"><strong>13.0940 ns</strong></td>
<td style="text-align: right;"><strong>10.2230 ns</strong></td>
<td style="text-align: right;"><strong>4,060.99 ns</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>1000</td>
<td style="text-align: right;">7,623.19 ns</td>
<td style="text-align: right;">95.4478 ns</td>
<td style="text-align: right;">79.7032 ns</td>
<td style="text-align: right;">7,610.51 ns</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>1000</td>
<td style="text-align: right;">6,271.42 ns</td>
<td style="text-align: right;">123.4688 ns</td>
<td style="text-align: right;">209.6594 ns</td>
<td style="text-align: right;">6,398.59 ns</td>
</tr>
</tbody>
</table>
<p>For <code>N=1000</code>, we have <code>~1.55x</code> speedup.
And we still have a bimodal distribution for mono.
Here is the timeline plot for <code>N=100</code>:</p>
<div class="mx-auto"><img class="mx-auto d-block" width="600" src="/img/posts/stephen-toub-benchmarks-part1/ListBenchmark2-Run-Mono5.0.1-x64 N=100-timelineSmooth.png" /></div>
<h4 id="concurrentqueue">ConcurrentQueue</h4>
<p>Now let's play with <code>ConcurrentQueue</code>.</p>
<p>The original code:</p>
<pre><code class="language-cs">while (true)
{
  var q = new ConcurrentQueue&lt;int&gt;();
  int gen0 = GC.CollectionCount(0), gen1 = GC.CollectionCount(1), gen2 = GC.CollectionCount(2);
  for (int i = 0; i &lt; 100_000_000; i++)
  {
    q.Enqueue(i);
    q.TryDequeue(out int _);
  }
  Console.WriteLine($&quot;Gen0={GC.CollectionCount(0) - gen0} Gen1={GC.CollectionCount(1) - gen1} Gen2={GC.CollectionCount(2) - gen2}&quot;);
}
</code></pre>
<p>The original results:</p>
<pre><code>// .NET Framework 4.7
00:00:02.6485174  Gen0=162 Gen1=80 Gen2=0
00:00:02.6144919  Gen0=162 Gen1=81 Gen2=0
00:00:02.6699958  Gen0=162 Gen1=81 Gen2=0
00:00:02.6441047  Gen0=162 Gen1=81 Gen2=0
00:00:02.6255135  Gen0=162 Gen1=81 Gen2=0
// .NET Core 2.0 Preview 1
00:00:01.7700190  Gen0=0 Gen1=0 Gen2=0
00:00:01.8324078  Gen0=0 Gen1=0 Gen2=0
00:00:01.7552966  Gen0=0 Gen1=0 Gen2=0
00:00:01.7518632  Gen0=0 Gen1=0 Gen2=0
00:00:01.7560811  Gen0=0 Gen1=0 Gen2=0
</code></pre>
<p>Here we manually check GC collections.
In general case, it can be heard because such measurements have own problems.
In BenchmarkDotNet, you mark the benchmark class with the <code>[MemoryDiagnoser]</code> attribute,
and GC statistics will be automatically calculated.
And it's not only about high-precision GC collection values, it also prints average allocated size in bytes!
Check out a post of <a href="https://github.com/adamsitnik">Adam Sitnik</a>
about <code>MemoryDiagnoser</code>: <a href="http://adamsitnik.com/the-new-Memory-Diagnoser/">&quot;The new MemoryDiagnoser is now better than ever!&quot;</a>.</p>
<p>Let's write a new benchmark:</p>
<pre><code class="language-cs">[Config(typeof(MainConfig))]
[BenchmarkCategory(&quot;Collections&quot;)]
[MemoryDiagnoser]
public class ConcurrentQueueBenchmark1
{
  private ConcurrentQueue&lt;int&gt; q = new ConcurrentQueue&lt;int&gt;();

  [Benchmark]
  public void Run()
  {
    q.Enqueue(0);
    q.TryDequeue(out int _);
  }
}
</code></pre>
<table>
<thead>
<tr>
<th>Job</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Gen 0</th>
<th style="text-align: right;">Gen 1</th>
<th style="text-align: right;">Gen 2</th>
<th style="text-align: right;">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core2.0-x64</td>
<td style="text-align: right;">18.92 ns</td>
<td style="text-align: right;">0.0272 ns</td>
<td style="text-align: right;">0.0227 ns</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">0 B</td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td style="text-align: right;">45.41 ns</td>
<td style="text-align: right;">0.1918 ns</td>
<td style="text-align: right;">0.1498 ns</td>
<td style="text-align: right;">0.0018</td>
<td style="text-align: right;">0.0001</td>
<td style="text-align: right;">0.0000</td>
<td style="text-align: right;">N/A</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td style="text-align: right;">31.24 ns</td>
<td style="text-align: right;">0.0826 ns</td>
<td style="text-align: right;">0.0773 ns</td>
<td style="text-align: right;">0.0017</td>
<td style="text-align: right;">0.0008</td>
<td style="text-align: right;">0.0000</td>
<td style="text-align: right;">9 B</td>
</tr>
</tbody>
</table>
<p>Now we know average GC collection counts for all generations (<code>Gen 0</code>/<code>Gen 1</code>/<code>Gen 2</code> are values per 1000 operations)
and the amount of allocated memory.
The original speedup is <code>~1.45x</code>, our value is <code>~1.65x</code></p>
<pre><code class="language-cs">[Config(typeof(MainConfig))]
[BenchmarkCategory(&quot;Collections&quot;)]
public class ConcurrentQueueBenchmark2
{
  private ConcurrentQueue&lt;int&gt; q = new ConcurrentQueue&lt;int&gt;();

  [Params(100, 100_000, 1_000_000)]
  public int N;

  [Benchmark]
  public void Run()
  {
    for (int i = 0; i &lt; N; i++)
      q.Enqueue(0);
    for (int i = 0; i &lt; N; i++)
      q.TryDequeue(out int _);
  }
}
</code></pre>
<table>
<thead>
<tr>
<th>Job</th>
<th>N</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>100</strong></td>
<td style="text-align: right;"><strong>2.490 us</strong></td>
<td style="text-align: right;"><strong>0.0022 us</strong></td>
<td style="text-align: right;"><strong>0.0019 us</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>100</td>
<td style="text-align: right;">4.283 us</td>
<td style="text-align: right;">0.0784 us</td>
<td style="text-align: right;">0.0695 us</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>100</td>
<td style="text-align: right;">3.174 us</td>
<td style="text-align: right;">0.0206 us</td>
<td style="text-align: right;">0.0183 us</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>100000</strong></td>
<td style="text-align: right;"><strong>2,720.496 us</strong></td>
<td style="text-align: right;"><strong>4.2448 us</strong></td>
<td style="text-align: right;"><strong>3.3141 us</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>100000</td>
<td style="text-align: right;">4,130.617 us</td>
<td style="text-align: right;">13.7123 us</td>
<td style="text-align: right;">12.1556 us</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>100000</td>
<td style="text-align: right;">3,211.175 us</td>
<td style="text-align: right;">5.8462 us</td>
<td style="text-align: right;">5.4685 us</td>
</tr>
<tr>
<td><strong>Core2.0-x64</strong></td>
<td><strong>1000000</strong></td>
<td style="text-align: right;"><strong>27,249.183 us</strong></td>
<td style="text-align: right;"><strong>74.8775 us</strong></td>
<td style="text-align: right;"><strong>66.3769 us</strong></td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>1000000</td>
<td style="text-align: right;">41,757.702 us</td>
<td style="text-align: right;">123.4342 us</td>
<td style="text-align: right;">126.7578 us</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>1000000</td>
<td style="text-align: right;">34,823.063 us</td>
<td style="text-align: right;">694.9357 us</td>
<td style="text-align: right;">1,161.0814 us</td>
</tr>
</tbody>
</table>
<p>Thus, speedup for <code>N=1_000_000</code> is <code>~1.26x</code>.
Let's look at the timelines:</p>
<div class="mx-auto"><img class="mx-auto d-block" width="600" src="/img/posts/stephen-toub-benchmarks-part1/ConcurrentQueueBenchmark2-Run-facetTimeline.png" /></div>
<p>Plots are cool: we immediately see a suspicious place: <code>.NET Framework 4.7</code> + <code>N=1_000_000</code>.
Looks like another bimodal distribution: a good candidate for detailed research, if we continue this investigation.</p>
<p>Now let's look at a more interesting example with multithreading.
The original code:</p>
<pre><code>while (true)
{
  const int Items = 100_000_000;
  var q = new ConcurrentQueue&lt;int&gt;();
  var sw = Stopwatch.StartNew();

  Task consumer = Task.Run(() =&gt;
  {
    int total = 0;
     while (total &lt; Items) if (q.TryDequeue(out int _)) total++;
  });
  for (int i = 0; i &lt; Items; i++) q.Enqueue(i);
  consumer.Wait();

  Console.WriteLine(sw.Elapsed);
}
</code></pre>
<p>The original results:</p>
<pre><code>// .NET Framework 4.7
00:00:06.1366044
00:00:05.7169339
00:00:06.3870274
00:00:05.5487718
00:00:06.6069291
// .NET Core 2.0 Preview 1
00:00:01.2052460
00:00:01.5269184
00:00:01.4638793
00:00:01.4963922
00:00:01.4927520
</code></pre>
<p>It's not easy to write multithreading benchmarks.
People asked me several times about multithreading support in BenchmarkDotNet, but it's not easy to implement.
Of course, it's easy to provide a nice API for such benchmark, but it's hard to achieve stable results.
I don't want to write another benchmarking library which prints <em>some numbers</em>.
If we have a feature, it should work great.
So, we don't support it out of the box, but we can just rewrite the original benchmark with the help of BenchmarkDotNet in a simple way:</p>
<pre><code class="language-cs">[Config(typeof(MonitoringConfig))]
[BenchmarkCategory(&quot;Collections&quot;)]
public class ConcurrentQueueBenchmark3
{
  private ConcurrentQueue&lt;int&gt; q = new ConcurrentQueue&lt;int&gt;();

  [Params(100_000_000)]
  public int N;

  [Benchmark]
  public void Run()
  {
    Task consumer = Task.Run(() =&gt;
    {
      int total = 0;
      while (total &lt; N) if (q.TryDequeue(out int _)) total++;
    });
    for (int i = 0; i &lt; N; i++)
      q.Enqueue(i);
    consumer.Wait();
  }
}
</code></pre>
<p>Here we use <code>MonitoringConfig</code> instead of <code>MainConfig</code>:</p>
<pre><code>public class MonitoringConfig : ManualConfig
{
  public MonitoringConfig()
  {
    Add(Job.Default.With(RunStrategy.Monitoring).With(Runtime.Clr).With(Jit.RyuJit).With(Platform.X64).WithId(&quot;NET4.7_RyuJIT-x64&quot;));
    Add(Job.Default.With(RunStrategy.Monitoring).With(Runtime.Mono).WithId(&quot;Mono5.0.1-x64&quot;));
    Add(Job.Default.With(RunStrategy.Monitoring).With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp20).WithId(&quot;Core2.0-x64&quot;));
    Add(RPlotExporter.Default);
    KeepBenchmarkFiles = true;
  }
}
</code></pre>
<p>Mainly, BenchmarkDotNet is focusing on microbenchmarking.
If you measure a method which takes seconds, the whole benchmarking process can take too much time.
<code>RunStrategy.Monitoring</code> is designed for macrobenchmarks, it allows getting good results in a short period of time.
One day we will support such method out of the box, but currently <code>Monitoring</code> is our choice (<a href="http://benchmarkdotnet.org/Guides/ChoosingRunStrategy.htm">more about run strategies</a>).</p>
<p>The results:</p>
<table>
<thead>
<tr>
<th>Job</th>
<th>N</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core2.0-x64</td>
<td>100000000</td>
<td style="text-align: right;">1.720 s</td>
<td style="text-align: right;">0.3313 s</td>
<td style="text-align: right;">0.2191 s</td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td>100000000</td>
<td style="text-align: right;">6.829 s</td>
<td style="text-align: right;">0.9576 s</td>
<td style="text-align: right;">0.6334 s</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td>100000000</td>
<td style="text-align: right;">6.042 s</td>
<td style="text-align: right;">0.4212 s</td>
<td style="text-align: right;">0.2786 s</td>
</tr>
</tbody>
</table>
<p>The original speedup is <code>~4x..5.3x</code>, the new speedup is <code>~3.5x</code>.
The important point here is the following: the standard deviation is huge.
Let's look again at a few of the original results for <code>.NET Framework 4.7</code>:</p>
<pre><code>00:00:05.5487718
00:00:06.6069291
</code></pre>
<p>There is a huge difference between measurements.
It's not enough to do only five iterations in such case!
Here is the box plot:</p>
<div class="mx-auto"><img class="mx-auto d-block" width="600" src="/img/posts/stephen-toub-benchmarks-part1/ConcurrentQueueBenchmark3-boxplot.png" /></div>
<p>Probably another case of a bimodal distribution?
Let's look at the density plot:</p>
<div class="mx-auto"><img class="mx-auto d-block" width="600" src="/img/posts/stephen-toub-benchmarks-part1/ConcurrentQueueBenchmark3-Run-density.png" /></div>
<p>It's not a bimodal distribution; it's just a distribution of strange form with huge <code>StdDev</code>.</p>
<h4 id="concurrentbag">ConcurrentBag</h4>
<p>The original benchmark:</p>
<pre><code class="language-cs">while (true)
{
  var q = new ConcurrentBag&lt;int&gt;() { 1, 2 };
  var sw = new Stopwatch();

  int gen0 = GC.CollectionCount(0), gen1 = GC.CollectionCount(1), gen2 = GC.CollectionCount(2);
  sw.Start();

  for (int i = 0; i &lt; 100_000_000; i++)
  {
    q.Add(i);
    q.TryTake(out int _);
  }

  sw.Stop();
  Console.WriteLine($&quot;Elapsed={sw.Elapsed} Gen0={GC.CollectionCount(0) - gen0} Gen1={GC.CollectionCount(1) - gen1} Gen2={GC.CollectionCount(2) - gen2}&quot;);
}
</code></pre>
<p>The original results:</p>
<pre><code class="language-cs">// .NET Framework 4.7
Elapsed=00:00:06.5672723 Gen0=953 Gen1=0 Gen2=0
Elapsed=00:00:06.4829793 Gen0=954 Gen1=1 Gen2=0
Elapsed=00:00:06.9008532 Gen0=954 Gen1=0 Gen2=0
Elapsed=00:00:06.6485667 Gen0=953 Gen1=1 Gen2=0
Elapsed=00:00:06.4671746 Gen0=954 Gen1=1 Gen2=0
// .NET Core 2.0 Preview 1
Elapsed=00:00:04.3377355 Gen0=0 Gen1=0 Gen2=0
Elapsed=00:00:04.2892791 Gen0=0 Gen1=0 Gen2=0
Elapsed=00:00:04.3101593 Gen0=0 Gen1=0 Gen2=0
Elapsed=00:00:04.2652497 Gen0=0 Gen1=0 Gen2=0
Elapsed=00:00:04.2808077 Gen0=0 Gen1=0 Gen2=0
</code></pre>
<p>A new benchmark:</p>
<pre><code class="language-cs">[Config(typeof(MainConfig))]
[BenchmarkCategory(&quot;Collections&quot;)]
[MemoryDiagnoser]
public class ConcurrentBag
{
  private ConcurrentBag&lt;int&gt; q = new ConcurrentBag&lt;int&gt; { 1, 2 };

  [Benchmark]
  public void Run()
  {
    q.Add(0);
    q.TryTake(out int _);
  }
}
</code></pre>
<table>
<thead>
<tr>
<th>Job</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Gen 0</th>
<th style="text-align: right;">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core2.0-x64</td>
<td style="text-align: right;">56.47 ns</td>
<td style="text-align: right;">1.1561 ns</td>
<td style="text-align: right;">2.1140 ns</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">0 B</td>
</tr>
<tr>
<td>Mono5.0.1-x64</td>
<td style="text-align: right;">162.82 ns</td>
<td style="text-align: right;">0.2874 ns</td>
<td style="text-align: right;">0.2548 ns</td>
<td style="text-align: right;">0.0086</td>
<td style="text-align: right;">N/A</td>
</tr>
<tr>
<td>NET4.7_RyuJIT-x64</td>
<td style="text-align: right;">82.52 ns</td>
<td style="text-align: right;">0.2572 ns</td>
<td style="text-align: right;">0.2008 ns</td>
<td style="text-align: right;">0.0126</td>
<td style="text-align: right;">40 B</td>
</tr>
</tbody>
</table>
<p>The original speedup is <code>~1.5x</code>, the new speedup is <code>~1.37x</code> (almost the same).</p>
<p>By the way, Mono works slowly again: about two times slower than the full framework.
On <code>.NET Core 2.0 Preview 1</code>, we got another bimodal distributions, here is a timeline plot:</p>
<div class="mx-auto"><img class="mx-auto d-block" width="600" src="/img/posts/stephen-toub-benchmarks-part1/ConcurrentBag-Run-Core2.0-x64-timelineSmooth.png" /></div>
<h3 id="conclusion">Conclusion</h3>
<p>Could we say that .NET Core is always the fastest runtime?
No.
We looked only at specific cases related to coreclr-specific optimizations.
These benchmarks <em>are designed</em> to show how fast .NET Core is.
I'm no saying that .NET Core is a bad runtime,
I'm saying that I can write an own set of benchmarks which show that the best runtime is the .NET Framework or Mono.
Anyway, .NET Core is a great project.
Guys from Microsoft (with the help of the community) did (and continue to do) an awesome job.
The .NET Core indeed has awesome performance improvements.
However, it's not a good idea to blindly believe that the .NET Core will always be super-fast for all the cases.
(Also it's not a good idea to blindly believe in any information which you read on the internet.)</p>
<p>If you are want to migrate to .NET Core and get better performance for free, you should write own benchmarks first.
Find bottleneck methods in your software,
design the corresponded benchmarks based on users use cases,
check different environment,
perform a thoughtful analysis (it's the most important part).
Only after this, you can make correct conclusions about the best .NET runtime <em>for you</em>.
I hope now you understand that it's not easy to design proper benchmarks (even if you use BenchmarkDotNet).
This activity requires a lot of time and skills.</p>
<p>If you want to check out how it's work in your environment (or make some additional experiments), here is a repo for you:
<a href="https://github.com/AndreyAkinshin/StephenToubBenchmarks">AndreyAkinshin/StephenToubBenchmarks</a>.
In this post, I didn't make real performance investigations (it wasn't my purpose):
I just tried to explain basic benchmarking concepts and show how to use BenchmarkDotNet.
This post contains only <em>drafts</em> of future benchmarks.
I wrote it in a few hours and maybe I made mistakes (actually, 90% of any benchmarking activity is making mistakes).
However, I hope that you have learned a few interesting benchmarking tricks.</p>
<p>You may notice that I didn't show all the benchmarks from the original post.
I implemented almost all of them in the GitHub repo, but
I just didn't have enough time to collect all measurements and write explanations.
There are a lot of interesting fundamental benchmark errors there,
but I want to get some feedback first.
Is it an interesting topic?
Is it worth to explain all the benchmarks and how they can be improved?
If so, I will be happy to explain in detail what happens in each case
(I hope that these explanations will help people to design correct benchmark for similar cases).</p>
</div>

<script src="/js/toc.js"></script>
<script type="text/javascript">
$(document).ready(function() {
    $('#toc').toc({
        title: '<h2>Table of Contents</h2>',
        noBackToTopLinks: true,
        listType: 'ol',
        showEffect: 'none',
        showSpeed: '0',
        headers: '.blog-post-toc h3, .blog-post-toc h4, .blog-post-toc h5, .blog-post-toc h6'
    });
});
</script>

<!-- Share -->

Share:
<a href="https://twitter.com/intent/tweet?text=Measuring Performance Improvements in .NET Core with BenchmarkDotNet (Part 1)&url=http://aakinshin.net/blog/post/stephen-toub-benchmarks-part1/&via=andrey_akinshin&related=andrey_akinshin" rel="nofollow" target="_blank" title="Share on Twitter"><img class="share-button" src="/img/icons/twitter.png" alt="" /></a>
<a href="https://www.reddit.com/submit?url=http://aakinshin.net/blog/post/stephen-toub-benchmarks-part1/" target="_blank" title="Share on Reddit"> <img class="share-button" src="/img/icons/reddit.png" alt="" border="0" /> </a>
<a href="https://news.ycombinator.com/submitlink?u=http://aakinshin.net/blog/post/stephen-toub-benchmarks-part1/" target="_blank" title="Share on HackerNews"> <img class="share-button" src="/img/icons/hn.png" alt="" border="0" /> </a>
<a href="https://facebook.com/sharer.php?u=http://aakinshin.net/blog/post/stephen-toub-benchmarks-part1/" rel="nofollow" target="_blank" title="Share on Facebook"><img class="share-button" src="/img/icons/facebook.png" alt="" /></a>
<a href="https://plus.google.com/share?url=http://aakinshin.net/blog/post/stephen-toub-benchmarks-part1/" rel="nofollow" target="_blank" title="Share on Google+"><img class="share-button" src="/img/icons/google-plus.png" alt="" /></a>
<a href="http://vk.com/share.php?url=http://aakinshin.net/blog/post/stephen-toub-benchmarks-part1/" target="_blank" title="Share on VKontakte"><img class="share-button" src="/img/icons/vk.png" alt="" /></a>
<hr />

<!-- GitHub -->
<div>
  You can find source code of this post on GitHub:<br />
  <a href="https://github.com/AndreyAkinshin/aakinshin.net/blob/master/web/_posts/en/2017/stephen-toub-benchmarks-part1.md">https://github.com/AndreyAkinshin/aakinshin.net/blob/master/web/_posts/en/2017/stephen-toub-benchmarks-part1.md</a>
</div>

<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    // Disqus
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'aakinshinnet-en'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>
</div>
    </div>

    <footer class="blog-footer">
      <div class="container">
        <p>&copy; 2014–2017 Andrey Akinshin</p>
      </div>
    </footer>

    <!-- jQuery first (header), then Tether, then Bootstrap JS. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
    <!-- Other scripts -->
    <script src="/js/highlight.pack.js"></script>
    <script src="/js/anchor.min.js"></script>
    <script src="/js/custom.js"></script>
  </body>
</html>
